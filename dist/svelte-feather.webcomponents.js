(() => {
  // node_modules/svelte/internal/index.mjs
  function noop() {
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  var tasks = new Set();
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    node.parentNode.removeChild(node);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function children(element) {
    return Array.from(element.childNodes);
  }
  function attribute_to_object(attributes) {
    const result = {};
    for (const attribute of attributes) {
      result[attribute.name] = attribute.value;
    }
    return result;
  }
  var active_docs = new Set();
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var flushing = false;
  var seen_callbacks = new Set();
  function flush() {
    if (flushing)
      return;
    flushing = true;
    do {
      for (let i = 0; i < dirty_components.length; i += 1) {
        const component = dirty_components[i];
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  var outroing = new Set();
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  var boolean_attributes = new Set([
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]);
  function mount_component(component, target, anchor, customElement) {
    const {fragment, on_mount, on_destroy, after_update} = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance287, create_fragment287, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: null,
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(parent_component ? parent_component.$$.context : []),
      callbacks: blank_object(),
      dirty,
      skip_bound: false
    };
    let ready = false;
    $$.ctx = instance287 ? instance287(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment287 ? create_fragment287($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({mode: "open"});
      }
      connectedCallback() {
        const {on_mount} = this.$$;
        this.$$.on_disconnect = on_mount.map(run).filter(is_function);
        for (const key in this.$$.slotted) {
          this.appendChild(this.$$.slotted[key]);
        }
      }
      attributeChangedCallback(attr2, _oldValue, newValue) {
        this[attr2] = newValue;
      }
      disconnectedCallback() {
        run_all(this.$$.on_disconnect);
      }
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
  }

  // util.js
  var ICON_SIZES = {
    default: "default",
    tiny: "tiny",
    small: "small",
    medium: "medium",
    large: "large",
    huge: "huge"
  };
  var ICON_SIZE_UNITS = {
    [ICON_SIZES.default]: "1em",
    [ICON_SIZES.tiny]: "12px",
    [ICON_SIZES.small]: "16px",
    [ICON_SIZES.medium]: "24px",
    [ICON_SIZES.large]: "32px",
    [ICON_SIZES.huge]: "48px"
  };
  function is_size_primitive(value) {
    return value.endsWith("%") || value.endsWith("px") || value.endsWith("em") || value.endsWith("rem");
  }

  // components/Activity.svelte
  function create_fragment(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "22 12 18 12 15 21 9 3 6 12 2 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-activity feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-activity feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Activity = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance, create_fragment, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-activity", Activity);

  // components/Airplay.svelte
  function create_fragment2(ctx) {
    let svg;
    let path;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(path, "d", "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1");
        attr(polygon, "points", "12 15 17 21 7 21 12 15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-airplay feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-airplay feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance2($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Airplay = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance2, create_fragment2, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-airplay", Airplay);

  // components/AlertCircle.svelte
  function create_fragment3(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "12");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "16");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-alert-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-alert-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance3($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlertCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance3, create_fragment3, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-alert-circle", AlertCircle);

  // components/AlertOctagon.svelte
  function create_fragment4(ctx) {
    let svg;
    let polygon;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
        attr(line0, "x1", "12");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "16");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-alert-octagon feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-alert-octagon feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance4($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlertOctagon = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance4, create_fragment4, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-alert-octagon", AlertOctagon);

  // components/AlertTriangle.svelte
  function create_fragment5(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
        attr(line0, "x1", "12");
        attr(line0, "y1", "9");
        attr(line0, "x2", "12");
        attr(line0, "y2", "13");
        attr(line1, "x1", "12");
        attr(line1, "y1", "17");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-alert-triangle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-alert-triangle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance5($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlertTriangle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance5, create_fragment5, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-alert-triangle", AlertTriangle);

  // components/AlignCenter.svelte
  function create_fragment6(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "18");
        attr(line0, "y1", "10");
        attr(line0, "x2", "6");
        attr(line0, "y2", "10");
        attr(line1, "x1", "21");
        attr(line1, "y1", "6");
        attr(line1, "x2", "3");
        attr(line1, "y2", "6");
        attr(line2, "x1", "21");
        attr(line2, "y1", "14");
        attr(line2, "x2", "3");
        attr(line2, "y2", "14");
        attr(line3, "x1", "18");
        attr(line3, "y1", "18");
        attr(line3, "x2", "6");
        attr(line3, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-align-center feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-align-center feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance6($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlignCenter = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance6, create_fragment6, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-align-center", AlignCenter);

  // components/AlignJustify.svelte
  function create_fragment7(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "21");
        attr(line0, "y1", "10");
        attr(line0, "x2", "3");
        attr(line0, "y2", "10");
        attr(line1, "x1", "21");
        attr(line1, "y1", "6");
        attr(line1, "x2", "3");
        attr(line1, "y2", "6");
        attr(line2, "x1", "21");
        attr(line2, "y1", "14");
        attr(line2, "x2", "3");
        attr(line2, "y2", "14");
        attr(line3, "x1", "21");
        attr(line3, "y1", "18");
        attr(line3, "x2", "3");
        attr(line3, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-align-justify feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-align-justify feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance7($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlignJustify = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance7, create_fragment7, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-align-justify", AlignJustify);

  // components/AlignLeft.svelte
  function create_fragment8(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "17");
        attr(line0, "y1", "10");
        attr(line0, "x2", "3");
        attr(line0, "y2", "10");
        attr(line1, "x1", "21");
        attr(line1, "y1", "6");
        attr(line1, "x2", "3");
        attr(line1, "y2", "6");
        attr(line2, "x1", "21");
        attr(line2, "y1", "14");
        attr(line2, "x2", "3");
        attr(line2, "y2", "14");
        attr(line3, "x1", "17");
        attr(line3, "y1", "18");
        attr(line3, "x2", "3");
        attr(line3, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-align-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-align-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance8($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlignLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance8, create_fragment8, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-align-left", AlignLeft);

  // components/AlignRight.svelte
  function create_fragment9(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "21");
        attr(line0, "y1", "10");
        attr(line0, "x2", "7");
        attr(line0, "y2", "10");
        attr(line1, "x1", "21");
        attr(line1, "y1", "6");
        attr(line1, "x2", "3");
        attr(line1, "y2", "6");
        attr(line2, "x1", "21");
        attr(line2, "y1", "14");
        attr(line2, "x2", "3");
        attr(line2, "y2", "14");
        attr(line3, "x1", "21");
        attr(line3, "y1", "18");
        attr(line3, "x2", "7");
        attr(line3, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-align-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-align-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance9($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AlignRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance9, create_fragment9, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-align-right", AlignRight);

  // components/Anchor.svelte
  function create_fragment10(ctx) {
    let svg;
    let circle;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "5");
        attr(circle, "r", "3");
        attr(line, "x1", "12");
        attr(line, "y1", "22");
        attr(line, "x2", "12");
        attr(line, "y2", "8");
        attr(path, "d", "M5 12H2a10 10 0 0 0 20 0h-3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-anchor feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-anchor feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance10($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Anchor = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance10, create_fragment10, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-anchor", Anchor);

  // components/Aperture.svelte
  function create_fragment11(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "14.31");
        attr(line0, "y1", "8");
        attr(line0, "x2", "20.05");
        attr(line0, "y2", "17.94");
        attr(line1, "x1", "9.69");
        attr(line1, "y1", "8");
        attr(line1, "x2", "21.17");
        attr(line1, "y2", "8");
        attr(line2, "x1", "7.38");
        attr(line2, "y1", "12");
        attr(line2, "x2", "13.12");
        attr(line2, "y2", "2.06");
        attr(line3, "x1", "9.69");
        attr(line3, "y1", "16");
        attr(line3, "x2", "3.95");
        attr(line3, "y2", "6.06");
        attr(line4, "x1", "14.31");
        attr(line4, "y1", "16");
        attr(line4, "x2", "2.83");
        attr(line4, "y2", "16");
        attr(line5, "x1", "16.62");
        attr(line5, "y1", "12");
        attr(line5, "x2", "10.88");
        attr(line5, "y2", "21.94");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-aperture feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-aperture feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance11($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Aperture = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance11, create_fragment11, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-aperture", Aperture);

  // components/Archive.svelte
  function create_fragment12(ctx) {
    let svg;
    let polyline;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(polyline, "points", "21 8 21 21 3 21 3 8");
        attr(rect, "x", "1");
        attr(rect, "y", "3");
        attr(rect, "width", "22");
        attr(rect, "height", "5");
        attr(line, "x1", "10");
        attr(line, "y1", "12");
        attr(line, "x2", "14");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-archive feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-archive feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance12($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Archive = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance12, create_fragment12, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-archive", Archive);

  // components/ArrowDownCircle.svelte
  function create_fragment13(ctx) {
    let svg;
    let circle;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polyline, "points", "8 12 12 16 16 12");
        attr(line, "x1", "12");
        attr(line, "y1", "8");
        attr(line, "x2", "12");
        attr(line, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-down-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance13($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowDownCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance13, create_fragment13, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-down-circle", ArrowDownCircle);

  // components/ArrowDownLeft.svelte
  function create_fragment14(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "17");
        attr(line, "y1", "7");
        attr(line, "x2", "7");
        attr(line, "y2", "17");
        attr(polyline, "points", "17 17 7 17 7 7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-down-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance14($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowDownLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance14, create_fragment14, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-down-left", ArrowDownLeft);

  // components/ArrowDownRight.svelte
  function create_fragment15(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "7");
        attr(line, "y1", "7");
        attr(line, "x2", "17");
        attr(line, "y2", "17");
        attr(polyline, "points", "17 7 17 17 7 17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-down-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance15($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowDownRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance15, create_fragment15, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-down-right", ArrowDownRight);

  // components/ArrowDown.svelte
  function create_fragment16(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "12");
        attr(line, "y1", "5");
        attr(line, "x2", "12");
        attr(line, "y2", "19");
        attr(polyline, "points", "19 12 12 19 5 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance16($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance16, create_fragment16, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-down", ArrowDown);

  // components/ArrowLeftCircle.svelte
  function create_fragment17(ctx) {
    let svg;
    let circle;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polyline, "points", "12 8 8 12 12 16");
        attr(line, "x1", "16");
        attr(line, "y1", "12");
        attr(line, "x2", "8");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-left-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-left-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance17($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowLeftCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance17, create_fragment17, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-left-circle", ArrowLeftCircle);

  // components/ArrowLeft.svelte
  function create_fragment18(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "19");
        attr(line, "y1", "12");
        attr(line, "x2", "5");
        attr(line, "y2", "12");
        attr(polyline, "points", "12 19 5 12 12 5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance18($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance18, create_fragment18, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-left", ArrowLeft);

  // components/ArrowRightCircle.svelte
  function create_fragment19(ctx) {
    let svg;
    let circle;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polyline, "points", "12 16 16 12 12 8");
        attr(line, "x1", "8");
        attr(line, "y1", "12");
        attr(line, "x2", "16");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-right-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-right-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance19($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowRightCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance19, create_fragment19, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-right-circle", ArrowRightCircle);

  // components/ArrowRight.svelte
  function create_fragment20(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "5");
        attr(line, "y1", "12");
        attr(line, "x2", "19");
        attr(line, "y2", "12");
        attr(polyline, "points", "12 5 19 12 12 19");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance20($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance20, create_fragment20, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-right", ArrowRight);

  // components/ArrowUpCircle.svelte
  function create_fragment21(ctx) {
    let svg;
    let circle;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polyline, "points", "16 12 12 8 8 12");
        attr(line, "x1", "12");
        attr(line, "y1", "16");
        attr(line, "x2", "12");
        attr(line, "y2", "8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-up-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance21($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowUpCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance21, create_fragment21, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-up-circle", ArrowUpCircle);

  // components/ArrowUpLeft.svelte
  function create_fragment22(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "17");
        attr(line, "y1", "17");
        attr(line, "x2", "7");
        attr(line, "y2", "7");
        attr(polyline, "points", "7 17 7 7 17 7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-up-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance22($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowUpLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance22, create_fragment22, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-up-left", ArrowUpLeft);

  // components/ArrowUpRight.svelte
  function create_fragment23(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "7");
        attr(line, "y1", "17");
        attr(line, "x2", "17");
        attr(line, "y2", "7");
        attr(polyline, "points", "7 7 17 7 17 17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-up-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance23($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowUpRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance23, create_fragment23, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-up-right", ArrowUpRight);

  // components/ArrowUp.svelte
  function create_fragment24(ctx) {
    let svg;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(line, "x1", "12");
        attr(line, "y1", "19");
        attr(line, "x2", "12");
        attr(line, "y2", "5");
        attr(polyline, "points", "5 12 12 5 19 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-arrow-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance24($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ArrowUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance24, create_fragment24, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-arrow-up", ArrowUp);

  // components/AtSign.svelte
  function create_fragment25(ctx) {
    let svg;
    let circle;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "4");
        attr(path, "d", "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-at-sign feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-at-sign feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance25($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var AtSign = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance25, create_fragment25, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-at-sign", AtSign);

  // components/Award.svelte
  function create_fragment26(ctx) {
    let svg;
    let circle;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "8");
        attr(circle, "r", "7");
        attr(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-award feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-award feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance26($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Award = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance26, create_fragment26, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-award", Award);

  // components/BarChart2.svelte
  function create_fragment27(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "18");
        attr(line0, "y1", "20");
        attr(line0, "x2", "18");
        attr(line0, "y2", "10");
        attr(line1, "x1", "12");
        attr(line1, "y1", "20");
        attr(line1, "x2", "12");
        attr(line1, "y2", "4");
        attr(line2, "x1", "6");
        attr(line2, "y1", "20");
        attr(line2, "x2", "6");
        attr(line2, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bar-chart-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bar-chart-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance27($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var BarChart2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance27, create_fragment27, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bar-chart-2", BarChart2);

  // components/BarChart.svelte
  function create_fragment28(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "12");
        attr(line0, "y1", "20");
        attr(line0, "x2", "12");
        attr(line0, "y2", "10");
        attr(line1, "x1", "18");
        attr(line1, "y1", "20");
        attr(line1, "x2", "18");
        attr(line1, "y2", "4");
        attr(line2, "x1", "6");
        attr(line2, "y1", "20");
        attr(line2, "x2", "6");
        attr(line2, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bar-chart feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bar-chart feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance28($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var BarChart = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance28, create_fragment28, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bar-chart", BarChart);

  // components/BatteryCharging.svelte
  function create_fragment29(ctx) {
    let svg;
    let path;
    let line;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19");
        attr(line, "x1", "23");
        attr(line, "y1", "13");
        attr(line, "x2", "23");
        attr(line, "y2", "11");
        attr(polyline, "points", "11 6 7 12 13 12 9 18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-battery-charging feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-battery-charging feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance29($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var BatteryCharging = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance29, create_fragment29, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-battery-charging", BatteryCharging);

  // components/Battery.svelte
  function create_fragment30(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "1");
        attr(rect, "y", "6");
        attr(rect, "width", "18");
        attr(rect, "height", "12");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "23");
        attr(line, "y1", "13");
        attr(line, "x2", "23");
        attr(line, "y2", "11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-battery feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-battery feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance30($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Battery = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance30, create_fragment30, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-battery", Battery);

  // components/BellOff.svelte
  function create_fragment31(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path0, "d", "M13.73 21a2 2 0 0 1-3.46 0");
        attr(path1, "d", "M18.63 13A17.89 17.89 0 0 1 18 8");
        attr(path2, "d", "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14");
        attr(path3, "d", "M18 8a6 6 0 0 0-9.33-5");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bell-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bell-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance31($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var BellOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance31, create_fragment31, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bell-off", BellOff);

  // components/Bell.svelte
  function create_fragment32(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");
        attr(path1, "d", "M13.73 21a2 2 0 0 1-3.46 0");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bell feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bell feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance32($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Bell = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance32, create_fragment32, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bell", Bell);

  // components/Bluetooth.svelte
  function create_fragment33(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bluetooth feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bluetooth feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance33($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Bluetooth = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance33, create_fragment33, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bluetooth", Bluetooth);

  // components/Bold.svelte
  function create_fragment34(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
        attr(path1, "d", "M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bold feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bold feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance34($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Bold = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance34, create_fragment34, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bold", Bold);

  // components/BookOpen.svelte
  function create_fragment35(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
        attr(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-book-open feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-book-open feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance35($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var BookOpen = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance35, create_fragment35, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-book-open", BookOpen);

  // components/Book.svelte
  function create_fragment36(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
        attr(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-book feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-book feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance36($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Book = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance36, create_fragment36, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-book", Book);

  // components/Bookmark.svelte
  function create_fragment37(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-bookmark feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-bookmark feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance37($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Bookmark = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance37, create_fragment37, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-bookmark", Bookmark);

  // components/Box.svelte
  function create_fragment38(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
        attr(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
        attr(line, "x1", "12");
        attr(line, "y1", "22.08");
        attr(line, "x2", "12");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-box feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-box feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance38($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Box = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance38, create_fragment38, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-box", Box);

  // components/Briefcase.svelte
  function create_fragment39(ctx) {
    let svg;
    let rect;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        path = svg_element("path");
        this.c = noop;
        attr(rect, "x", "2");
        attr(rect, "y", "7");
        attr(rect, "width", "20");
        attr(rect, "height", "14");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(path, "d", "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-briefcase feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-briefcase feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance39($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Briefcase = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance39, create_fragment39, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-briefcase", Briefcase);

  // components/Calendar.svelte
  function create_fragment40(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "4");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "16");
        attr(line0, "y1", "2");
        attr(line0, "x2", "16");
        attr(line0, "y2", "6");
        attr(line1, "x1", "8");
        attr(line1, "y1", "2");
        attr(line1, "x2", "8");
        attr(line1, "y2", "6");
        attr(line2, "x1", "3");
        attr(line2, "y1", "10");
        attr(line2, "x2", "21");
        attr(line2, "y2", "10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-calendar feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-calendar feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance40($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Calendar = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance40, create_fragment40, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-calendar", Calendar);

  // components/CameraOff.svelte
  function create_fragment41(ctx) {
    let svg;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(path, "d", "M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-camera-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-camera-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance41($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CameraOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance41, create_fragment41, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-camera-off", CameraOff);

  // components/Camera.svelte
  function create_fragment42(ctx) {
    let svg;
    let path;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
        attr(circle, "cx", "12");
        attr(circle, "cy", "13");
        attr(circle, "r", "4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-camera feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-camera feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance42($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Camera = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance42, create_fragment42, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-camera", Camera);

  // components/Cast.svelte
  function create_fragment43(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6");
        attr(line, "x1", "2");
        attr(line, "y1", "20");
        attr(line, "x2", "2.01");
        attr(line, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cast feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cast feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance43($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Cast = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance43, create_fragment43, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cast", Cast);

  // components/CheckCircle.svelte
  function create_fragment44(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
        attr(polyline, "points", "22 4 12 14.01 9 11.01");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-check-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-check-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance44($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CheckCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance44, create_fragment44, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-check-circle", CheckCircle);

  // components/CheckSquare.svelte
  function create_fragment45(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "9 11 12 14 22 4");
        attr(path, "d", "M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-check-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-check-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance45($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CheckSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance45, create_fragment45, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-check-square", CheckSquare);

  // components/Check.svelte
  function create_fragment46(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "20 6 9 17 4 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-check feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-check feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance46($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Check = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance46, create_fragment46, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-check", Check);

  // components/ChevronDown.svelte
  function create_fragment47(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "6 9 12 15 18 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevron-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance47($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance47, create_fragment47, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevron-down", ChevronDown);

  // components/ChevronLeft.svelte
  function create_fragment48(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "15 18 9 12 15 6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevron-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance48($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance48, create_fragment48, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevron-left", ChevronLeft);

  // components/ChevronRight.svelte
  function create_fragment49(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "9 18 15 12 9 6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevron-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance49($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance49, create_fragment49, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevron-right", ChevronRight);

  // components/ChevronUp.svelte
  function create_fragment50(ctx) {
    let svg;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(polyline, "points", "18 15 12 9 6 15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevron-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance50($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance50, create_fragment50, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevron-up", ChevronUp);

  // components/ChevronsDown.svelte
  function create_fragment51(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "7 13 12 18 17 13");
        attr(polyline1, "points", "7 6 12 11 17 6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevrons-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance51($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronsDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance51, create_fragment51, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevrons-down", ChevronsDown);

  // components/ChevronsLeft.svelte
  function create_fragment52(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "11 17 6 12 11 7");
        attr(polyline1, "points", "18 17 13 12 18 7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevrons-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance52($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronsLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance52, create_fragment52, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevrons-left", ChevronsLeft);

  // components/ChevronsRight.svelte
  function create_fragment53(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "13 17 18 12 13 7");
        attr(polyline1, "points", "6 17 11 12 6 7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevrons-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance53($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronsRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance53, create_fragment53, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevrons-right", ChevronsRight);

  // components/ChevronsUp.svelte
  function create_fragment54(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "17 11 12 6 7 11");
        attr(polyline1, "points", "17 18 12 13 7 18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chevrons-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance54($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ChevronsUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance54, create_fragment54, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chevrons-up", ChevronsUp);

  // components/Chrome.svelte
  function create_fragment55(ctx) {
    let svg;
    let circle0;
    let circle1;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "10");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "4");
        attr(line0, "x1", "21.17");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "8");
        attr(line1, "x1", "3.95");
        attr(line1, "y1", "6.06");
        attr(line1, "x2", "8.54");
        attr(line1, "y2", "14");
        attr(line2, "x1", "10.88");
        attr(line2, "y1", "21.94");
        attr(line2, "x2", "15.46");
        attr(line2, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-chrome feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-chrome feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance55($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Chrome = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance55, create_fragment55, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-chrome", Chrome);

  // components/Circle.svelte
  function create_fragment56(ctx) {
    let svg;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance56($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Circle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance56, create_fragment56, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-circle", Circle);

  // components/Clipboard.svelte
  function create_fragment57(ctx) {
    let svg;
    let path;
    let rect;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        rect = svg_element("rect");
        this.c = noop;
        attr(path, "d", "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2");
        attr(rect, "x", "8");
        attr(rect, "y", "2");
        attr(rect, "width", "8");
        attr(rect, "height", "4");
        attr(rect, "rx", "1");
        attr(rect, "ry", "1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-clipboard feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, rect);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-clipboard feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance57($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Clipboard = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance57, create_fragment57, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-clipboard", Clipboard);

  // components/Clock.svelte
  function create_fragment58(ctx) {
    let svg;
    let circle;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polyline, "points", "12 6 12 12 16 14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-clock feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-clock feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance58($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Clock = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance58, create_fragment58, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-clock", Clock);

  // components/CloudDrizzle.svelte
  function create_fragment59(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(line0, "x1", "8");
        attr(line0, "y1", "19");
        attr(line0, "x2", "8");
        attr(line0, "y2", "21");
        attr(line1, "x1", "8");
        attr(line1, "y1", "13");
        attr(line1, "x2", "8");
        attr(line1, "y2", "15");
        attr(line2, "x1", "16");
        attr(line2, "y1", "19");
        attr(line2, "x2", "16");
        attr(line2, "y2", "21");
        attr(line3, "x1", "16");
        attr(line3, "y1", "13");
        attr(line3, "x2", "16");
        attr(line3, "y2", "15");
        attr(line4, "x1", "12");
        attr(line4, "y1", "21");
        attr(line4, "x2", "12");
        attr(line4, "y2", "23");
        attr(line5, "x1", "12");
        attr(line5, "y1", "15");
        attr(line5, "x2", "12");
        attr(line5, "y2", "17");
        attr(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud-drizzle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-drizzle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance59($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CloudDrizzle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance59, create_fragment59, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud-drizzle", CloudDrizzle);

  // components/CloudLightning.svelte
  function create_fragment60(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9");
        attr(polyline, "points", "13 11 9 17 15 17 11 23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud-lightning feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-lightning feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance60($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CloudLightning = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance60, create_fragment60, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud-lightning", CloudLightning);

  // components/CloudOff.svelte
  function create_fragment61(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance61($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CloudOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance61, create_fragment61, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud-off", CloudOff);

  // components/CloudRain.svelte
  function create_fragment62(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(line0, "x1", "16");
        attr(line0, "y1", "13");
        attr(line0, "x2", "16");
        attr(line0, "y2", "21");
        attr(line1, "x1", "8");
        attr(line1, "y1", "13");
        attr(line1, "x2", "8");
        attr(line1, "y2", "21");
        attr(line2, "x1", "12");
        attr(line2, "y1", "15");
        attr(line2, "x2", "12");
        attr(line2, "y2", "23");
        attr(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud-rain feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-rain feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance62($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CloudRain = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance62, create_fragment62, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud-rain", CloudRain);

  // components/CloudSnow.svelte
  function create_fragment63(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25");
        attr(line0, "x1", "8");
        attr(line0, "y1", "16");
        attr(line0, "x2", "8.01");
        attr(line0, "y2", "16");
        attr(line1, "x1", "8");
        attr(line1, "y1", "20");
        attr(line1, "x2", "8.01");
        attr(line1, "y2", "20");
        attr(line2, "x1", "12");
        attr(line2, "y1", "18");
        attr(line2, "x2", "12.01");
        attr(line2, "y2", "18");
        attr(line3, "x1", "12");
        attr(line3, "y1", "22");
        attr(line3, "x2", "12.01");
        attr(line3, "y2", "22");
        attr(line4, "x1", "16");
        attr(line4, "y1", "16");
        attr(line4, "x2", "16.01");
        attr(line4, "y2", "16");
        attr(line5, "x1", "16");
        attr(line5, "y1", "20");
        attr(line5, "x2", "16.01");
        attr(line5, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud-snow feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-snow feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance63($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CloudSnow = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance63, create_fragment63, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud-snow", CloudSnow);

  // components/Cloud.svelte
  function create_fragment64(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cloud feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cloud feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance64($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Cloud = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance64, create_fragment64, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cloud", Cloud);

  // components/Code.svelte
  function create_fragment65(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "16 18 22 12 16 6");
        attr(polyline1, "points", "8 6 2 12 8 18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-code feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-code feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance65($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Code = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance65, create_fragment65, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-code", Code);

  // components/Codepen.svelte
  function create_fragment66(ctx) {
    let svg;
    let polygon;
    let line0;
    let polyline0;
    let polyline1;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line0 = svg_element("line");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        line1 = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2");
        attr(line0, "x1", "12");
        attr(line0, "y1", "22");
        attr(line0, "x2", "12");
        attr(line0, "y2", "15.5");
        attr(polyline0, "points", "22 8.5 12 15.5 2 8.5");
        attr(polyline1, "points", "2 15.5 12 8.5 22 15.5");
        attr(line1, "x1", "12");
        attr(line1, "y1", "2");
        attr(line1, "x2", "12");
        attr(line1, "y2", "8.5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-codepen feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line0);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-codepen feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance66($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Codepen = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance66, create_fragment66, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-codepen", Codepen);

  // components/Codesandbox.svelte
  function create_fragment67(ctx) {
    let svg;
    let path;
    let polyline0;
    let polyline1;
    let polyline2;
    let polyline3;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        polyline2 = svg_element("polyline");
        polyline3 = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
        attr(polyline0, "points", "7.5 4.21 12 6.81 16.5 4.21");
        attr(polyline1, "points", "7.5 19.79 7.5 14.6 3 12");
        attr(polyline2, "points", "21 12 16.5 14.6 16.5 19.79");
        attr(polyline3, "points", "3.27 6.96 12 12.01 20.73 6.96");
        attr(line, "x1", "12");
        attr(line, "y1", "22.08");
        attr(line, "x2", "12");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-codesandbox feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, polyline2);
        append(svg, polyline3);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-codesandbox feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance67($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Codesandbox = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance67, create_fragment67, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-codesandbox", Codesandbox);

  // components/Coffee.svelte
  function create_fragment68(ctx) {
    let svg;
    let path0;
    let path1;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(path0, "d", "M18 8h1a4 4 0 0 1 0 8h-1");
        attr(path1, "d", "M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z");
        attr(line0, "x1", "6");
        attr(line0, "y1", "1");
        attr(line0, "x2", "6");
        attr(line0, "y2", "4");
        attr(line1, "x1", "10");
        attr(line1, "y1", "1");
        attr(line1, "x2", "10");
        attr(line1, "y2", "4");
        attr(line2, "x1", "14");
        attr(line2, "y1", "1");
        attr(line2, "x2", "14");
        attr(line2, "y2", "4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-coffee feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-coffee feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance68($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Coffee = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance68, create_fragment68, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-coffee", Coffee);

  // components/Columns.svelte
  function create_fragment69(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-columns feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-columns feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance69($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Columns = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance69, create_fragment69, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-columns", Columns);

  // components/Command.svelte
  function create_fragment70(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-command feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-command feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance70($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Command = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance70, create_fragment70, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-command", Command);

  // components/Compass.svelte
  function create_fragment71(ctx) {
    let svg;
    let circle;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polygon, "points", "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-compass feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-compass feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance71($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Compass = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance71, create_fragment71, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-compass", Compass);

  // components/Copy.svelte
  function create_fragment72(ctx) {
    let svg;
    let rect;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        path = svg_element("path");
        this.c = noop;
        attr(rect, "x", "9");
        attr(rect, "y", "9");
        attr(rect, "width", "13");
        attr(rect, "height", "13");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(path, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-copy feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-copy feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance72($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Copy = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance72, create_fragment72, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-copy", Copy);

  // components/CornerDownLeft.svelte
  function create_fragment73(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "9 10 4 15 9 20");
        attr(path, "d", "M20 4v7a4 4 0 0 1-4 4H4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-down-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-down-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance73($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerDownLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance73, create_fragment73, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-down-left", CornerDownLeft);

  // components/CornerDownRight.svelte
  function create_fragment74(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "15 10 20 15 15 20");
        attr(path, "d", "M4 4v7a4 4 0 0 0 4 4h12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-down-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-down-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance74($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerDownRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance74, create_fragment74, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-down-right", CornerDownRight);

  // components/CornerLeftDown.svelte
  function create_fragment75(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "14 15 9 20 4 15");
        attr(path, "d", "M20 4h-7a4 4 0 0 0-4 4v12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-left-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-left-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance75($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerLeftDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance75, create_fragment75, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-left-down", CornerLeftDown);

  // components/CornerLeftUp.svelte
  function create_fragment76(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "14 9 9 4 4 9");
        attr(path, "d", "M20 20h-7a4 4 0 0 1-4-4V4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-left-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-left-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance76($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerLeftUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance76, create_fragment76, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-left-up", CornerLeftUp);

  // components/CornerRightDown.svelte
  function create_fragment77(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "10 15 15 20 20 15");
        attr(path, "d", "M4 4h7a4 4 0 0 1 4 4v12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-right-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-right-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance77($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerRightDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance77, create_fragment77, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-right-down", CornerRightDown);

  // components/CornerRightUp.svelte
  function create_fragment78(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "10 9 15 4 20 9");
        attr(path, "d", "M4 20h7a4 4 0 0 0 4-4V4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-right-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-right-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance78($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerRightUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance78, create_fragment78, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-right-up", CornerRightUp);

  // components/CornerUpLeft.svelte
  function create_fragment79(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "9 14 4 9 9 4");
        attr(path, "d", "M20 20v-7a4 4 0 0 0-4-4H4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-up-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-up-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance79($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerUpLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance79, create_fragment79, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-up-left", CornerUpLeft);

  // components/CornerUpRight.svelte
  function create_fragment80(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "15 14 20 9 15 4");
        attr(path, "d", "M4 20v-7a4 4 0 0 1 4-4h12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-corner-up-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-corner-up-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance80($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CornerUpRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance80, create_fragment80, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-corner-up-right", CornerUpRight);

  // components/Cpu.svelte
  function create_fragment81(ctx) {
    let svg;
    let rect0;
    let rect1;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let line6;
    let line7;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect0 = svg_element("rect");
        rect1 = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        line6 = svg_element("line");
        line7 = svg_element("line");
        this.c = noop;
        attr(rect0, "x", "4");
        attr(rect0, "y", "4");
        attr(rect0, "width", "16");
        attr(rect0, "height", "16");
        attr(rect0, "rx", "2");
        attr(rect0, "ry", "2");
        attr(rect1, "x", "9");
        attr(rect1, "y", "9");
        attr(rect1, "width", "6");
        attr(rect1, "height", "6");
        attr(line0, "x1", "9");
        attr(line0, "y1", "1");
        attr(line0, "x2", "9");
        attr(line0, "y2", "4");
        attr(line1, "x1", "15");
        attr(line1, "y1", "1");
        attr(line1, "x2", "15");
        attr(line1, "y2", "4");
        attr(line2, "x1", "9");
        attr(line2, "y1", "20");
        attr(line2, "x2", "9");
        attr(line2, "y2", "23");
        attr(line3, "x1", "15");
        attr(line3, "y1", "20");
        attr(line3, "x2", "15");
        attr(line3, "y2", "23");
        attr(line4, "x1", "20");
        attr(line4, "y1", "9");
        attr(line4, "x2", "23");
        attr(line4, "y2", "9");
        attr(line5, "x1", "20");
        attr(line5, "y1", "14");
        attr(line5, "x2", "23");
        attr(line5, "y2", "14");
        attr(line6, "x1", "1");
        attr(line6, "y1", "9");
        attr(line6, "x2", "4");
        attr(line6, "y2", "9");
        attr(line7, "x1", "1");
        attr(line7, "y1", "14");
        attr(line7, "x2", "4");
        attr(line7, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-cpu feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect0);
        append(svg, rect1);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, line6);
        append(svg, line7);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-cpu feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance81($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Cpu = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance81, create_fragment81, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-cpu", Cpu);

  // components/CreditCard.svelte
  function create_fragment82(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "1");
        attr(rect, "y", "4");
        attr(rect, "width", "22");
        attr(rect, "height", "16");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "1");
        attr(line, "y1", "10");
        attr(line, "x2", "23");
        attr(line, "y2", "10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-credit-card feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-credit-card feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance82($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var CreditCard = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance82, create_fragment82, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-credit-card", CreditCard);

  // components/Crop.svelte
  function create_fragment83(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M6.13 1L6 16a2 2 0 0 0 2 2h15");
        attr(path1, "d", "M1 6.13L16 6a2 2 0 0 1 2 2v15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-crop feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-crop feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance83($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Crop = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance83, create_fragment83, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-crop", Crop);

  // components/Crosshair.svelte
  function create_fragment84(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "22");
        attr(line0, "y1", "12");
        attr(line0, "x2", "18");
        attr(line0, "y2", "12");
        attr(line1, "x1", "6");
        attr(line1, "y1", "12");
        attr(line1, "x2", "2");
        attr(line1, "y2", "12");
        attr(line2, "x1", "12");
        attr(line2, "y1", "6");
        attr(line2, "x2", "12");
        attr(line2, "y2", "2");
        attr(line3, "x1", "12");
        attr(line3, "y1", "22");
        attr(line3, "x2", "12");
        attr(line3, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-crosshair feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-crosshair feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance84($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Crosshair = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance84, create_fragment84, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-crosshair", Crosshair);

  // components/Database.svelte
  function create_fragment85(ctx) {
    let svg;
    let ellipse;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        ellipse = svg_element("ellipse");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(ellipse, "cx", "12");
        attr(ellipse, "cy", "5");
        attr(ellipse, "rx", "9");
        attr(ellipse, "ry", "3");
        attr(path0, "d", "M21 12c0 1.66-4 3-9 3s-9-1.34-9-3");
        attr(path1, "d", "M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-database feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, ellipse);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-database feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance85($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Database = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance85, create_fragment85, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-database", Database);

  // components/Delete.svelte
  function create_fragment86(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z");
        attr(line0, "x1", "18");
        attr(line0, "y1", "9");
        attr(line0, "x2", "12");
        attr(line0, "y2", "15");
        attr(line1, "x1", "12");
        attr(line1, "y1", "9");
        attr(line1, "x2", "18");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-delete feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-delete feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance86($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Delete = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance86, create_fragment86, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-delete", Delete);

  // components/Disc.svelte
  function create_fragment87(ctx) {
    let svg;
    let circle0;
    let circle1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "10");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-disc feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-disc feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance87($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Disc = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance87, create_fragment87, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-disc", Disc);

  // components/DivideCircle.svelte
  function create_fragment88(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        circle = svg_element("circle");
        this.c = noop;
        attr(line0, "x1", "8");
        attr(line0, "y1", "12");
        attr(line0, "x2", "16");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "16");
        attr(line1, "x2", "12");
        attr(line1, "y2", "16");
        attr(line2, "x1", "12");
        attr(line2, "y1", "8");
        attr(line2, "x2", "12");
        attr(line2, "y2", "8");
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-divide-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-divide-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance88($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var DivideCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance88, create_fragment88, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-divide-circle", DivideCircle);

  // components/DivideSquare.svelte
  function create_fragment89(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "8");
        attr(line0, "y1", "12");
        attr(line0, "x2", "16");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "16");
        attr(line1, "x2", "12");
        attr(line1, "y2", "16");
        attr(line2, "x1", "12");
        attr(line2, "y1", "8");
        attr(line2, "x2", "12");
        attr(line2, "y2", "8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-divide-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-divide-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance89($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var DivideSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance89, create_fragment89, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-divide-square", DivideSquare);

  // components/Divide.svelte
  function create_fragment90(ctx) {
    let svg;
    let circle0;
    let line;
    let circle1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        line = svg_element("line");
        circle1 = svg_element("circle");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "6");
        attr(circle0, "r", "2");
        attr(line, "x1", "5");
        attr(line, "y1", "12");
        attr(line, "x2", "19");
        attr(line, "y2", "12");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "18");
        attr(circle1, "r", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-divide feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, line);
        append(svg, circle1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-divide feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance90($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Divide = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance90, create_fragment90, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-divide", Divide);

  // components/DollarSign.svelte
  function create_fragment91(ctx) {
    let svg;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(line, "x1", "12");
        attr(line, "y1", "1");
        attr(line, "x2", "12");
        attr(line, "y2", "23");
        attr(path, "d", "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-dollar-sign feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-dollar-sign feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance91($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var DollarSign = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance91, create_fragment91, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-dollar-sign", DollarSign);

  // components/DownloadCloud.svelte
  function create_fragment92(ctx) {
    let svg;
    let polyline;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "8 17 12 21 16 17");
        attr(line, "x1", "12");
        attr(line, "y1", "12");
        attr(line, "x2", "12");
        attr(line, "y2", "21");
        attr(path, "d", "M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-download-cloud feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-download-cloud feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance92($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var DownloadCloud = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance92, create_fragment92, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-download-cloud", DownloadCloud);

  // components/Download.svelte
  function create_fragment93(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
        attr(polyline, "points", "7 10 12 15 17 10");
        attr(line, "x1", "12");
        attr(line, "y1", "15");
        attr(line, "x2", "12");
        attr(line, "y2", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-download feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-download feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance93($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Download = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance93, create_fragment93, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-download", Download);

  // components/Dribbble.svelte
  function create_fragment94(ctx) {
    let svg;
    let circle;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(path, "d", "M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-dribbble feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-dribbble feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance94($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Dribbble = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance94, create_fragment94, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-dribbble", Dribbble);

  // components/Droplet.svelte
  function create_fragment95(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-droplet feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-droplet feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance95($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Droplet = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance95, create_fragment95, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-droplet", Droplet);

  // components/Edit2.svelte
  function create_fragment96(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-edit-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-edit-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance96($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Edit2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance96, create_fragment96, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-edit-2", Edit2);

  // components/Edit3.svelte
  function create_fragment97(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M12 20h9");
        attr(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-edit-3 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-edit-3 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance97($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Edit3 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance97, create_fragment97, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-edit-3", Edit3);

  // components/Edit.svelte
  function create_fragment98(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
        attr(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-edit feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-edit feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance98($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Edit = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance98, create_fragment98, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-edit", Edit);

  // components/ExternalLink.svelte
  function create_fragment99(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6");
        attr(polyline, "points", "15 3 21 3 21 9");
        attr(line, "x1", "10");
        attr(line, "y1", "14");
        attr(line, "x2", "21");
        attr(line, "y2", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-external-link feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-external-link feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance99($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ExternalLink = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance99, create_fragment99, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-external-link", ExternalLink);

  // components/EyeOff.svelte
  function create_fragment100(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-eye-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-eye-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance100($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var EyeOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance100, create_fragment100, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-eye-off", EyeOff);

  // components/Eye.svelte
  function create_fragment101(ctx) {
    let svg;
    let path;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-eye feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-eye feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance101($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Eye = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance101, create_fragment101, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-eye", Eye);

  // components/Facebook.svelte
  function create_fragment102(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-facebook feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-facebook feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance102($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Facebook = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance102, create_fragment102, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-facebook", Facebook);

  // components/FastForward.svelte
  function create_fragment103(ctx) {
    let svg;
    let polygon0;
    let polygon1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon0 = svg_element("polygon");
        polygon1 = svg_element("polygon");
        this.c = noop;
        attr(polygon0, "points", "13 19 22 12 13 5 13 19");
        attr(polygon1, "points", "2 19 11 12 2 5 2 19");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-fast-forward feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon0);
        append(svg, polygon1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-fast-forward feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance103($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FastForward = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance103, create_fragment103, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-fast-forward", FastForward);

  // components/Feather.svelte
  function create_fragment104(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z");
        attr(line0, "x1", "16");
        attr(line0, "y1", "8");
        attr(line0, "x2", "2");
        attr(line0, "y2", "22");
        attr(line1, "x1", "17.5");
        attr(line1, "y1", "15");
        attr(line1, "x2", "9");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-feather feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-feather feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance104($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Feather = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance104, create_fragment104, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-feather", Feather);

  // components/Figma.svelte
  function create_fragment105(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let path4;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        path4 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z");
        attr(path1, "d", "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z");
        attr(path2, "d", "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z");
        attr(path3, "d", "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z");
        attr(path4, "d", "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-figma feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        append(svg, path4);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-figma feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance105($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Figma = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance105, create_fragment105, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-figma", Figma);

  // components/FileMinus.svelte
  function create_fragment106(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
        attr(polyline, "points", "14 2 14 8 20 8");
        attr(line, "x1", "9");
        attr(line, "y1", "15");
        attr(line, "x2", "15");
        attr(line, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-file-minus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-file-minus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance106($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FileMinus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance106, create_fragment106, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-file-minus", FileMinus);

  // components/FilePlus.svelte
  function create_fragment107(ctx) {
    let svg;
    let path;
    let polyline;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
        attr(polyline, "points", "14 2 14 8 20 8");
        attr(line0, "x1", "12");
        attr(line0, "y1", "18");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line1, "x1", "9");
        attr(line1, "y1", "15");
        attr(line1, "x2", "15");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-file-plus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-file-plus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance107($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FilePlus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance107, create_fragment107, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-file-plus", FilePlus);

  // components/FileText.svelte
  function create_fragment108(ctx) {
    let svg;
    let path;
    let polyline0;
    let line0;
    let line1;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline0 = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
        attr(polyline0, "points", "14 2 14 8 20 8");
        attr(line0, "x1", "16");
        attr(line0, "y1", "13");
        attr(line0, "x2", "8");
        attr(line0, "y2", "13");
        attr(line1, "x1", "16");
        attr(line1, "y1", "17");
        attr(line1, "x2", "8");
        attr(line1, "y2", "17");
        attr(polyline1, "points", "10 9 9 9 8 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-file-text feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline0);
        append(svg, line0);
        append(svg, line1);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-file-text feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance108($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FileText = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance108, create_fragment108, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-file-text", FileText);

  // components/File.svelte
  function create_fragment109(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z");
        attr(polyline, "points", "13 2 13 9 20 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-file feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-file feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance109($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var File = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance109, create_fragment109, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-file", File);

  // components/Film.svelte
  function create_fragment110(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let line6;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        line6 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "2");
        attr(rect, "y", "2");
        attr(rect, "width", "20");
        attr(rect, "height", "20");
        attr(rect, "rx", "2.18");
        attr(rect, "ry", "2.18");
        attr(line0, "x1", "7");
        attr(line0, "y1", "2");
        attr(line0, "x2", "7");
        attr(line0, "y2", "22");
        attr(line1, "x1", "17");
        attr(line1, "y1", "2");
        attr(line1, "x2", "17");
        attr(line1, "y2", "22");
        attr(line2, "x1", "2");
        attr(line2, "y1", "12");
        attr(line2, "x2", "22");
        attr(line2, "y2", "12");
        attr(line3, "x1", "2");
        attr(line3, "y1", "7");
        attr(line3, "x2", "7");
        attr(line3, "y2", "7");
        attr(line4, "x1", "2");
        attr(line4, "y1", "17");
        attr(line4, "x2", "7");
        attr(line4, "y2", "17");
        attr(line5, "x1", "17");
        attr(line5, "y1", "17");
        attr(line5, "x2", "22");
        attr(line5, "y2", "17");
        attr(line6, "x1", "17");
        attr(line6, "y1", "7");
        attr(line6, "x2", "22");
        attr(line6, "y2", "7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-film feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, line6);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-film feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance110($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Film = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance110, create_fragment110, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-film", Film);

  // components/Filter.svelte
  function create_fragment111(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-filter feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-filter feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance111($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Filter = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance111, create_fragment111, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-filter", Filter);

  // components/Flag.svelte
  function create_fragment112(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z");
        attr(line, "x1", "4");
        attr(line, "y1", "22");
        attr(line, "x2", "4");
        attr(line, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-flag feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-flag feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance112($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Flag = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance112, create_fragment112, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-flag", Flag);

  // components/FolderMinus.svelte
  function create_fragment113(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
        attr(line, "x1", "9");
        attr(line, "y1", "14");
        attr(line, "x2", "15");
        attr(line, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-folder-minus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-folder-minus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance113($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FolderMinus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance113, create_fragment113, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-folder-minus", FolderMinus);

  // components/FolderPlus.svelte
  function create_fragment114(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
        attr(line0, "x1", "12");
        attr(line0, "y1", "11");
        attr(line0, "x2", "12");
        attr(line0, "y2", "17");
        attr(line1, "x1", "9");
        attr(line1, "y1", "14");
        attr(line1, "x2", "15");
        attr(line1, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-folder-plus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-folder-plus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance114($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var FolderPlus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance114, create_fragment114, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-folder-plus", FolderPlus);

  // components/Folder.svelte
  function create_fragment115(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-folder feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-folder feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance115($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Folder = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance115, create_fragment115, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-folder", Folder);

  // components/Framer.svelte
  function create_fragment116(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-framer feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-framer feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance116($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Framer = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance116, create_fragment116, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-framer", Framer);

  // components/Frown.svelte
  function create_fragment117(ctx) {
    let svg;
    let circle;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(path, "d", "M16 16s-1.5-2-4-2-4 2-4 2");
        attr(line0, "x1", "9");
        attr(line0, "y1", "9");
        attr(line0, "x2", "9.01");
        attr(line0, "y2", "9");
        attr(line1, "x1", "15");
        attr(line1, "y1", "9");
        attr(line1, "x2", "15.01");
        attr(line1, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-frown feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-frown feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance117($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Frown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance117, create_fragment117, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-frown", Frown);

  // components/Gift.svelte
  function create_fragment118(ctx) {
    let svg;
    let polyline;
    let rect;
    let line;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        rect = svg_element("rect");
        line = svg_element("line");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "20 12 20 22 4 22 4 12");
        attr(rect, "x", "2");
        attr(rect, "y", "7");
        attr(rect, "width", "20");
        attr(rect, "height", "5");
        attr(line, "x1", "12");
        attr(line, "y1", "22");
        attr(line, "x2", "12");
        attr(line, "y2", "7");
        attr(path0, "d", "M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z");
        attr(path1, "d", "M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-gift feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, rect);
        append(svg, line);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-gift feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance118($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Gift = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance118, create_fragment118, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-gift", Gift);

  // components/GitBranch.svelte
  function create_fragment119(ctx) {
    let svg;
    let line;
    let circle0;
    let circle1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(line, "x1", "6");
        attr(line, "y1", "3");
        attr(line, "x2", "6");
        attr(line, "y2", "15");
        attr(circle0, "cx", "18");
        attr(circle0, "cy", "6");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "6");
        attr(circle1, "cy", "18");
        attr(circle1, "r", "3");
        attr(path, "d", "M18 9a9 9 0 0 1-9 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-git-branch feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-git-branch feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance119($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var GitBranch = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance119, create_fragment119, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-git-branch", GitBranch);

  // components/GitCommit.svelte
  function create_fragment120(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "4");
        attr(line0, "x1", "1.05");
        attr(line0, "y1", "12");
        attr(line0, "x2", "7");
        attr(line0, "y2", "12");
        attr(line1, "x1", "17.01");
        attr(line1, "y1", "12");
        attr(line1, "x2", "22.96");
        attr(line1, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-git-commit feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-git-commit feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance120($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var GitCommit = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance120, create_fragment120, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-git-commit", GitCommit);

  // components/GitMerge.svelte
  function create_fragment121(ctx) {
    let svg;
    let circle0;
    let circle1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle0, "cx", "18");
        attr(circle0, "cy", "18");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "6");
        attr(circle1, "cy", "6");
        attr(circle1, "r", "3");
        attr(path, "d", "M6 21V9a9 9 0 0 0 9 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-git-merge feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-git-merge feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance121($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var GitMerge = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance121, create_fragment121, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-git-merge", GitMerge);

  // components/GitPullRequest.svelte
  function create_fragment122(ctx) {
    let svg;
    let circle0;
    let circle1;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "18");
        attr(circle0, "cy", "18");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "6");
        attr(circle1, "cy", "6");
        attr(circle1, "r", "3");
        attr(path, "d", "M13 6h3a2 2 0 0 1 2 2v7");
        attr(line, "x1", "6");
        attr(line, "y1", "9");
        attr(line, "x2", "6");
        attr(line, "y2", "21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-git-pull-request feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-git-pull-request feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance122($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var GitPullRequest = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance122, create_fragment122, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-git-pull-request", GitPullRequest);

  // components/Github.svelte
  function create_fragment123(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-github feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-github feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance123($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Github = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance123, create_fragment123, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-github", Github);

  // components/Gitlab.svelte
  function create_fragment124(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-gitlab feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-gitlab feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance124($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Gitlab = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance124, create_fragment124, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-gitlab", Gitlab);

  // components/Globe.svelte
  function create_fragment125(ctx) {
    let svg;
    let circle;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line, "x1", "2");
        attr(line, "y1", "12");
        attr(line, "x2", "22");
        attr(line, "y2", "12");
        attr(path, "d", "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-globe feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-globe feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance125($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Globe = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance125, create_fragment125, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-globe", Globe);

  // components/Grid.svelte
  function create_fragment126(ctx) {
    let svg;
    let rect0;
    let rect1;
    let rect2;
    let rect3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect0 = svg_element("rect");
        rect1 = svg_element("rect");
        rect2 = svg_element("rect");
        rect3 = svg_element("rect");
        this.c = noop;
        attr(rect0, "x", "3");
        attr(rect0, "y", "3");
        attr(rect0, "width", "7");
        attr(rect0, "height", "7");
        attr(rect1, "x", "14");
        attr(rect1, "y", "3");
        attr(rect1, "width", "7");
        attr(rect1, "height", "7");
        attr(rect2, "x", "14");
        attr(rect2, "y", "14");
        attr(rect2, "width", "7");
        attr(rect2, "height", "7");
        attr(rect3, "x", "3");
        attr(rect3, "y", "14");
        attr(rect3, "width", "7");
        attr(rect3, "height", "7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-grid feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect0);
        append(svg, rect1);
        append(svg, rect2);
        append(svg, rect3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-grid feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance126($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Grid = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance126, create_fragment126, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-grid", Grid);

  // components/HardDrive.svelte
  function create_fragment127(ctx) {
    let svg;
    let line0;
    let path;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        path = svg_element("path");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "22");
        attr(line0, "y1", "12");
        attr(line0, "x2", "2");
        attr(line0, "y2", "12");
        attr(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
        attr(line1, "x1", "6");
        attr(line1, "y1", "16");
        attr(line1, "x2", "6.01");
        attr(line1, "y2", "16");
        attr(line2, "x1", "10");
        attr(line2, "y1", "16");
        attr(line2, "x2", "10.01");
        attr(line2, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-hard-drive feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, path);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-hard-drive feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance127($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var HardDrive = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance127, create_fragment127, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-hard-drive", HardDrive);

  // components/Hash.svelte
  function create_fragment128(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "4");
        attr(line0, "y1", "9");
        attr(line0, "x2", "20");
        attr(line0, "y2", "9");
        attr(line1, "x1", "4");
        attr(line1, "y1", "15");
        attr(line1, "x2", "20");
        attr(line1, "y2", "15");
        attr(line2, "x1", "10");
        attr(line2, "y1", "3");
        attr(line2, "x2", "8");
        attr(line2, "y2", "21");
        attr(line3, "x1", "16");
        attr(line3, "y1", "3");
        attr(line3, "x2", "14");
        attr(line3, "y2", "21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-hash feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-hash feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance128($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Hash = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance128, create_fragment128, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-hash", Hash);

  // components/Headphones.svelte
  function create_fragment129(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M3 18v-6a9 9 0 0 1 18 0v6");
        attr(path1, "d", "M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-headphones feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-headphones feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance129($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Headphones = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance129, create_fragment129, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-headphones", Headphones);

  // components/Heart.svelte
  function create_fragment130(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-heart feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-heart feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance130($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Heart = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance130, create_fragment130, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-heart", Heart);

  // components/HelpCircle.svelte
  function create_fragment131(ctx) {
    let svg;
    let circle;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(path, "d", "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3");
        attr(line, "x1", "12");
        attr(line, "y1", "17");
        attr(line, "x2", "12.01");
        attr(line, "y2", "17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-help-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-help-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance131($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var HelpCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance131, create_fragment131, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-help-circle", HelpCircle);

  // components/Hexagon.svelte
  function create_fragment132(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-hexagon feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-hexagon feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance132($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Hexagon = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance132, create_fragment132, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-hexagon", Hexagon);

  // components/Home.svelte
  function create_fragment133(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
        attr(polyline, "points", "9 22 9 12 15 12 15 22");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-home feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-home feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance133($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Home = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance133, create_fragment133, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-home", Home);

  // components/Image.svelte
  function create_fragment134(ctx) {
    let svg;
    let rect;
    let circle;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(circle, "cx", "8.5");
        attr(circle, "cy", "8.5");
        attr(circle, "r", "1.5");
        attr(polyline, "points", "21 15 16 10 5 21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-image feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, circle);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-image feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance134($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Image = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance134, create_fragment134, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-image", Image);

  // components/Inbox.svelte
  function create_fragment135(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "22 12 16 12 14 15 10 15 8 12 2 12");
        attr(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-inbox feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-inbox feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance135($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Inbox = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance135, create_fragment135, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-inbox", Inbox);

  // components/Info.svelte
  function create_fragment136(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "12");
        attr(line0, "y1", "16");
        attr(line0, "x2", "12");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "8");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-info feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-info feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance136($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Info = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance136, create_fragment136, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-info", Info);

  // components/Instagram.svelte
  function create_fragment137(ctx) {
    let svg;
    let rect;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "2");
        attr(rect, "y", "2");
        attr(rect, "width", "20");
        attr(rect, "height", "20");
        attr(rect, "rx", "5");
        attr(rect, "ry", "5");
        attr(path, "d", "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z");
        attr(line, "x1", "17.5");
        attr(line, "y1", "6.5");
        attr(line, "x2", "17.51");
        attr(line, "y2", "6.5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-instagram feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-instagram feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance137($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Instagram = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance137, create_fragment137, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-instagram", Instagram);

  // components/Italic.svelte
  function create_fragment138(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "19");
        attr(line0, "y1", "4");
        attr(line0, "x2", "10");
        attr(line0, "y2", "4");
        attr(line1, "x1", "14");
        attr(line1, "y1", "20");
        attr(line1, "x2", "5");
        attr(line1, "y2", "20");
        attr(line2, "x1", "15");
        attr(line2, "y1", "4");
        attr(line2, "x2", "9");
        attr(line2, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-italic feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-italic feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance138($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Italic = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance138, create_fragment138, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-italic", Italic);

  // components/Key.svelte
  function create_fragment139(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-key feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-key feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance139($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Key = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance139, create_fragment139, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-key", Key);

  // components/Layers.svelte
  function create_fragment140(ctx) {
    let svg;
    let polygon;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polygon, "points", "12 2 2 7 12 12 22 7 12 2");
        attr(polyline0, "points", "2 17 12 22 22 17");
        attr(polyline1, "points", "2 12 12 17 22 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-layers feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-layers feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance140($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Layers = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance140, create_fragment140, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-layers", Layers);

  // components/Layout.svelte
  function create_fragment141(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "3");
        attr(line0, "y1", "9");
        attr(line0, "x2", "21");
        attr(line0, "y2", "9");
        attr(line1, "x1", "9");
        attr(line1, "y1", "21");
        attr(line1, "x2", "9");
        attr(line1, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-layout feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-layout feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance141($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Layout = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance141, create_fragment141, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-layout", Layout);

  // components/LifeBuoy.svelte
  function create_fragment142(ctx) {
    let svg;
    let circle0;
    let circle1;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "10");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "4");
        attr(line0, "x1", "4.93");
        attr(line0, "y1", "4.93");
        attr(line0, "x2", "9.17");
        attr(line0, "y2", "9.17");
        attr(line1, "x1", "14.83");
        attr(line1, "y1", "14.83");
        attr(line1, "x2", "19.07");
        attr(line1, "y2", "19.07");
        attr(line2, "x1", "14.83");
        attr(line2, "y1", "9.17");
        attr(line2, "x2", "19.07");
        attr(line2, "y2", "4.93");
        attr(line3, "x1", "14.83");
        attr(line3, "y1", "9.17");
        attr(line3, "x2", "18.36");
        attr(line3, "y2", "5.64");
        attr(line4, "x1", "4.93");
        attr(line4, "y1", "19.07");
        attr(line4, "x2", "9.17");
        attr(line4, "y2", "14.83");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-life-buoy feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-life-buoy feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance142($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var LifeBuoy = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance142, create_fragment142, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-life-buoy", LifeBuoy);

  // components/Link2.svelte
  function create_fragment143(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3");
        attr(line, "x1", "8");
        attr(line, "y1", "12");
        attr(line, "x2", "16");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-link-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-link-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance143($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Link2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance143, create_fragment143, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-link-2", Link2);

  // components/Link.svelte
  function create_fragment144(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71");
        attr(path1, "d", "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-link feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-link feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance144($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Link = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance144, create_fragment144, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-link", Link);

  // components/Linkedin.svelte
  function create_fragment145(ctx) {
    let svg;
    let path;
    let rect;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        rect = svg_element("rect");
        circle = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z");
        attr(rect, "x", "2");
        attr(rect, "y", "9");
        attr(rect, "width", "4");
        attr(rect, "height", "12");
        attr(circle, "cx", "4");
        attr(circle, "cy", "4");
        attr(circle, "r", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-linkedin feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, rect);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-linkedin feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance145($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Linkedin = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance145, create_fragment145, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-linkedin", Linkedin);

  // components/List.svelte
  function create_fragment146(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "8");
        attr(line0, "y1", "6");
        attr(line0, "x2", "21");
        attr(line0, "y2", "6");
        attr(line1, "x1", "8");
        attr(line1, "y1", "12");
        attr(line1, "x2", "21");
        attr(line1, "y2", "12");
        attr(line2, "x1", "8");
        attr(line2, "y1", "18");
        attr(line2, "x2", "21");
        attr(line2, "y2", "18");
        attr(line3, "x1", "3");
        attr(line3, "y1", "6");
        attr(line3, "x2", "3.01");
        attr(line3, "y2", "6");
        attr(line4, "x1", "3");
        attr(line4, "y1", "12");
        attr(line4, "x2", "3.01");
        attr(line4, "y2", "12");
        attr(line5, "x1", "3");
        attr(line5, "y1", "18");
        attr(line5, "x2", "3.01");
        attr(line5, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-list feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-list feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance146($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var List = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance146, create_fragment146, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-list", List);

  // components/Loader.svelte
  function create_fragment147(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let line6;
    let line7;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        line6 = svg_element("line");
        line7 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "12");
        attr(line0, "y1", "2");
        attr(line0, "x2", "12");
        attr(line0, "y2", "6");
        attr(line1, "x1", "12");
        attr(line1, "y1", "18");
        attr(line1, "x2", "12");
        attr(line1, "y2", "22");
        attr(line2, "x1", "4.93");
        attr(line2, "y1", "4.93");
        attr(line2, "x2", "7.76");
        attr(line2, "y2", "7.76");
        attr(line3, "x1", "16.24");
        attr(line3, "y1", "16.24");
        attr(line3, "x2", "19.07");
        attr(line3, "y2", "19.07");
        attr(line4, "x1", "2");
        attr(line4, "y1", "12");
        attr(line4, "x2", "6");
        attr(line4, "y2", "12");
        attr(line5, "x1", "18");
        attr(line5, "y1", "12");
        attr(line5, "x2", "22");
        attr(line5, "y2", "12");
        attr(line6, "x1", "4.93");
        attr(line6, "y1", "19.07");
        attr(line6, "x2", "7.76");
        attr(line6, "y2", "16.24");
        attr(line7, "x1", "16.24");
        attr(line7, "y1", "7.76");
        attr(line7, "x2", "19.07");
        attr(line7, "y2", "4.93");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-loader feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, line6);
        append(svg, line7);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-loader feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance147($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Loader = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance147, create_fragment147, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-loader", Loader);

  // components/Lock.svelte
  function create_fragment148(ctx) {
    let svg;
    let rect;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        path = svg_element("path");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "11");
        attr(rect, "width", "18");
        attr(rect, "height", "11");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(path, "d", "M7 11V7a5 5 0 0 1 10 0v4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-lock feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-lock feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance148($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Lock = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance148, create_fragment148, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-lock", Lock);

  // components/LogIn.svelte
  function create_fragment149(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
        attr(polyline, "points", "10 17 15 12 10 7");
        attr(line, "x1", "15");
        attr(line, "y1", "12");
        attr(line, "x2", "3");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-log-in feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-log-in feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance149($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var LogIn = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance149, create_fragment149, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-log-in", LogIn);

  // components/LogOut.svelte
  function create_fragment150(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4");
        attr(polyline, "points", "16 17 21 12 16 7");
        attr(line, "x1", "21");
        attr(line, "y1", "12");
        attr(line, "x2", "9");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-log-out feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-log-out feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance150($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var LogOut = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance150, create_fragment150, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-log-out", LogOut);

  // components/Mail.svelte
  function create_fragment151(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z");
        attr(polyline, "points", "22,6 12,13 2,6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-mail feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-mail feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance151($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Mail = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance151, create_fragment151, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-mail", Mail);

  // components/MapPin.svelte
  function create_fragment152(ctx) {
    let svg;
    let path;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z");
        attr(circle, "cx", "12");
        attr(circle, "cy", "10");
        attr(circle, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-map-pin feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-map-pin feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance152($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MapPin = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance152, create_fragment152, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-map-pin", MapPin);

  // components/Map.svelte
  function create_fragment153(ctx) {
    let svg;
    let polygon;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6");
        attr(line0, "x1", "8");
        attr(line0, "y1", "2");
        attr(line0, "x2", "8");
        attr(line0, "y2", "18");
        attr(line1, "x1", "16");
        attr(line1, "y1", "6");
        attr(line1, "x2", "16");
        attr(line1, "y2", "22");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-map feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-map feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance153($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Map2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance153, create_fragment153, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-map", Map2);

  // components/Maximize2.svelte
  function create_fragment154(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polyline0, "points", "15 3 21 3 21 9");
        attr(polyline1, "points", "9 21 3 21 3 15");
        attr(line0, "x1", "21");
        attr(line0, "y1", "3");
        attr(line0, "x2", "14");
        attr(line0, "y2", "10");
        attr(line1, "x1", "3");
        attr(line1, "y1", "21");
        attr(line1, "x2", "10");
        attr(line1, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-maximize-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-maximize-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance154($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Maximize2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance154, create_fragment154, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-maximize-2", Maximize2);

  // components/Maximize.svelte
  function create_fragment155(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-maximize feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-maximize feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance155($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Maximize = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance155, create_fragment155, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-maximize", Maximize);

  // components/Meh.svelte
  function create_fragment156(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "8");
        attr(line0, "y1", "15");
        attr(line0, "x2", "16");
        attr(line0, "y2", "15");
        attr(line1, "x1", "9");
        attr(line1, "y1", "9");
        attr(line1, "x2", "9.01");
        attr(line1, "y2", "9");
        attr(line2, "x1", "15");
        attr(line2, "y1", "9");
        attr(line2, "x2", "15.01");
        attr(line2, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-meh feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-meh feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance156($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Meh = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance156, create_fragment156, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-meh", Meh);

  // components/Menu.svelte
  function create_fragment157(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "3");
        attr(line0, "y1", "12");
        attr(line0, "x2", "21");
        attr(line0, "y2", "12");
        attr(line1, "x1", "3");
        attr(line1, "y1", "6");
        attr(line1, "x2", "21");
        attr(line1, "y2", "6");
        attr(line2, "x1", "3");
        attr(line2, "y1", "18");
        attr(line2, "x2", "21");
        attr(line2, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-menu feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-menu feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance157($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Menu = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance157, create_fragment157, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-menu", Menu);

  // components/MessageCircle.svelte
  function create_fragment158(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-message-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-message-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance158($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MessageCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance158, create_fragment158, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-message-circle", MessageCircle);

  // components/MessageSquare.svelte
  function create_fragment159(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-message-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-message-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance159($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MessageSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance159, create_fragment159, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-message-square", MessageSquare);

  // components/MicOff.svelte
  function create_fragment160(ctx) {
    let svg;
    let line0;
    let path0;
    let path1;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        path0 = svg_element("path");
        path1 = svg_element("path");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "1");
        attr(line0, "y1", "1");
        attr(line0, "x2", "23");
        attr(line0, "y2", "23");
        attr(path0, "d", "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6");
        attr(path1, "d", "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23");
        attr(line1, "x1", "12");
        attr(line1, "y1", "19");
        attr(line1, "x2", "12");
        attr(line1, "y2", "23");
        attr(line2, "x1", "8");
        attr(line2, "y1", "23");
        attr(line2, "x2", "16");
        attr(line2, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-mic-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, path0);
        append(svg, path1);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-mic-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance160($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MicOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance160, create_fragment160, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-mic-off", MicOff);

  // components/Mic.svelte
  function create_fragment161(ctx) {
    let svg;
    let path0;
    let path1;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path0, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z");
        attr(path1, "d", "M19 10v2a7 7 0 0 1-14 0v-2");
        attr(line0, "x1", "12");
        attr(line0, "y1", "19");
        attr(line0, "x2", "12");
        attr(line0, "y2", "23");
        attr(line1, "x1", "8");
        attr(line1, "y1", "23");
        attr(line1, "x2", "16");
        attr(line1, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-mic feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-mic feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance161($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Mic = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance161, create_fragment161, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-mic", Mic);

  // components/Minimize2.svelte
  function create_fragment162(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polyline0, "points", "4 14 10 14 10 20");
        attr(polyline1, "points", "20 10 14 10 14 4");
        attr(line0, "x1", "14");
        attr(line0, "y1", "10");
        attr(line0, "x2", "21");
        attr(line0, "y2", "3");
        attr(line1, "x1", "3");
        attr(line1, "y1", "21");
        attr(line1, "x2", "10");
        attr(line1, "y2", "14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-minimize-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-minimize-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance162($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Minimize2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance162, create_fragment162, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-minimize-2", Minimize2);

  // components/Minimize.svelte
  function create_fragment163(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-minimize feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-minimize feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance163($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Minimize = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance163, create_fragment163, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-minimize", Minimize);

  // components/MinusCircle.svelte
  function create_fragment164(ctx) {
    let svg;
    let circle;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line, "x1", "8");
        attr(line, "y1", "12");
        attr(line, "x2", "16");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-minus-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-minus-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance164($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MinusCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance164, create_fragment164, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-minus-circle", MinusCircle);

  // components/MinusSquare.svelte
  function create_fragment165(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "8");
        attr(line, "y1", "12");
        attr(line, "x2", "16");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-minus-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-minus-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance165($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MinusSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance165, create_fragment165, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-minus-square", MinusSquare);

  // components/Minus.svelte
  function create_fragment166(ctx) {
    let svg;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        this.c = noop;
        attr(line, "x1", "5");
        attr(line, "y1", "12");
        attr(line, "x2", "19");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-minus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-minus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance166($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Minus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance166, create_fragment166, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-minus", Minus);

  // components/Monitor.svelte
  function create_fragment167(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "2");
        attr(rect, "y", "3");
        attr(rect, "width", "20");
        attr(rect, "height", "14");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "8");
        attr(line0, "y1", "21");
        attr(line0, "x2", "16");
        attr(line0, "y2", "21");
        attr(line1, "x1", "12");
        attr(line1, "y1", "17");
        attr(line1, "x2", "12");
        attr(line1, "y2", "21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-monitor feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-monitor feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance167($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Monitor = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance167, create_fragment167, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-monitor", Monitor);

  // components/Moon.svelte
  function create_fragment168(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-moon feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-moon feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance168($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Moon = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance168, create_fragment168, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-moon", Moon);

  // components/MoreHorizontal.svelte
  function create_fragment169(ctx) {
    let svg;
    let circle0;
    let circle1;
    let circle2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        circle2 = svg_element("circle");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "1");
        attr(circle1, "cx", "19");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "1");
        attr(circle2, "cx", "5");
        attr(circle2, "cy", "12");
        attr(circle2, "r", "1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-more-horizontal feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, circle2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-more-horizontal feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance169($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MoreHorizontal = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance169, create_fragment169, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-more-horizontal", MoreHorizontal);

  // components/MoreVertical.svelte
  function create_fragment170(ctx) {
    let svg;
    let circle0;
    let circle1;
    let circle2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        circle2 = svg_element("circle");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "1");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "5");
        attr(circle1, "r", "1");
        attr(circle2, "cx", "12");
        attr(circle2, "cy", "19");
        attr(circle2, "r", "1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-more-vertical feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, circle2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-more-vertical feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance170($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MoreVertical = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance170, create_fragment170, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-more-vertical", MoreVertical);

  // components/MousePointer.svelte
  function create_fragment171(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z");
        attr(path1, "d", "M13 13l6 6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-mouse-pointer feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-mouse-pointer feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance171($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var MousePointer = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance171, create_fragment171, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-mouse-pointer", MousePointer);

  // components/Move.svelte
  function create_fragment172(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let polyline2;
    let polyline3;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        polyline2 = svg_element("polyline");
        polyline3 = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polyline0, "points", "5 9 2 12 5 15");
        attr(polyline1, "points", "9 5 12 2 15 5");
        attr(polyline2, "points", "15 19 12 22 9 19");
        attr(polyline3, "points", "19 9 22 12 19 15");
        attr(line0, "x1", "2");
        attr(line0, "y1", "12");
        attr(line0, "x2", "22");
        attr(line0, "y2", "12");
        attr(line1, "x1", "12");
        attr(line1, "y1", "2");
        attr(line1, "x2", "12");
        attr(line1, "y2", "22");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-move feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, polyline2);
        append(svg, polyline3);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-move feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance172($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Move = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance172, create_fragment172, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-move", Move);

  // components/Music.svelte
  function create_fragment173(ctx) {
    let svg;
    let path;
    let circle0;
    let circle1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M9 18V5l12-2v13");
        attr(circle0, "cx", "6");
        attr(circle0, "cy", "18");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "18");
        attr(circle1, "cy", "16");
        attr(circle1, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-music feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle0);
        append(svg, circle1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-music feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance173($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Music = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance173, create_fragment173, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-music", Music);

  // components/Navigation2.svelte
  function create_fragment174(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "12 2 19 21 12 17 5 21 12 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-navigation-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-navigation-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance174($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Navigation2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance174, create_fragment174, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-navigation-2", Navigation2);

  // components/Navigation.svelte
  function create_fragment175(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "3 11 22 2 13 21 11 13 3 11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-navigation feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-navigation feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance175($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Navigation = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance175, create_fragment175, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-navigation", Navigation);

  // components/Octagon.svelte
  function create_fragment176(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-octagon feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-octagon feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance176($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Octagon = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance176, create_fragment176, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-octagon", Octagon);

  // components/Package.svelte
  function create_fragment177(ctx) {
    let svg;
    let line0;
    let path;
    let polyline;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line1 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "16.5");
        attr(line0, "y1", "9.4");
        attr(line0, "x2", "7.5");
        attr(line0, "y2", "4.21");
        attr(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
        attr(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
        attr(line1, "x1", "12");
        attr(line1, "y1", "22.08");
        attr(line1, "x2", "12");
        attr(line1, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-package feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, path);
        append(svg, polyline);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-package feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance177($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Package = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance177, create_fragment177, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-package", Package);

  // components/Paperclip.svelte
  function create_fragment178(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-paperclip feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-paperclip feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance178($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Paperclip = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance178, create_fragment178, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-paperclip", Paperclip);

  // components/PauseCircle.svelte
  function create_fragment179(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "10");
        attr(line0, "y1", "15");
        attr(line0, "x2", "10");
        attr(line0, "y2", "9");
        attr(line1, "x1", "14");
        attr(line1, "y1", "15");
        attr(line1, "x2", "14");
        attr(line1, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-pause-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-pause-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance179($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PauseCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance179, create_fragment179, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-pause-circle", PauseCircle);

  // components/Pause.svelte
  function create_fragment180(ctx) {
    let svg;
    let rect0;
    let rect1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect0 = svg_element("rect");
        rect1 = svg_element("rect");
        this.c = noop;
        attr(rect0, "x", "6");
        attr(rect0, "y", "4");
        attr(rect0, "width", "4");
        attr(rect0, "height", "16");
        attr(rect1, "x", "14");
        attr(rect1, "y", "4");
        attr(rect1, "width", "4");
        attr(rect1, "height", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-pause feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect0);
        append(svg, rect1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-pause feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance180($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Pause = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance180, create_fragment180, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-pause", Pause);

  // components/PenTool.svelte
  function create_fragment181(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path0, "d", "M12 19l7-7 3 3-7 7-3-3z");
        attr(path1, "d", "M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z");
        attr(path2, "d", "M2 2l7.586 7.586");
        attr(circle, "cx", "11");
        attr(circle, "cy", "11");
        attr(circle, "r", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-pen-tool feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-pen-tool feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance181($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PenTool = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance181, create_fragment181, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-pen-tool", PenTool);

  // components/Percent.svelte
  function create_fragment182(ctx) {
    let svg;
    let line;
    let circle0;
    let circle1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        this.c = noop;
        attr(line, "x1", "19");
        attr(line, "y1", "5");
        attr(line, "x2", "5");
        attr(line, "y2", "19");
        attr(circle0, "cx", "6.5");
        attr(circle0, "cy", "6.5");
        attr(circle0, "r", "2.5");
        attr(circle1, "cx", "17.5");
        attr(circle1, "cy", "17.5");
        attr(circle1, "r", "2.5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-percent feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, circle0);
        append(svg, circle1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-percent feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance182($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Percent = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance182, create_fragment182, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-percent", Percent);

  // components/PhoneCall.svelte
  function create_fragment183(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-call feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-call feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance183($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneCall = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance183, create_fragment183, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-call", PhoneCall);

  // components/PhoneForwarded.svelte
  function create_fragment184(ctx) {
    let svg;
    let polyline;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "19 1 23 5 19 9");
        attr(line, "x1", "15");
        attr(line, "y1", "5");
        attr(line, "x2", "23");
        attr(line, "y2", "5");
        attr(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-forwarded feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-forwarded feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance184($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneForwarded = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance184, create_fragment184, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-forwarded", PhoneForwarded);

  // components/PhoneIncoming.svelte
  function create_fragment185(ctx) {
    let svg;
    let polyline;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "16 2 16 8 22 8");
        attr(line, "x1", "23");
        attr(line, "y1", "1");
        attr(line, "x2", "16");
        attr(line, "y2", "8");
        attr(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-incoming feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-incoming feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance185($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneIncoming = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance185, create_fragment185, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-incoming", PhoneIncoming);

  // components/PhoneMissed.svelte
  function create_fragment186(ctx) {
    let svg;
    let line0;
    let line1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(line0, "x1", "23");
        attr(line0, "y1", "1");
        attr(line0, "x2", "17");
        attr(line0, "y2", "7");
        attr(line1, "x1", "17");
        attr(line1, "y1", "1");
        attr(line1, "x2", "23");
        attr(line1, "y2", "7");
        attr(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-missed feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-missed feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance186($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneMissed = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance186, create_fragment186, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-missed", PhoneMissed);

  // components/PhoneOff.svelte
  function create_fragment187(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91");
        attr(line, "x1", "23");
        attr(line, "y1", "1");
        attr(line, "x2", "1");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance187($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance187, create_fragment187, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-off", PhoneOff);

  // components/PhoneOutgoing.svelte
  function create_fragment188(ctx) {
    let svg;
    let polyline;
    let line;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line = svg_element("line");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "23 7 23 1 17 1");
        attr(line, "x1", "16");
        attr(line, "y1", "8");
        attr(line, "x2", "23");
        attr(line, "y2", "1");
        attr(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone-outgoing feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone-outgoing feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance188($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PhoneOutgoing = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance188, create_fragment188, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone-outgoing", PhoneOutgoing);

  // components/Phone.svelte
  function create_fragment189(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-phone feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-phone feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance189($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Phone = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance189, create_fragment189, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-phone", Phone);

  // components/PieChart.svelte
  function create_fragment190(ctx) {
    let svg;
    let path0;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M21.21 15.89A10 10 0 1 1 8 2.83");
        attr(path1, "d", "M22 12A10 10 0 0 0 12 2v10z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-pie-chart feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-pie-chart feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance190($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PieChart = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance190, create_fragment190, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-pie-chart", PieChart);

  // components/PlayCircle.svelte
  function create_fragment191(ctx) {
    let svg;
    let circle;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(polygon, "points", "10 8 16 12 10 16 10 8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-play-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-play-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance191($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PlayCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance191, create_fragment191, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-play-circle", PlayCircle);

  // components/Play.svelte
  function create_fragment192(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "5 3 19 12 5 21 5 3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-play feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-play feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance192($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Play = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance192, create_fragment192, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-play", Play);

  // components/PlusCircle.svelte
  function create_fragment193(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "12");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "16");
        attr(line1, "x1", "8");
        attr(line1, "y1", "12");
        attr(line1, "x2", "16");
        attr(line1, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-plus-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-plus-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance193($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PlusCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance193, create_fragment193, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-plus-circle", PlusCircle);

  // components/PlusSquare.svelte
  function create_fragment194(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "12");
        attr(line0, "y1", "8");
        attr(line0, "x2", "12");
        attr(line0, "y2", "16");
        attr(line1, "x1", "8");
        attr(line1, "y1", "12");
        attr(line1, "x2", "16");
        attr(line1, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-plus-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-plus-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance194($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var PlusSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance194, create_fragment194, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-plus-square", PlusSquare);

  // components/Plus.svelte
  function create_fragment195(ctx) {
    let svg;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "12");
        attr(line0, "y1", "5");
        attr(line0, "x2", "12");
        attr(line0, "y2", "19");
        attr(line1, "x1", "5");
        attr(line1, "y1", "12");
        attr(line1, "x2", "19");
        attr(line1, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-plus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-plus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance195($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Plus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance195, create_fragment195, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-plus", Plus);

  // components/Pocket.svelte
  function create_fragment196(ctx) {
    let svg;
    let path;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z");
        attr(polyline, "points", "8 10 12 14 16 10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-pocket feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-pocket feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance196($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Pocket = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance196, create_fragment196, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-pocket", Pocket);

  // components/Power.svelte
  function create_fragment197(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
        attr(line, "x1", "12");
        attr(line, "y1", "2");
        attr(line, "x2", "12");
        attr(line, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-power feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-power feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance197($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Power = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance197, create_fragment197, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-power", Power);

  // components/Printer.svelte
  function create_fragment198(ctx) {
    let svg;
    let polyline;
    let path;
    let rect;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        rect = svg_element("rect");
        this.c = noop;
        attr(polyline, "points", "6 9 6 2 18 2 18 9");
        attr(path, "d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2");
        attr(rect, "x", "6");
        attr(rect, "y", "14");
        attr(rect, "width", "12");
        attr(rect, "height", "8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-printer feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
        append(svg, rect);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-printer feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance198($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Printer = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance198, create_fragment198, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-printer", Printer);

  // components/Radio.svelte
  function create_fragment199(ctx) {
    let svg;
    let circle;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "2");
        attr(path, "d", "M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-radio feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-radio feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance199($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Radio = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance199, create_fragment199, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-radio", Radio);

  // components/RefreshCcw.svelte
  function create_fragment200(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline0, "points", "1 4 1 10 7 10");
        attr(polyline1, "points", "23 20 23 14 17 14");
        attr(path, "d", "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-refresh-ccw feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-refresh-ccw feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance200($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var RefreshCcw = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance200, create_fragment200, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-refresh-ccw", RefreshCcw);

  // components/RefreshCw.svelte
  function create_fragment201(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline0, "points", "23 4 23 10 17 10");
        attr(polyline1, "points", "1 20 1 14 7 14");
        attr(path, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-refresh-cw feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-refresh-cw feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance201($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var RefreshCw = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance201, create_fragment201, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-refresh-cw", RefreshCw);

  // components/Repeat.svelte
  function create_fragment202(ctx) {
    let svg;
    let polyline0;
    let path0;
    let polyline1;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        path0 = svg_element("path");
        polyline1 = svg_element("polyline");
        path1 = svg_element("path");
        this.c = noop;
        attr(polyline0, "points", "17 1 21 5 17 9");
        attr(path0, "d", "M3 11V9a4 4 0 0 1 4-4h14");
        attr(polyline1, "points", "7 23 3 19 7 15");
        attr(path1, "d", "M21 13v2a4 4 0 0 1-4 4H3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-repeat feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, path0);
        append(svg, polyline1);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-repeat feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance202($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Repeat = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance202, create_fragment202, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-repeat", Repeat);

  // components/Rewind.svelte
  function create_fragment203(ctx) {
    let svg;
    let polygon0;
    let polygon1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon0 = svg_element("polygon");
        polygon1 = svg_element("polygon");
        this.c = noop;
        attr(polygon0, "points", "11 19 2 12 11 5 11 19");
        attr(polygon1, "points", "22 19 13 12 22 5 22 19");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-rewind feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon0);
        append(svg, polygon1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-rewind feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance203($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Rewind = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance203, create_fragment203, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-rewind", Rewind);

  // components/RotateCcw.svelte
  function create_fragment204(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "1 4 1 10 7 10");
        attr(path, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-rotate-ccw feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-rotate-ccw feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance204($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var RotateCcw = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance204, create_fragment204, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-rotate-ccw", RotateCcw);

  // components/RotateCw.svelte
  function create_fragment205(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "23 4 23 10 17 10");
        attr(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-rotate-cw feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-rotate-cw feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance205($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var RotateCw = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance205, create_fragment205, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-rotate-cw", RotateCw);

  // components/Rss.svelte
  function create_fragment206(ctx) {
    let svg;
    let path0;
    let path1;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path0, "d", "M4 11a9 9 0 0 1 9 9");
        attr(path1, "d", "M4 4a16 16 0 0 1 16 16");
        attr(circle, "cx", "5");
        attr(circle, "cy", "19");
        attr(circle, "r", "1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-rss feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-rss feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance206($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Rss = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance206, create_fragment206, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-rss", Rss);

  // components/Save.svelte
  function create_fragment207(ctx) {
    let svg;
    let path;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
        attr(polyline0, "points", "17 21 17 13 7 13 7 21");
        attr(polyline1, "points", "7 3 7 8 15 8");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-save feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-save feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance207($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Save = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance207, create_fragment207, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-save", Save);

  // components/Scissors.svelte
  function create_fragment208(ctx) {
    let svg;
    let circle0;
    let circle1;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "6");
        attr(circle0, "cy", "6");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "6");
        attr(circle1, "cy", "18");
        attr(circle1, "r", "3");
        attr(line0, "x1", "20");
        attr(line0, "y1", "4");
        attr(line0, "x2", "8.12");
        attr(line0, "y2", "15.88");
        attr(line1, "x1", "14.47");
        attr(line1, "y1", "14.48");
        attr(line1, "x2", "20");
        attr(line1, "y2", "20");
        attr(line2, "x1", "8.12");
        attr(line2, "y1", "8.12");
        attr(line2, "x2", "12");
        attr(line2, "y2", "12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-scissors feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-scissors feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance208($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Scissors = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance208, create_fragment208, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-scissors", Scissors);

  // components/Search.svelte
  function create_fragment209(ctx) {
    let svg;
    let circle;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "11");
        attr(circle, "cy", "11");
        attr(circle, "r", "8");
        attr(line, "x1", "21");
        attr(line, "y1", "21");
        attr(line, "x2", "16.65");
        attr(line, "y2", "16.65");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-search feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-search feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance209($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Search = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance209, create_fragment209, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-search", Search);

  // components/Send.svelte
  function create_fragment210(ctx) {
    let svg;
    let line;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line = svg_element("line");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(line, "x1", "22");
        attr(line, "y1", "2");
        attr(line, "x2", "11");
        attr(line, "y2", "13");
        attr(polygon, "points", "22 2 15 22 11 13 2 9 22 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-send feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-send feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance210($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Send = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance210, create_fragment210, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-send", Send);

  // components/Server.svelte
  function create_fragment211(ctx) {
    let svg;
    let rect0;
    let rect1;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect0 = svg_element("rect");
        rect1 = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(rect0, "x", "2");
        attr(rect0, "y", "2");
        attr(rect0, "width", "20");
        attr(rect0, "height", "8");
        attr(rect0, "rx", "2");
        attr(rect0, "ry", "2");
        attr(rect1, "x", "2");
        attr(rect1, "y", "14");
        attr(rect1, "width", "20");
        attr(rect1, "height", "8");
        attr(rect1, "rx", "2");
        attr(rect1, "ry", "2");
        attr(line0, "x1", "6");
        attr(line0, "y1", "6");
        attr(line0, "x2", "6.01");
        attr(line0, "y2", "6");
        attr(line1, "x1", "6");
        attr(line1, "y1", "18");
        attr(line1, "x2", "6.01");
        attr(line1, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-server feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect0);
        append(svg, rect1);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-server feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance211($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Server = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance211, create_fragment211, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-server", Server);

  // components/Settings.svelte
  function create_fragment212(ctx) {
    let svg;
    let circle;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "3");
        attr(path, "d", "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-settings feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-settings feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance212($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Settings = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance212, create_fragment212, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-settings", Settings);

  // components/Share2.svelte
  function create_fragment213(ctx) {
    let svg;
    let circle0;
    let circle1;
    let circle2;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        circle2 = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "18");
        attr(circle0, "cy", "5");
        attr(circle0, "r", "3");
        attr(circle1, "cx", "6");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "3");
        attr(circle2, "cx", "18");
        attr(circle2, "cy", "19");
        attr(circle2, "r", "3");
        attr(line0, "x1", "8.59");
        attr(line0, "y1", "13.51");
        attr(line0, "x2", "15.42");
        attr(line0, "y2", "17.49");
        attr(line1, "x1", "15.41");
        attr(line1, "y1", "6.51");
        attr(line1, "x2", "8.59");
        attr(line1, "y2", "10.49");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-share-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, circle2);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-share-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance213($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Share2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance213, create_fragment213, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-share-2", Share2);

  // components/Share.svelte
  function create_fragment214(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8");
        attr(polyline, "points", "16 6 12 2 8 6");
        attr(line, "x1", "12");
        attr(line, "y1", "2");
        attr(line, "x2", "12");
        attr(line, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-share feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-share feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance214($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Share = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance214, create_fragment214, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-share", Share);

  // components/ShieldOff.svelte
  function create_fragment215(ctx) {
    let svg;
    let path0;
    let path1;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path0, "d", "M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18");
        attr(path1, "d", "M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-shield-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-shield-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance215($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ShieldOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance215, create_fragment215, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-shield-off", ShieldOff);

  // components/Shield.svelte
  function create_fragment216(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-shield feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-shield feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance216($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Shield = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance216, create_fragment216, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-shield", Shield);

  // components/ShoppingBag.svelte
  function create_fragment217(ctx) {
    let svg;
    let path0;
    let line;
    let path1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        line = svg_element("line");
        path1 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z");
        attr(line, "x1", "3");
        attr(line, "y1", "6");
        attr(line, "x2", "21");
        attr(line, "y2", "6");
        attr(path1, "d", "M16 10a4 4 0 0 1-8 0");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-shopping-bag feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, line);
        append(svg, path1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-shopping-bag feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance217($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ShoppingBag = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance217, create_fragment217, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-shopping-bag", ShoppingBag);

  // components/ShoppingCart.svelte
  function create_fragment218(ctx) {
    let svg;
    let circle0;
    let circle1;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        path = svg_element("path");
        this.c = noop;
        attr(circle0, "cx", "9");
        attr(circle0, "cy", "21");
        attr(circle0, "r", "1");
        attr(circle1, "cx", "20");
        attr(circle1, "cy", "21");
        attr(circle1, "r", "1");
        attr(path, "d", "M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-shopping-cart feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-shopping-cart feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance218($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ShoppingCart = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance218, create_fragment218, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-shopping-cart", ShoppingCart);

  // components/Shuffle.svelte
  function create_fragment219(ctx) {
    let svg;
    let polyline0;
    let line0;
    let polyline1;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        line0 = svg_element("line");
        polyline1 = svg_element("polyline");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(polyline0, "points", "16 3 21 3 21 8");
        attr(line0, "x1", "4");
        attr(line0, "y1", "20");
        attr(line0, "x2", "21");
        attr(line0, "y2", "3");
        attr(polyline1, "points", "21 16 21 21 16 21");
        attr(line1, "x1", "15");
        attr(line1, "y1", "15");
        attr(line1, "x2", "21");
        attr(line1, "y2", "21");
        attr(line2, "x1", "4");
        attr(line2, "y1", "4");
        attr(line2, "x2", "9");
        attr(line2, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-shuffle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, line0);
        append(svg, polyline1);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-shuffle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance219($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Shuffle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance219, create_fragment219, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-shuffle", Shuffle);

  // components/Sidebar.svelte
  function create_fragment220(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "9");
        attr(line, "y1", "3");
        attr(line, "x2", "9");
        attr(line, "y2", "21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-sidebar feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-sidebar feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance220($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Sidebar = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance220, create_fragment220, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-sidebar", Sidebar);

  // components/SkipBack.svelte
  function create_fragment221(ctx) {
    let svg;
    let polygon;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "19 20 9 12 19 4 19 20");
        attr(line, "x1", "5");
        attr(line, "y1", "19");
        attr(line, "x2", "5");
        attr(line, "y2", "5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-skip-back feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-skip-back feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance221($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var SkipBack = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance221, create_fragment221, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-skip-back", SkipBack);

  // components/SkipForward.svelte
  function create_fragment222(ctx) {
    let svg;
    let polygon;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "5 4 15 12 5 20 5 4");
        attr(line, "x1", "19");
        attr(line, "y1", "5");
        attr(line, "x2", "19");
        attr(line, "y2", "19");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-skip-forward feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-skip-forward feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance222($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var SkipForward = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance222, create_fragment222, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-skip-forward", SkipForward);

  // components/Slack.svelte
  function create_fragment223(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let path3;
    let path4;
    let path5;
    let path6;
    let path7;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        path4 = svg_element("path");
        path5 = svg_element("path");
        path6 = svg_element("path");
        path7 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z");
        attr(path1, "d", "M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
        attr(path2, "d", "M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z");
        attr(path3, "d", "M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z");
        attr(path4, "d", "M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z");
        attr(path5, "d", "M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
        attr(path6, "d", "M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z");
        attr(path7, "d", "M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-slack feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        append(svg, path4);
        append(svg, path5);
        append(svg, path6);
        append(svg, path7);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-slack feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance223($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Slack = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance223, create_fragment223, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-slack", Slack);

  // components/Slash.svelte
  function create_fragment224(ctx) {
    let svg;
    let circle;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line, "x1", "4.93");
        attr(line, "y1", "4.93");
        attr(line, "x2", "19.07");
        attr(line, "y2", "19.07");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-slash feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-slash feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance224($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Slash = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance224, create_fragment224, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-slash", Slash);

  // components/Sliders.svelte
  function create_fragment225(ctx) {
    let svg;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let line6;
    let line7;
    let line8;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        line6 = svg_element("line");
        line7 = svg_element("line");
        line8 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "4");
        attr(line0, "y1", "21");
        attr(line0, "x2", "4");
        attr(line0, "y2", "14");
        attr(line1, "x1", "4");
        attr(line1, "y1", "10");
        attr(line1, "x2", "4");
        attr(line1, "y2", "3");
        attr(line2, "x1", "12");
        attr(line2, "y1", "21");
        attr(line2, "x2", "12");
        attr(line2, "y2", "12");
        attr(line3, "x1", "12");
        attr(line3, "y1", "8");
        attr(line3, "x2", "12");
        attr(line3, "y2", "3");
        attr(line4, "x1", "20");
        attr(line4, "y1", "21");
        attr(line4, "x2", "20");
        attr(line4, "y2", "16");
        attr(line5, "x1", "20");
        attr(line5, "y1", "12");
        attr(line5, "x2", "20");
        attr(line5, "y2", "3");
        attr(line6, "x1", "1");
        attr(line6, "y1", "14");
        attr(line6, "x2", "7");
        attr(line6, "y2", "14");
        attr(line7, "x1", "9");
        attr(line7, "y1", "8");
        attr(line7, "x2", "15");
        attr(line7, "y2", "8");
        attr(line8, "x1", "17");
        attr(line8, "y1", "16");
        attr(line8, "x2", "23");
        attr(line8, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-sliders feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, line6);
        append(svg, line7);
        append(svg, line8);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-sliders feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance225($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Sliders = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance225, create_fragment225, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-sliders", Sliders);

  // components/Smartphone.svelte
  function create_fragment226(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "5");
        attr(rect, "y", "2");
        attr(rect, "width", "14");
        attr(rect, "height", "20");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "12");
        attr(line, "y1", "18");
        attr(line, "x2", "12.01");
        attr(line, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-smartphone feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-smartphone feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance226($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Smartphone = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance226, create_fragment226, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-smartphone", Smartphone);

  // components/Smile.svelte
  function create_fragment227(ctx) {
    let svg;
    let circle;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(path, "d", "M8 14s1.5 2 4 2 4-2 4-2");
        attr(line0, "x1", "9");
        attr(line0, "y1", "9");
        attr(line0, "x2", "9.01");
        attr(line0, "y2", "9");
        attr(line1, "x1", "15");
        attr(line1, "y1", "9");
        attr(line1, "x2", "15.01");
        attr(line1, "y2", "9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-smile feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-smile feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance227($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Smile = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance227, create_fragment227, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-smile", Smile);

  // components/Speaker.svelte
  function create_fragment228(ctx) {
    let svg;
    let rect;
    let circle;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        circle = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "4");
        attr(rect, "y", "2");
        attr(rect, "width", "16");
        attr(rect, "height", "20");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(circle, "cx", "12");
        attr(circle, "cy", "14");
        attr(circle, "r", "4");
        attr(line, "x1", "12");
        attr(line, "y1", "6");
        attr(line, "x2", "12.01");
        attr(line, "y2", "6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-speaker feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, circle);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-speaker feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance228($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Speaker = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance228, create_fragment228, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-speaker", Speaker);

  // components/Square.svelte
  function create_fragment229(ctx) {
    let svg;
    let rect;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance229($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Square = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance229, create_fragment229, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-square", Square);

  // components/Star.svelte
  function create_fragment230(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-star feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-star feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance230($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Star = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance230, create_fragment230, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-star", Star);

  // components/StopCircle.svelte
  function create_fragment231(ctx) {
    let svg;
    let circle;
    let rect;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        rect = svg_element("rect");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(rect, "x", "9");
        attr(rect, "y", "9");
        attr(rect, "width", "6");
        attr(rect, "height", "6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-stop-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, rect);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-stop-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance231($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var StopCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance231, create_fragment231, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-stop-circle", StopCircle);

  // components/Sun.svelte
  function create_fragment232(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let line6;
    let line7;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        line6 = svg_element("line");
        line7 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "5");
        attr(line0, "x1", "12");
        attr(line0, "y1", "1");
        attr(line0, "x2", "12");
        attr(line0, "y2", "3");
        attr(line1, "x1", "12");
        attr(line1, "y1", "21");
        attr(line1, "x2", "12");
        attr(line1, "y2", "23");
        attr(line2, "x1", "4.22");
        attr(line2, "y1", "4.22");
        attr(line2, "x2", "5.64");
        attr(line2, "y2", "5.64");
        attr(line3, "x1", "18.36");
        attr(line3, "y1", "18.36");
        attr(line3, "x2", "19.78");
        attr(line3, "y2", "19.78");
        attr(line4, "x1", "1");
        attr(line4, "y1", "12");
        attr(line4, "x2", "3");
        attr(line4, "y2", "12");
        attr(line5, "x1", "21");
        attr(line5, "y1", "12");
        attr(line5, "x2", "23");
        attr(line5, "y2", "12");
        attr(line6, "x1", "4.22");
        attr(line6, "y1", "19.78");
        attr(line6, "x2", "5.64");
        attr(line6, "y2", "18.36");
        attr(line7, "x1", "18.36");
        attr(line7, "y1", "5.64");
        attr(line7, "x2", "19.78");
        attr(line7, "y2", "4.22");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-sun feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, line6);
        append(svg, line7);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-sun feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance232($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Sun = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance232, create_fragment232, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-sun", Sun);

  // components/Sunrise.svelte
  function create_fragment233(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M17 18a5 5 0 0 0-10 0");
        attr(line0, "x1", "12");
        attr(line0, "y1", "2");
        attr(line0, "x2", "12");
        attr(line0, "y2", "9");
        attr(line1, "x1", "4.22");
        attr(line1, "y1", "10.22");
        attr(line1, "x2", "5.64");
        attr(line1, "y2", "11.64");
        attr(line2, "x1", "1");
        attr(line2, "y1", "18");
        attr(line2, "x2", "3");
        attr(line2, "y2", "18");
        attr(line3, "x1", "21");
        attr(line3, "y1", "18");
        attr(line3, "x2", "23");
        attr(line3, "y2", "18");
        attr(line4, "x1", "18.36");
        attr(line4, "y1", "11.64");
        attr(line4, "x2", "19.78");
        attr(line4, "y2", "10.22");
        attr(line5, "x1", "23");
        attr(line5, "y1", "22");
        attr(line5, "x2", "1");
        attr(line5, "y2", "22");
        attr(polyline, "points", "8 6 12 2 16 6");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-sunrise feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-sunrise feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance233($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Sunrise = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance233, create_fragment233, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-sunrise", Sunrise);

  // components/Sunset.svelte
  function create_fragment234(ctx) {
    let svg;
    let path;
    let line0;
    let line1;
    let line2;
    let line3;
    let line4;
    let line5;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        line3 = svg_element("line");
        line4 = svg_element("line");
        line5 = svg_element("line");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M17 18a5 5 0 0 0-10 0");
        attr(line0, "x1", "12");
        attr(line0, "y1", "9");
        attr(line0, "x2", "12");
        attr(line0, "y2", "2");
        attr(line1, "x1", "4.22");
        attr(line1, "y1", "10.22");
        attr(line1, "x2", "5.64");
        attr(line1, "y2", "11.64");
        attr(line2, "x1", "1");
        attr(line2, "y1", "18");
        attr(line2, "x2", "3");
        attr(line2, "y2", "18");
        attr(line3, "x1", "21");
        attr(line3, "y1", "18");
        attr(line3, "x2", "23");
        attr(line3, "y2", "18");
        attr(line4, "x1", "18.36");
        attr(line4, "y1", "11.64");
        attr(line4, "x2", "19.78");
        attr(line4, "y2", "10.22");
        attr(line5, "x1", "23");
        attr(line5, "y1", "22");
        attr(line5, "x2", "1");
        attr(line5, "y2", "22");
        attr(polyline, "points", "16 5 12 9 8 5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-sunset feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
        append(svg, line3);
        append(svg, line4);
        append(svg, line5);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-sunset feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance234($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Sunset = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance234, create_fragment234, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-sunset", Sunset);

  // components/Tablet.svelte
  function create_fragment235(ctx) {
    let svg;
    let rect;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line = svg_element("line");
        this.c = noop;
        attr(rect, "x", "4");
        attr(rect, "y", "2");
        attr(rect, "width", "16");
        attr(rect, "height", "20");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line, "x1", "12");
        attr(line, "y1", "18");
        attr(line, "x2", "12.01");
        attr(line, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-tablet feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-tablet feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance235($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Tablet = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance235, create_fragment235, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-tablet", Tablet);

  // components/Tag.svelte
  function create_fragment236(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z");
        attr(line, "x1", "7");
        attr(line, "y1", "7");
        attr(line, "x2", "7.01");
        attr(line, "y2", "7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-tag feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-tag feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance236($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Tag = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance236, create_fragment236, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-tag", Tag);

  // components/Target.svelte
  function create_fragment237(ctx) {
    let svg;
    let circle0;
    let circle1;
    let circle2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        circle2 = svg_element("circle");
        this.c = noop;
        attr(circle0, "cx", "12");
        attr(circle0, "cy", "12");
        attr(circle0, "r", "10");
        attr(circle1, "cx", "12");
        attr(circle1, "cy", "12");
        attr(circle1, "r", "6");
        attr(circle2, "cx", "12");
        attr(circle2, "cy", "12");
        attr(circle2, "r", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-target feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, circle2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-target feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance237($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Target = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance237, create_fragment237, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-target", Target);

  // components/Terminal.svelte
  function create_fragment238(ctx) {
    let svg;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(polyline, "points", "4 17 10 11 4 5");
        attr(line, "x1", "12");
        attr(line, "y1", "19");
        attr(line, "x2", "20");
        attr(line, "y2", "19");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-terminal feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-terminal feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance238($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Terminal = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance238, create_fragment238, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-terminal", Terminal);

  // components/Thermometer.svelte
  function create_fragment239(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-thermometer feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-thermometer feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance239($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Thermometer = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance239, create_fragment239, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-thermometer", Thermometer);

  // components/ThumbsDown.svelte
  function create_fragment240(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-thumbs-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-thumbs-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance240($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ThumbsDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance240, create_fragment240, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-thumbs-down", ThumbsDown);

  // components/ThumbsUp.svelte
  function create_fragment241(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-thumbs-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-thumbs-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance241($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ThumbsUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance241, create_fragment241, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-thumbs-up", ThumbsUp);

  // components/ToggleLeft.svelte
  function create_fragment242(ctx) {
    let svg;
    let rect;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        circle = svg_element("circle");
        this.c = noop;
        attr(rect, "x", "1");
        attr(rect, "y", "5");
        attr(rect, "width", "22");
        attr(rect, "height", "14");
        attr(rect, "rx", "7");
        attr(rect, "ry", "7");
        attr(circle, "cx", "8");
        attr(circle, "cy", "12");
        attr(circle, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-toggle-left feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-toggle-left feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance242($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ToggleLeft = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance242, create_fragment242, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-toggle-left", ToggleLeft);

  // components/ToggleRight.svelte
  function create_fragment243(ctx) {
    let svg;
    let rect;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        circle = svg_element("circle");
        this.c = noop;
        attr(rect, "x", "1");
        attr(rect, "y", "5");
        attr(rect, "width", "22");
        attr(rect, "height", "14");
        attr(rect, "rx", "7");
        attr(rect, "ry", "7");
        attr(circle, "cx", "16");
        attr(circle, "cy", "12");
        attr(circle, "r", "3");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-toggle-right feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-toggle-right feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance243($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ToggleRight = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance243, create_fragment243, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-toggle-right", ToggleRight);

  // components/Tool.svelte
  function create_fragment244(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-tool feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-tool feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance244($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Tool = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance244, create_fragment244, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-tool", Tool);

  // components/Trash2.svelte
  function create_fragment245(ctx) {
    let svg;
    let polyline;
    let path;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polyline, "points", "3 6 5 6 21 6");
        attr(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
        attr(line0, "x1", "10");
        attr(line0, "y1", "11");
        attr(line0, "x2", "10");
        attr(line0, "y2", "17");
        attr(line1, "x1", "14");
        attr(line1, "y1", "11");
        attr(line1, "x2", "14");
        attr(line1, "y2", "17");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-trash-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-trash-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance245($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Trash2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance245, create_fragment245, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-trash-2", Trash2);

  // components/Trash.svelte
  function create_fragment246(ctx) {
    let svg;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(polyline, "points", "3 6 5 6 21 6");
        attr(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-trash feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-trash feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance246($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Trash = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance246, create_fragment246, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-trash", Trash);

  // components/Trello.svelte
  function create_fragment247(ctx) {
    let svg;
    let rect0;
    let rect1;
    let rect2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect0 = svg_element("rect");
        rect1 = svg_element("rect");
        rect2 = svg_element("rect");
        this.c = noop;
        attr(rect0, "x", "3");
        attr(rect0, "y", "3");
        attr(rect0, "width", "18");
        attr(rect0, "height", "18");
        attr(rect0, "rx", "2");
        attr(rect0, "ry", "2");
        attr(rect1, "x", "7");
        attr(rect1, "y", "7");
        attr(rect1, "width", "3");
        attr(rect1, "height", "9");
        attr(rect2, "x", "14");
        attr(rect2, "y", "7");
        attr(rect2, "width", "3");
        attr(rect2, "height", "5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-trello feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect0);
        append(svg, rect1);
        append(svg, rect2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-trello feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance247($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Trello = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance247, create_fragment247, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-trello", Trello);

  // components/TrendingDown.svelte
  function create_fragment248(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "23 18 13.5 8.5 8.5 13.5 1 6");
        attr(polyline1, "points", "17 18 23 18 23 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-trending-down feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-trending-down feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance248($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var TrendingDown = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance248, create_fragment248, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-trending-down", TrendingDown);

  // components/TrendingUp.svelte
  function create_fragment249(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "23 6 13.5 15.5 8.5 10.5 1 18");
        attr(polyline1, "points", "17 6 23 6 23 12");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-trending-up feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-trending-up feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance249($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var TrendingUp = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance249, create_fragment249, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-trending-up", TrendingUp);

  // components/Triangle.svelte
  function create_fragment250(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-triangle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-triangle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance250($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Triangle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance250, create_fragment250, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-triangle", Triangle);

  // components/Truck.svelte
  function create_fragment251(ctx) {
    let svg;
    let rect;
    let polygon;
    let circle0;
    let circle1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        polygon = svg_element("polygon");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        this.c = noop;
        attr(rect, "x", "1");
        attr(rect, "y", "3");
        attr(rect, "width", "15");
        attr(rect, "height", "13");
        attr(polygon, "points", "16 8 20 8 23 11 23 16 16 16 16 8");
        attr(circle0, "cx", "5.5");
        attr(circle0, "cy", "18.5");
        attr(circle0, "r", "2.5");
        attr(circle1, "cx", "18.5");
        attr(circle1, "cy", "18.5");
        attr(circle1, "r", "2.5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-truck feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, polygon);
        append(svg, circle0);
        append(svg, circle1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-truck feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance251($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Truck = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance251, create_fragment251, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-truck", Truck);

  // components/Tv.svelte
  function create_fragment252(ctx) {
    let svg;
    let rect;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(rect, "x", "2");
        attr(rect, "y", "7");
        attr(rect, "width", "20");
        attr(rect, "height", "15");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(polyline, "points", "17 2 12 7 7 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-tv feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-tv feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance252($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Tv = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance252, create_fragment252, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-tv", Tv);

  // components/Twitch.svelte
  function create_fragment253(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-twitch feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-twitch feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance253($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Twitch = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance253, create_fragment253, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-twitch", Twitch);

  // components/Twitter.svelte
  function create_fragment254(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-twitter feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-twitter feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance254($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Twitter = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance254, create_fragment254, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-twitter", Twitter);

  // components/Type.svelte
  function create_fragment255(ctx) {
    let svg;
    let polyline;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline = svg_element("polyline");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polyline, "points", "4 7 4 4 20 4 20 7");
        attr(line0, "x1", "9");
        attr(line0, "y1", "20");
        attr(line0, "x2", "15");
        attr(line0, "y2", "20");
        attr(line1, "x1", "12");
        attr(line1, "y1", "4");
        attr(line1, "x2", "12");
        attr(line1, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-type feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-type feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance255($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Type = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance255, create_fragment255, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-type", Type);

  // components/Umbrella.svelte
  function create_fragment256(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-umbrella feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-umbrella feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance256($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Umbrella = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance256, create_fragment256, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-umbrella", Umbrella);

  // components/Underline.svelte
  function create_fragment257(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3");
        attr(line, "x1", "4");
        attr(line, "y1", "21");
        attr(line, "x2", "20");
        attr(line, "y2", "21");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-underline feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-underline feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance257($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Underline = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance257, create_fragment257, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-underline", Underline);

  // components/Unlock.svelte
  function create_fragment258(ctx) {
    let svg;
    let rect;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        path = svg_element("path");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "11");
        attr(rect, "width", "18");
        attr(rect, "height", "11");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(path, "d", "M7 11V7a5 5 0 0 1 9.9-1");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-unlock feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-unlock feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance258($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Unlock = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance258, create_fragment258, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-unlock", Unlock);

  // components/UploadCloud.svelte
  function create_fragment259(ctx) {
    let svg;
    let polyline0;
    let line;
    let path;
    let polyline1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        line = svg_element("line");
        path = svg_element("path");
        polyline1 = svg_element("polyline");
        this.c = noop;
        attr(polyline0, "points", "16 16 12 12 8 16");
        attr(line, "x1", "12");
        attr(line, "y1", "12");
        attr(line, "x2", "12");
        attr(line, "y2", "21");
        attr(path, "d", "M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3");
        attr(polyline1, "points", "16 16 12 12 8 16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-upload-cloud feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, line);
        append(svg, path);
        append(svg, polyline1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-upload-cloud feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance259($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var UploadCloud = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance259, create_fragment259, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-upload-cloud", UploadCloud);

  // components/Upload.svelte
  function create_fragment260(ctx) {
    let svg;
    let path;
    let polyline;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polyline = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
        attr(polyline, "points", "17 8 12 3 7 8");
        attr(line, "x1", "12");
        attr(line, "y1", "3");
        attr(line, "x2", "12");
        attr(line, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-upload feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polyline);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-upload feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance260($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Upload = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance260, create_fragment260, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-upload", Upload);

  // components/UserCheck.svelte
  function create_fragment261(ctx) {
    let svg;
    let path;
    let circle;
    let polyline;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        this.c = noop;
        attr(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "8.5");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(polyline, "points", "17 11 19 13 23 9");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-user-check feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
        append(svg, polyline);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-user-check feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance261($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var UserCheck = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance261, create_fragment261, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-user-check", UserCheck);

  // components/UserMinus.svelte
  function create_fragment262(ctx) {
    let svg;
    let path;
    let circle;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "8.5");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(line, "x1", "23");
        attr(line, "y1", "11");
        attr(line, "x2", "17");
        attr(line, "y2", "11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-user-minus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-user-minus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance262($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var UserMinus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance262, create_fragment262, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-user-minus", UserMinus);

  // components/UserPlus.svelte
  function create_fragment263(ctx) {
    let svg;
    let path;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "8.5");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(line0, "x1", "20");
        attr(line0, "y1", "8");
        attr(line0, "x2", "20");
        attr(line0, "y2", "14");
        attr(line1, "x1", "23");
        attr(line1, "y1", "11");
        attr(line1, "x2", "17");
        attr(line1, "y2", "11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-user-plus feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-user-plus feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance263($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var UserPlus = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance263, create_fragment263, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-user-plus", UserPlus);

  // components/UserX.svelte
  function create_fragment264(ctx) {
    let svg;
    let path;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "8.5");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(line0, "x1", "18");
        attr(line0, "y1", "8");
        attr(line0, "x2", "23");
        attr(line0, "y2", "13");
        attr(line1, "x1", "23");
        attr(line1, "y1", "8");
        attr(line1, "x2", "18");
        attr(line1, "y2", "13");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-user-x feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-user-x feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance264($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var UserX = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance264, create_fragment264, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-user-x", UserX);

  // components/User.svelte
  function create_fragment265(ctx) {
    let svg;
    let path;
    let circle;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        circle = svg_element("circle");
        this.c = noop;
        attr(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "12");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-user feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, circle);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-user feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance265($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var User = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance265, create_fragment265, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-user", User);

  // components/Users.svelte
  function create_fragment266(ctx) {
    let svg;
    let path0;
    let circle;
    let path1;
    let path2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        circle = svg_element("circle");
        path1 = svg_element("path");
        path2 = svg_element("path");
        this.c = noop;
        attr(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
        attr(circle, "cx", "9");
        attr(circle, "cy", "7");
        attr(circle, "r", "4");
        attr(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
        attr(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-users feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, circle);
        append(svg, path1);
        append(svg, path2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-users feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance266($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Users = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance266, create_fragment266, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-users", Users);

  // components/VideoOff.svelte
  function create_fragment267(ctx) {
    let svg;
    let path;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path, "d", "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-video-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-video-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance267($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var VideoOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance267, create_fragment267, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-video-off", VideoOff);

  // components/Video.svelte
  function create_fragment268(ctx) {
    let svg;
    let polygon;
    let rect;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        rect = svg_element("rect");
        this.c = noop;
        attr(polygon, "points", "23 7 16 12 23 17 23 7");
        attr(rect, "x", "1");
        attr(rect, "y", "5");
        attr(rect, "width", "15");
        attr(rect, "height", "14");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-video feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, rect);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-video feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance268($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Video = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance268, create_fragment268, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-video", Video);

  // components/Voicemail.svelte
  function create_fragment269(ctx) {
    let svg;
    let circle0;
    let circle1;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle0 = svg_element("circle");
        circle1 = svg_element("circle");
        line = svg_element("line");
        this.c = noop;
        attr(circle0, "cx", "5.5");
        attr(circle0, "cy", "11.5");
        attr(circle0, "r", "4.5");
        attr(circle1, "cx", "18.5");
        attr(circle1, "cy", "11.5");
        attr(circle1, "r", "4.5");
        attr(line, "x1", "5.5");
        attr(line, "y1", "16");
        attr(line, "x2", "18.5");
        attr(line, "y2", "16");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-voicemail feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle0);
        append(svg, circle1);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-voicemail feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance269($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Voicemail = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance269, create_fragment269, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-voicemail", Voicemail);

  // components/Volume1.svelte
  function create_fragment270(ctx) {
    let svg;
    let polygon;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        path = svg_element("path");
        this.c = noop;
        attr(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
        attr(path, "d", "M15.54 8.46a5 5 0 0 1 0 7.07");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-volume-1 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-volume-1 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance270($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Volume1 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance270, create_fragment270, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-volume-1", Volume1);

  // components/Volume2.svelte
  function create_fragment271(ctx) {
    let svg;
    let polygon;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        path = svg_element("path");
        this.c = noop;
        attr(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
        attr(path, "d", "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-volume-2 feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-volume-2 feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance271($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Volume2 = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance271, create_fragment271, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-volume-2", Volume2);

  // components/VolumeX.svelte
  function create_fragment272(ctx) {
    let svg;
    let polygon;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
        attr(line0, "x1", "23");
        attr(line0, "y1", "9");
        attr(line0, "x2", "17");
        attr(line0, "y2", "15");
        attr(line1, "x1", "17");
        attr(line1, "y1", "9");
        attr(line1, "x2", "23");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-volume-x feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-volume-x feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance272($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var VolumeX = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance272, create_fragment272, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-volume-x", VolumeX);

  // components/Volume.svelte
  function create_fragment273(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-volume feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-volume feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance273($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Volume = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance273, create_fragment273, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-volume", Volume);

  // components/Watch.svelte
  function create_fragment274(ctx) {
    let svg;
    let circle;
    let polyline;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        polyline = svg_element("polyline");
        path = svg_element("path");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "7");
        attr(polyline, "points", "12 9 12 12 13.5 13.5");
        attr(path, "d", "M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-watch feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, polyline);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-watch feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance274($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Watch = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance274, create_fragment274, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-watch", Watch);

  // components/WifiOff.svelte
  function create_fragment275(ctx) {
    let svg;
    let line0;
    let path0;
    let path1;
    let path2;
    let path3;
    let path4;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        path3 = svg_element("path");
        path4 = svg_element("path");
        line1 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "1");
        attr(line0, "y1", "1");
        attr(line0, "x2", "23");
        attr(line0, "y2", "23");
        attr(path0, "d", "M16.72 11.06A10.94 10.94 0 0 1 19 12.55");
        attr(path1, "d", "M5 12.55a10.94 10.94 0 0 1 5.17-2.39");
        attr(path2, "d", "M10.71 5.05A16 16 0 0 1 22.58 9");
        attr(path3, "d", "M1.42 9a15.91 15.91 0 0 1 4.7-2.88");
        attr(path4, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
        attr(line1, "x1", "12");
        attr(line1, "y1", "20");
        attr(line1, "x2", "12.01");
        attr(line1, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-wifi-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, path3);
        append(svg, path4);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-wifi-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance275($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var WifiOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance275, create_fragment275, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-wifi-off", WifiOff);

  // components/Wifi.svelte
  function create_fragment276(ctx) {
    let svg;
    let path0;
    let path1;
    let path2;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path0 = svg_element("path");
        path1 = svg_element("path");
        path2 = svg_element("path");
        line = svg_element("line");
        this.c = noop;
        attr(path0, "d", "M5 12.55a11 11 0 0 1 14.08 0");
        attr(path1, "d", "M1.42 9a16 16 0 0 1 21.16 0");
        attr(path2, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
        attr(line, "x1", "12");
        attr(line, "y1", "20");
        attr(line, "x2", "12.01");
        attr(line, "y2", "20");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-wifi feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path0);
        append(svg, path1);
        append(svg, path2);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-wifi feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance276($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Wifi = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance276, create_fragment276, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-wifi", Wifi);

  // components/Wind.svelte
  function create_fragment277(ctx) {
    let svg;
    let path;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        this.c = noop;
        attr(path, "d", "M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-wind feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-wind feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance277($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Wind = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance277, create_fragment277, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-wind", Wind);

  // components/XCircle.svelte
  function create_fragment278(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "12");
        attr(circle, "cy", "12");
        attr(circle, "r", "10");
        attr(line0, "x1", "15");
        attr(line0, "y1", "9");
        attr(line0, "x2", "9");
        attr(line0, "y2", "15");
        attr(line1, "x1", "9");
        attr(line1, "y1", "9");
        attr(line1, "x2", "15");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-x-circle feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-x-circle feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance278($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var XCircle = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance278, create_fragment278, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-x-circle", XCircle);

  // components/XOctagon.svelte
  function create_fragment279(ctx) {
    let svg;
    let polygon;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
        attr(line0, "x1", "15");
        attr(line0, "y1", "9");
        attr(line0, "x2", "9");
        attr(line0, "y2", "15");
        attr(line1, "x1", "9");
        attr(line1, "y1", "9");
        attr(line1, "x2", "15");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-x-octagon feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-x-octagon feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance279($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var XOctagon = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance279, create_fragment279, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-x-octagon", XOctagon);

  // components/XSquare.svelte
  function create_fragment280(ctx) {
    let svg;
    let rect;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        rect = svg_element("rect");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(rect, "x", "3");
        attr(rect, "y", "3");
        attr(rect, "width", "18");
        attr(rect, "height", "18");
        attr(rect, "rx", "2");
        attr(rect, "ry", "2");
        attr(line0, "x1", "9");
        attr(line0, "y1", "9");
        attr(line0, "x2", "15");
        attr(line0, "y2", "15");
        attr(line1, "x1", "15");
        attr(line1, "y1", "9");
        attr(line1, "x2", "9");
        attr(line1, "y2", "15");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-x-square feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, rect);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-x-square feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance280($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var XSquare = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance280, create_fragment280, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-x-square", XSquare);

  // components/X.svelte
  function create_fragment281(ctx) {
    let svg;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(line0, "x1", "18");
        attr(line0, "y1", "6");
        attr(line0, "x2", "6");
        attr(line0, "y2", "18");
        attr(line1, "x1", "6");
        attr(line1, "y1", "6");
        attr(line1, "x2", "18");
        attr(line1, "y2", "18");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-x feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-x feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance281($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var X = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance281, create_fragment281, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-x", X);

  // components/Youtube.svelte
  function create_fragment282(ctx) {
    let svg;
    let path;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        path = svg_element("path");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(path, "d", "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z");
        attr(polygon, "points", "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-youtube feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, path);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-youtube feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance282($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Youtube = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance282, create_fragment282, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-youtube", Youtube);

  // components/ZapOff.svelte
  function create_fragment283(ctx) {
    let svg;
    let polyline0;
    let polyline1;
    let polyline2;
    let line;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polyline0 = svg_element("polyline");
        polyline1 = svg_element("polyline");
        polyline2 = svg_element("polyline");
        line = svg_element("line");
        this.c = noop;
        attr(polyline0, "points", "12.41 6.75 13 2 10.57 4.92");
        attr(polyline1, "points", "18.57 12.91 21 10 15.66 10");
        attr(polyline2, "points", "8 8 3 14 12 14 11 22 16 16");
        attr(line, "x1", "1");
        attr(line, "y1", "1");
        attr(line, "x2", "23");
        attr(line, "y2", "23");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-zap-off feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polyline0);
        append(svg, polyline1);
        append(svg, polyline2);
        append(svg, line);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-zap-off feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance283($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ZapOff = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance283, create_fragment283, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-zap-off", ZapOff);

  // components/Zap.svelte
  function create_fragment284(ctx) {
    let svg;
    let polygon;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        polygon = svg_element("polygon");
        this.c = noop;
        attr(polygon, "points", "13 2 3 14 12 14 11 22 21 10 12 10 13 2");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-zap feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, polygon);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-zap feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance284($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var Zap = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance284, create_fragment284, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-zap", Zap);

  // components/ZoomIn.svelte
  function create_fragment285(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let line2;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        line2 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "11");
        attr(circle, "cy", "11");
        attr(circle, "r", "8");
        attr(line0, "x1", "21");
        attr(line0, "y1", "21");
        attr(line0, "x2", "16.65");
        attr(line0, "y2", "16.65");
        attr(line1, "x1", "11");
        attr(line1, "y1", "8");
        attr(line1, "x2", "11");
        attr(line1, "y2", "14");
        attr(line2, "x1", "8");
        attr(line2, "y1", "11");
        attr(line2, "x2", "14");
        attr(line2, "y2", "11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-zoom-in feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
        append(svg, line2);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-zoom-in feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance285($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ZoomIn = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance285, create_fragment285, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-zoom-in", ZoomIn);

  // components/ZoomOut.svelte
  function create_fragment286(ctx) {
    let svg;
    let circle;
    let line0;
    let line1;
    let svg_class_value;
    return {
      c() {
        svg = svg_element("svg");
        circle = svg_element("circle");
        line0 = svg_element("line");
        line1 = svg_element("line");
        this.c = noop;
        attr(circle, "cx", "11");
        attr(circle, "cy", "11");
        attr(circle, "r", "8");
        attr(line0, "x1", "21");
        attr(line0, "y1", "21");
        attr(line0, "x2", "16.65");
        attr(line0, "y2", "16.65");
        attr(line1, "x1", "8");
        attr(line1, "y1", "11");
        attr(line1, "x2", "14");
        attr(line1, "y2", "11");
        attr(svg, "xmlns", "http://www.w3.org/2000/svg");
        attr(svg, "class", svg_class_value = "feather feather-zoom-out feather-size-" + ctx[3] + "\n    " + ctx[0]);
        attr(svg, "width", ctx[8]);
        attr(svg, "height", ctx[8]);
        attr(svg, "viewBox", "0 0 24 24");
        attr(svg, "fill", ctx[4]);
        attr(svg, "stroke", ctx[2]);
        attr(svg, "stroke-width", ctx[7]);
        attr(svg, "stroke-linecap", ctx[5]);
        attr(svg, "stroke-linejoin", ctx[6]);
        attr(svg, "style", ctx[1]);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        append(svg, circle);
        append(svg, line0);
        append(svg, line1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 9 && svg_class_value !== (svg_class_value = "feather feather-zoom-out feather-size-" + ctx2[3] + "\n    " + ctx2[0])) {
          attr(svg, "class", svg_class_value);
        }
        if (dirty & 256) {
          attr(svg, "width", ctx2[8]);
        }
        if (dirty & 256) {
          attr(svg, "height", ctx2[8]);
        }
        if (dirty & 16) {
          attr(svg, "fill", ctx2[4]);
        }
        if (dirty & 4) {
          attr(svg, "stroke", ctx2[2]);
        }
        if (dirty & 128) {
          attr(svg, "stroke-width", ctx2[7]);
        }
        if (dirty & 32) {
          attr(svg, "stroke-linecap", ctx2[5]);
        }
        if (dirty & 64) {
          attr(svg, "stroke-linejoin", ctx2[6]);
        }
        if (dirty & 2) {
          attr(svg, "style", ctx2[1]);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(svg);
      }
    };
  }
  function instance286($$self, $$props, $$invalidate) {
    let {class: _class = ""} = $$props;
    let {style = ""} = $$props;
    let {color = "currentColor"} = $$props;
    let {size = ICON_SIZES.default} = $$props;
    let {fill = "none"} = $$props;
    let {linecap = "round"} = $$props;
    let {linejoin = "round"} = $$props;
    let {width = "2"} = $$props;
    let font_size;
    $$self.$$set = ($$props2) => {
      if ("class" in $$props2)
        $$invalidate(0, _class = $$props2.class);
      if ("style" in $$props2)
        $$invalidate(1, style = $$props2.style);
      if ("color" in $$props2)
        $$invalidate(2, color = $$props2.color);
      if ("size" in $$props2)
        $$invalidate(3, size = $$props2.size);
      if ("fill" in $$props2)
        $$invalidate(4, fill = $$props2.fill);
      if ("linecap" in $$props2)
        $$invalidate(5, linecap = $$props2.linecap);
      if ("linejoin" in $$props2)
        $$invalidate(6, linejoin = $$props2.linejoin);
      if ("width" in $$props2)
        $$invalidate(7, width = $$props2.width);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 8) {
        $: {
          if (is_size_primitive(size)) {
            $$invalidate(8, font_size = size);
          } else {
            $$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
          }
        }
      }
    };
    return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
  }
  var ZoomOut = class extends SvelteElement {
    constructor(options) {
      super();
      init(this, {
        target: this.shadowRoot,
        props: attribute_to_object(this.attributes),
        customElement: true
      }, instance286, create_fragment286, safe_not_equal, {
        class: 0,
        style: 1,
        color: 2,
        size: 3,
        fill: 4,
        linecap: 5,
        linejoin: 6,
        width: 7
      });
      if (options) {
        if (options.target) {
          insert(options.target, this, options.anchor);
        }
        if (options.props) {
          this.$set(options.props);
          flush();
        }
      }
    }
    static get observedAttributes() {
      return ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];
    }
    get class() {
      return this.$$.ctx[0];
    }
    set class(_class) {
      this.$set({class: _class});
      flush();
    }
    get style() {
      return this.$$.ctx[1];
    }
    set style(style) {
      this.$set({style});
      flush();
    }
    get color() {
      return this.$$.ctx[2];
    }
    set color(color) {
      this.$set({color});
      flush();
    }
    get size() {
      return this.$$.ctx[3];
    }
    set size(size) {
      this.$set({size});
      flush();
    }
    get fill() {
      return this.$$.ctx[4];
    }
    set fill(fill) {
      this.$set({fill});
      flush();
    }
    get linecap() {
      return this.$$.ctx[5];
    }
    set linecap(linecap) {
      this.$set({linecap});
      flush();
    }
    get linejoin() {
      return this.$$.ctx[6];
    }
    set linejoin(linejoin) {
      this.$set({linejoin});
      flush();
    }
    get width() {
      return this.$$.ctx[7];
    }
    set width(width) {
      this.$set({width});
      flush();
    }
  };
  customElements.define("feather-zoom-out", ZoomOut);
})();
//# sourceMappingURL=svelte-feather.webcomponents.js.map
