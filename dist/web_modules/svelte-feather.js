function noop() { }
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let current_component;
function set_current_component(component) {
    current_component = component;
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if ($$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set() {
        // overridden by instance, if it has props
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.3' }, detail)));
}
function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", { node });
    detach(node);
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
    else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error(`'target' is a required option`);
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

/**
 * Represents the standard size values end-developers can use as icon sizes
 */
const ICON_SIZES = {
    default: "default",
    tiny: "tiny",
    small: "small",
    large: "large",
    huge: "huge"
};

/**
 * Represents the standard size tiers icons can be
 */
const ICON_SIZE_UNITS = {
    [ICON_SIZES.default]: "24px",
    [ICON_SIZES.tiny]: "12px",
    [ICON_SIZES.small]: "16px",
    [ICON_SIZES.large]: "32px",
    [ICON_SIZES.huge]: "48px"
};

/**
 * Returns if the value is a CSS sizing unit primitive
 * @param {string} value
 */
function is_size_primitive(value) {
    return (
        value.endsWith("%") || value.endsWith("px") || value.endsWith("em") || value.endsWith("rem")
    );
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconActivity.svelte generated by Svelte v3.22.3 */
const file = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconActivity.svelte";

function create_fragment(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "22 12 18 12 15 21 9 3 6 12 2 12");
			add_location(polyline, file, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-activity feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-activity feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconActivity> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconActivity", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconActivity extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconActivity",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconActivity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconActivity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAirplay.svelte generated by Svelte v3.22.3 */
const file$1 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAirplay.svelte";

function create_fragment$1(ctx) {
	let svg;
	let path;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polygon = svg_element("polygon");
			attr_dev(path, "d", "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1");
			add_location(path, file$1, 39, 4, 920);
			attr_dev(polygon, "points", "12 15 17 21 7 21 12 15");
			add_location(polygon, file$1, 40, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-airplay feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-airplay feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAirplay> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAirplay", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAirplay extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAirplay",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAirplay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAirplay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertCircle.svelte generated by Svelte v3.22.3 */
const file$2 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertCircle.svelte";

function create_fragment$2(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2, 39, 4, 925);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2, 40, 4, 963);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$2, 41, 4, 1007);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-alert-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-alert-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlertCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlertCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlertCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlertCircle",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlertCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlertCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertOctagon.svelte generated by Svelte v3.22.3 */
const file$3 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertOctagon.svelte";

function create_fragment$3(ctx) {
	let svg;
	let polygon;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$3, 39, 4, 926);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$3, 40, 4, 1022);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$3, 41, 4, 1066);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-alert-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-alert-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlertOctagon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlertOctagon", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlertOctagon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlertOctagon",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlertOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlertOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertTriangle.svelte generated by Svelte v3.22.3 */
const file$4 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlertTriangle.svelte";

function create_fragment$4(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
			add_location(path, file$4, 39, 4, 927);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "13");
			add_location(line0, file$4, 41, 4, 1041);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "17");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$4, 42, 4, 1085);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-alert-triangle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-alert-triangle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlertTriangle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlertTriangle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlertTriangle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlertTriangle",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlertTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlertTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignCenter.svelte generated by Svelte v3.22.3 */
const file$5 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignCenter.svelte";

function create_fragment$5(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$5, 39, 4, 925);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$5, 40, 4, 969);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$5, 41, 4, 1011);
			attr_dev(line3, "x1", "18");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "6");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$5, 42, 4, 1055);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-align-center feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$5, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-align-center feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlignCenter> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlignCenter", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlignCenter extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlignCenter",
			options,
			id: create_fragment$5.name
		});
	}

	get class() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlignCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlignCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignJustify.svelte generated by Svelte v3.22.3 */
const file$6 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignJustify.svelte";

function create_fragment$6(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "3");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$6, 39, 4, 926);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$6, 40, 4, 970);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$6, 41, 4, 1012);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "3");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$6, 42, 4, 1056);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-align-justify feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$6, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-align-justify feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlignJustify> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlignJustify", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlignJustify extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlignJustify",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlignJustify>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlignJustify>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignLeft.svelte generated by Svelte v3.22.3 */
const file$7 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignLeft.svelte";

function create_fragment$7(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(line0, "x1", "17");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "3");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$7, 39, 4, 923);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$7, 40, 4, 967);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$7, 41, 4, 1009);
			attr_dev(line3, "x1", "17");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "3");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$7, 42, 4, 1053);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-align-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$7, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-align-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlignLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlignLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlignLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlignLeft",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlignLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlignLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignRight.svelte generated by Svelte v3.22.3 */
const file$8 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAlignRight.svelte";

function create_fragment$8(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$8, 39, 4, 924);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$8, 40, 4, 968);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$8, 41, 4, 1010);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "7");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$8, 42, 4, 1054);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-align-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$8, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-align-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAlignRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAlignRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAlignRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAlignRight",
			options,
			id: create_fragment$8.name
		});
	}

	get class() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAlignRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAlignRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAnchor.svelte generated by Svelte v3.22.3 */
const file$9 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAnchor.svelte";

function create_fragment$9(ctx) {
	let svg;
	let circle;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "5");
			attr_dev(circle, "r", "3");
			add_location(circle, file$9, 39, 4, 919);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "8");
			add_location(line, file$9, 40, 4, 955);
			attr_dev(path, "d", "M5 12H2a10 10 0 0 0 20 0h-3");
			add_location(path, file$9, 41, 4, 999);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-anchor feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$9, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-anchor feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAnchor> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAnchor", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAnchor extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAnchor",
			options,
			id: create_fragment$9.name
		});
	}

	get class() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAperture.svelte generated by Svelte v3.22.3 */
const file$a = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAperture.svelte";

function create_fragment$a(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$a, 39, 4, 921);
			attr_dev(line0, "x1", "14.31");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "20.05");
			attr_dev(line0, "y2", "17.94");
			add_location(line0, file$a, 40, 4, 959);
			attr_dev(line1, "x1", "9.69");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "21.17");
			attr_dev(line1, "y2", "8");
			add_location(line1, file$a, 41, 4, 1012);
			attr_dev(line2, "x1", "7.38");
			attr_dev(line2, "y1", "12");
			attr_dev(line2, "x2", "13.12");
			attr_dev(line2, "y2", "2.06");
			add_location(line2, file$a, 42, 4, 1060);
			attr_dev(line3, "x1", "9.69");
			attr_dev(line3, "y1", "16");
			attr_dev(line3, "x2", "3.95");
			attr_dev(line3, "y2", "6.06");
			add_location(line3, file$a, 43, 4, 1112);
			attr_dev(line4, "x1", "14.31");
			attr_dev(line4, "y1", "16");
			attr_dev(line4, "x2", "2.83");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$a, 44, 4, 1163);
			attr_dev(line5, "x1", "16.62");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "10.88");
			attr_dev(line5, "y2", "21.94");
			add_location(line5, file$a, 45, 4, 1213);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-aperture feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$a, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-aperture feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAperture> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAperture", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAperture extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAperture",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAperture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAperture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArchive.svelte generated by Svelte v3.22.3 */
const file$b = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArchive.svelte";

function create_fragment$b(ctx) {
	let svg;
	let polyline;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(polyline, "points", "21 8 21 21 3 21 3 8");
			add_location(polyline, file$b, 39, 4, 920);
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "5");
			add_location(rect, file$b, 40, 4, 966);
			attr_dev(line, "x1", "10");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "14");
			attr_dev(line, "y2", "12");
			add_location(line, file$b, 41, 4, 1013);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-archive feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$b, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-archive feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArchive> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArchive", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArchive extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArchive",
			options,
			id: create_fragment$b.name
		});
	}

	get class() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArchive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArchive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownCircle.svelte generated by Svelte v3.22.3 */
const file$c = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownCircle.svelte";

function create_fragment$c(ctx) {
	let svg;
	let circle;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$c, 39, 4, 930);
			attr_dev(polyline, "points", "8 12 12 16 16 12");
			add_location(polyline, file$c, 40, 4, 968);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "8");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "16");
			add_location(line, file$c, 41, 4, 1011);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$c, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowDownCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowDownCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowDownCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowDownCircle",
			options,
			id: create_fragment$c.name
		});
	}

	get class() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowDownCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowDownCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownLeft.svelte generated by Svelte v3.22.3 */
const file$d = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownLeft.svelte";

function create_fragment$d(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "17");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "7");
			attr_dev(line, "y2", "17");
			add_location(line, file$d, 39, 4, 928);
			attr_dev(polyline, "points", "17 17 7 17 7 7");
			add_location(polyline, file$d, 40, 4, 971);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$d, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowDownLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowDownLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowDownLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowDownLeft",
			options,
			id: create_fragment$d.name
		});
	}

	get class() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownRight.svelte generated by Svelte v3.22.3 */
const file$e = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDownRight.svelte";

function create_fragment$e(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "17");
			add_location(line, file$e, 39, 4, 929);
			attr_dev(polyline, "points", "17 7 17 17 7 17");
			add_location(polyline, file$e, 40, 4, 972);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$e, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowDownRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowDownRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowDownRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowDownRight",
			options,
			id: create_fragment$e.name
		});
	}

	get class() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDown.svelte generated by Svelte v3.22.3 */
const file$f = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowDown.svelte";

function create_fragment$f(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "19");
			add_location(line, file$f, 39, 4, 923);
			attr_dev(polyline, "points", "19 12 12 19 5 12");
			add_location(polyline, file$f, 40, 4, 967);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$f, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowDown",
			options,
			id: create_fragment$f.name
		});
	}

	get class() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowLeftCircle.svelte generated by Svelte v3.22.3 */
const file$g = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowLeftCircle.svelte";

function create_fragment$g(ctx) {
	let svg;
	let circle;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$g, 39, 4, 930);
			attr_dev(polyline, "points", "12 8 8 12 12 16");
			add_location(polyline, file$g, 40, 4, 968);
			attr_dev(line, "x1", "16");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "8");
			attr_dev(line, "y2", "12");
			add_location(line, file$g, 41, 4, 1010);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-left-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$g, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-left-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowLeftCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowLeftCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowLeftCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowLeftCircle",
			options,
			id: create_fragment$g.name
		});
	}

	get class() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowLeftCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowLeftCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowLeft.svelte generated by Svelte v3.22.3 */
const file$h = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowLeft.svelte";

function create_fragment$h(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "12");
			add_location(line, file$h, 39, 4, 923);
			attr_dev(polyline, "points", "12 19 5 12 12 5");
			add_location(polyline, file$h, 40, 4, 967);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$h, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowLeft",
			options,
			id: create_fragment$h.name
		});
	}

	get class() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowRightCircle.svelte generated by Svelte v3.22.3 */
const file$i = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowRightCircle.svelte";

function create_fragment$i(ctx) {
	let svg;
	let circle;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$i, 39, 4, 931);
			attr_dev(polyline, "points", "12 16 16 12 12 8");
			add_location(polyline, file$i, 40, 4, 969);
			attr_dev(line, "x1", "8");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "12");
			add_location(line, file$i, 41, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-right-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$i, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-right-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowRightCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowRightCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowRightCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowRightCircle",
			options,
			id: create_fragment$i.name
		});
	}

	get class() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowRightCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowRightCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowRight.svelte generated by Svelte v3.22.3 */
const file$j = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowRight.svelte";

function create_fragment$j(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "12");
			add_location(line, file$j, 39, 4, 924);
			attr_dev(polyline, "points", "12 5 19 12 12 19");
			add_location(polyline, file$j, 40, 4, 968);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$j, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowRight",
			options,
			id: create_fragment$j.name
		});
	}

	get class() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpCircle.svelte generated by Svelte v3.22.3 */
const file$k = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpCircle.svelte";

function create_fragment$k(ctx) {
	let svg;
	let circle;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$k, 39, 4, 928);
			attr_dev(polyline, "points", "16 12 12 8 8 12");
			add_location(polyline, file$k, 40, 4, 966);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "16");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "8");
			add_location(line, file$k, 41, 4, 1008);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$k, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowUpCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowUpCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowUpCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowUpCircle",
			options,
			id: create_fragment$k.name
		});
	}

	get class() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowUpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowUpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpLeft.svelte generated by Svelte v3.22.3 */
const file$l = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpLeft.svelte";

function create_fragment$l(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "17");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "7");
			attr_dev(line, "y2", "7");
			add_location(line, file$l, 39, 4, 926);
			attr_dev(polyline, "points", "7 17 7 7 17 7");
			add_location(polyline, file$l, 40, 4, 969);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$l, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowUpLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowUpLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowUpLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowUpLeft",
			options,
			id: create_fragment$l.name
		});
	}

	get class() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpRight.svelte generated by Svelte v3.22.3 */
const file$m = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUpRight.svelte";

function create_fragment$m(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "7");
			add_location(line, file$m, 39, 4, 927);
			attr_dev(polyline, "points", "7 7 17 7 17 17");
			add_location(polyline, file$m, 40, 4, 970);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$m, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowUpRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowUpRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowUpRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowUpRight",
			options,
			id: create_fragment$m.name
		});
	}

	get class() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUp.svelte generated by Svelte v3.22.3 */
const file$n = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconArrowUp.svelte";

function create_fragment$n(ctx) {
	let svg;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "5");
			add_location(line, file$n, 39, 4, 921);
			attr_dev(polyline, "points", "5 12 12 5 19 12");
			add_location(polyline, file$n, 40, 4, 965);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-arrow-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$n, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-arrow-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconArrowUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconArrowUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconArrowUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconArrowUp",
			options,
			id: create_fragment$n.name
		});
	}

	get class() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconArrowUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconArrowUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAtSign.svelte generated by Svelte v3.22.3 */
const file$o = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAtSign.svelte";

function create_fragment$o(ctx) {
	let svg;
	let circle;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "4");
			add_location(circle, file$o, 39, 4, 920);
			attr_dev(path, "d", "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94");
			add_location(path, file$o, 40, 4, 957);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-at-sign feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$o, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-at-sign feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAtSign> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAtSign", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAtSign extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAtSign",
			options,
			id: create_fragment$o.name
		});
	}

	get class() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAtSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAtSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAward.svelte generated by Svelte v3.22.3 */
const file$p = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconAward.svelte";

function create_fragment$p(ctx) {
	let svg;
	let circle;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "8");
			attr_dev(circle, "r", "7");
			add_location(circle, file$p, 39, 4, 918);
			attr_dev(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
			add_location(polyline, file$p, 40, 4, 954);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-award feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$p, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-award feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconAward> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconAward", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconAward extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconAward",
			options,
			id: create_fragment$p.name
		});
	}

	get class() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconAward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconAward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBarChart2.svelte generated by Svelte v3.22.3 */
const file$q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBarChart2.svelte";

function create_fragment$q(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "18");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$q, 39, 4, 924);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$q, 40, 4, 969);
			attr_dev(line2, "x1", "6");
			attr_dev(line2, "y1", "20");
			attr_dev(line2, "x2", "6");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$q, 41, 4, 1013);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bar-chart-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bar-chart-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBarChart2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBarChart2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBarChart2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBarChart2",
			options,
			id: create_fragment$q.name
		});
	}

	get class() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBarChart2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBarChart2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBarChart.svelte generated by Svelte v3.22.3 */
const file$r = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBarChart.svelte";

function create_fragment$r(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$r, 39, 4, 922);
			attr_dev(line1, "x1", "18");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$r, 40, 4, 967);
			attr_dev(line2, "x1", "6");
			attr_dev(line2, "y1", "20");
			attr_dev(line2, "x2", "6");
			attr_dev(line2, "y2", "16");
			add_location(line2, file$r, 41, 4, 1011);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bar-chart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$r, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bar-chart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBarChart> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBarChart", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBarChart extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBarChart",
			options,
			id: create_fragment$r.name
		});
	}

	get class() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBatteryCharging.svelte generated by Svelte v3.22.3 */
const file$s = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBatteryCharging.svelte";

function create_fragment$s(ctx) {
	let svg;
	let path;
	let line;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19");
			add_location(path, file$s, 39, 4, 929);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "13");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "11");
			add_location(line, file$s, 41, 4, 1040);
			attr_dev(polyline, "points", "11 6 7 12 13 12 9 18");
			add_location(polyline, file$s, 42, 4, 1085);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-battery-charging feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$s, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-battery-charging feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBatteryCharging> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBatteryCharging", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBatteryCharging extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBatteryCharging",
			options,
			id: create_fragment$s.name
		});
	}

	get class() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBatteryCharging>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBatteryCharging>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBattery.svelte generated by Svelte v3.22.3 */
const file$t = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBattery.svelte";

function create_fragment$t(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "6");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "12");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$t, 39, 4, 920);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "13");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "11");
			add_location(line, file$t, 40, 4, 982);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-battery feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$t, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-battery feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBattery> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBattery", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBattery extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBattery",
			options,
			id: create_fragment$t.name
		});
	}

	get class() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBattery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBattery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBellOff.svelte generated by Svelte v3.22.3 */
const file$u = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBellOff.svelte";

function create_fragment$u(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			line = svg_element("line");
			attr_dev(path0, "d", "M13.73 21a2 2 0 0 1-3.46 0");
			add_location(path0, file$u, 39, 4, 921);
			attr_dev(path1, "d", "M18.63 13A17.89 17.89 0 0 1 18 8");
			add_location(path1, file$u, 40, 4, 965);
			attr_dev(path2, "d", "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14");
			add_location(path2, file$u, 41, 4, 1015);
			attr_dev(path3, "d", "M18 8a6 6 0 0 0-9.33-5");
			add_location(path3, file$u, 42, 4, 1078);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$u, 43, 4, 1118);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bell-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$u, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, path3);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bell-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBellOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBellOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBellOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBellOff",
			options,
			id: create_fragment$u.name
		});
	}

	get class() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBellOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBellOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBell.svelte generated by Svelte v3.22.3 */
const file$v = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBell.svelte";

function create_fragment$v(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");
			add_location(path0, file$v, 39, 4, 917);
			attr_dev(path1, "d", "M13.73 21a2 2 0 0 1-3.46 0");
			add_location(path1, file$v, 40, 4, 978);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bell feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$v, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bell feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$v($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBell> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBell", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBell extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBell",
			options,
			id: create_fragment$v.name
		});
	}

	get class() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBluetooth.svelte generated by Svelte v3.22.3 */
const file$w = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBluetooth.svelte";

function create_fragment$w(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5");
			add_location(polyline, file$w, 39, 4, 922);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bluetooth feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$w, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bluetooth feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$w($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBluetooth> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBluetooth", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBluetooth extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBluetooth",
			options,
			id: create_fragment$w.name
		});
	}

	get class() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBluetooth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBluetooth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBold.svelte generated by Svelte v3.22.3 */
const file$x = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBold.svelte";

function create_fragment$x(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
			add_location(path0, file$x, 39, 4, 917);
			attr_dev(path1, "d", "M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
			add_location(path1, file$x, 40, 4, 972);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bold feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$x, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bold feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBold> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBold", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBold extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBold",
			options,
			id: create_fragment$x.name
		});
	}

	get class() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBold>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBold>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBookOpen.svelte generated by Svelte v3.22.3 */
const file$y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBookOpen.svelte";

function create_fragment$y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
			add_location(path0, file$y, 39, 4, 922);
			attr_dev(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
			add_location(path1, file$y, 40, 4, 980);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-book-open feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-book-open feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBookOpen> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBookOpen", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBookOpen extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBookOpen",
			options,
			id: create_fragment$y.name
		});
	}

	get class() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBookOpen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBookOpen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBook.svelte generated by Svelte v3.22.3 */
const file$z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBook.svelte";

function create_fragment$z(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
			add_location(path0, file$z, 39, 4, 917);
			attr_dev(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
			add_location(path1, file$z, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-book feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-book feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBook> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBook", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBook extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBook",
			options,
			id: create_fragment$z.name
		});
	}

	get class() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBookmark.svelte generated by Svelte v3.22.3 */
const file$A = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBookmark.svelte";

function create_fragment$A(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
			add_location(path, file$A, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-bookmark feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$A, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-bookmark feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBookmark> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBookmark", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBookmark extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBookmark",
			options,
			id: create_fragment$A.name
		});
	}

	get class() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBox.svelte generated by Svelte v3.22.3 */
const file$B = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBox.svelte";

function create_fragment$B(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2\n        2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$B, 39, 4, 916);
			attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline, file$B, 42, 4, 1071);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22.08");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$B, 43, 4, 1127);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-box feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$B, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-box feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBox> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBox", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBox",
			options,
			id: create_fragment$B.name
		});
	}

	get class() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBriefcase.svelte generated by Svelte v3.22.3 */
const file$C = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconBriefcase.svelte";

function create_fragment$C(ctx) {
	let svg;
	let rect;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$C, 39, 4, 922);
			attr_dev(path, "d", "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16");
			add_location(path, file$C, 40, 4, 984);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-briefcase feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$C, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-briefcase feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBriefcase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBriefcase", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconBriefcase extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBriefcase",
			options,
			id: create_fragment$C.name
		});
	}

	get class() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconBriefcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconBriefcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCalendar.svelte generated by Svelte v3.22.3 */
const file$D = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCalendar.svelte";

function create_fragment$D(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "4");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$D, 39, 4, 921);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$D, 40, 4, 983);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$D, 41, 4, 1026);
			attr_dev(line2, "x1", "3");
			attr_dev(line2, "y1", "10");
			attr_dev(line2, "x2", "21");
			attr_dev(line2, "y2", "10");
			add_location(line2, file$D, 42, 4, 1067);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-calendar feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$D, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-calendar feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCalendar> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCalendar", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCalendar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCalendar",
			options,
			id: create_fragment$D.name
		});
	}

	get class() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCameraOff.svelte generated by Svelte v3.22.3 */
const file$E = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCameraOff.svelte";

function create_fragment$E(ctx) {
	let svg;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$E, 39, 4, 923);
			attr_dev(path, "d", "M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0\n        1 1-5.56-5.56");
			add_location(path, file$E, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-camera-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$E, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-camera-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$E($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCameraOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCameraOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCameraOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCameraOff",
			options,
			id: create_fragment$E.name
		});
	}

	get class() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCameraOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCameraOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCamera.svelte generated by Svelte v3.22.3 */
const file$F = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCamera.svelte";

function create_fragment$F(ctx) {
	let svg;
	let path;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
			add_location(path, file$F, 39, 4, 919);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "13");
			attr_dev(circle, "r", "4");
			add_location(circle, file$F, 40, 4, 1018);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-camera feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$F, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-camera feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCamera> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCamera", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCamera extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCamera",
			options,
			id: create_fragment$F.name
		});
	}

	get class() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCast.svelte generated by Svelte v3.22.3 */
const file$G = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCast.svelte";

function create_fragment$G(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2\n        2v12a2 2 0 0 1-2 2h-6");
			add_location(path, file$G, 39, 4, 917);
			attr_dev(line, "x1", "2");
			attr_dev(line, "y1", "20");
			attr_dev(line, "x2", "2.01");
			attr_dev(line, "y2", "20");
			add_location(line, file$G, 42, 4, 1058);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cast feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$G, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cast feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$G($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCast> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCast", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCast extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCast",
			options,
			id: create_fragment$G.name
		});
	}

	get class() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheckCircle.svelte generated by Svelte v3.22.3 */
const file$H = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheckCircle.svelte";

function create_fragment$H(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
			add_location(path, file$H, 39, 4, 925);
			attr_dev(polyline, "points", "22 4 12 14.01 9 11.01");
			add_location(polyline, file$H, 40, 4, 977);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-check-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$H, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-check-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCheckCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCheckCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCheckCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCheckCircle",
			options,
			id: create_fragment$H.name
		});
	}

	get class() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCheckCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCheckCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheckSquare.svelte generated by Svelte v3.22.3 */
const file$I = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheckSquare.svelte";

function create_fragment$I(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "9 11 12 14 22 4");
			add_location(polyline, file$I, 39, 4, 925);
			attr_dev(path, "d", "M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11");
			add_location(path, file$I, 40, 4, 967);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-check-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$I, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-check-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCheckSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCheckSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCheckSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCheckSquare",
			options,
			id: create_fragment$I.name
		});
	}

	get class() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCheckSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCheckSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheck.svelte generated by Svelte v3.22.3 */
const file$J = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCheck.svelte";

function create_fragment$J(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "20 6 9 17 4 12");
			add_location(polyline, file$J, 39, 4, 918);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-check feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$J, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-check feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCheck> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCheck", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCheck extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCheck",
			options,
			id: create_fragment$J.name
		});
	}

	get class() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronDown.svelte generated by Svelte v3.22.3 */
const file$K = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronDown.svelte";

function create_fragment$K(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "6 9 12 15 18 9");
			add_location(polyline, file$K, 39, 4, 925);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$K, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronDown",
			options,
			id: create_fragment$K.name
		});
	}

	get class() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronLeft.svelte generated by Svelte v3.22.3 */
const file$L = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronLeft.svelte";

function create_fragment$L(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "15 18 9 12 15 6");
			add_location(polyline, file$L, 39, 4, 925);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$L, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$L($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronLeft",
			options,
			id: create_fragment$L.name
		});
	}

	get class() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronRight.svelte generated by Svelte v3.22.3 */
const file$M = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronRight.svelte";

function create_fragment$M(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "9 18 15 12 9 6");
			add_location(polyline, file$M, 39, 4, 926);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$M, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronRight",
			options,
			id: create_fragment$M.name
		});
	}

	get class() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronUp.svelte generated by Svelte v3.22.3 */
const file$N = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronUp.svelte";

function create_fragment$N(ctx) {
	let svg;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			attr_dev(polyline, "points", "18 15 12 9 6 15");
			add_location(polyline, file$N, 39, 4, 923);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevron-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$N, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevron-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronUp",
			options,
			id: create_fragment$N.name
		});
	}

	get class() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsDown.svelte generated by Svelte v3.22.3 */
const file$O = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsDown.svelte";

function create_fragment$O(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "7 13 12 18 17 13");
			add_location(polyline0, file$O, 39, 4, 926);
			attr_dev(polyline1, "points", "7 6 12 11 17 6");
			add_location(polyline1, file$O, 40, 4, 969);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$O, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$O($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronsDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronsDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronsDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$O, create_fragment$O, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronsDown",
			options,
			id: create_fragment$O.name
		});
	}

	get class() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsLeft.svelte generated by Svelte v3.22.3 */
const file$P = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsLeft.svelte";

function create_fragment$P(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "11 17 6 12 11 7");
			add_location(polyline0, file$P, 39, 4, 926);
			attr_dev(polyline1, "points", "18 17 13 12 18 7");
			add_location(polyline1, file$P, 40, 4, 968);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$P, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronsLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronsLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronsLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$P, create_fragment$P, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronsLeft",
			options,
			id: create_fragment$P.name
		});
	}

	get class() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsRight.svelte generated by Svelte v3.22.3 */
const file$Q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsRight.svelte";

function create_fragment$Q(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "13 17 18 12 13 7");
			add_location(polyline0, file$Q, 39, 4, 927);
			attr_dev(polyline1, "points", "6 17 11 12 6 7");
			add_location(polyline1, file$Q, 40, 4, 970);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$Q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronsRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronsRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronsRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronsRight",
			options,
			id: create_fragment$Q.name
		});
	}

	get class() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsUp.svelte generated by Svelte v3.22.3 */
const file$R = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChevronsUp.svelte";

function create_fragment$R(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "17 11 12 6 7 11");
			add_location(polyline0, file$R, 39, 4, 924);
			attr_dev(polyline1, "points", "17 18 12 13 7 18");
			add_location(polyline1, file$R, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chevrons-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$R, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chevrons-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChevronsUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChevronsUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChevronsUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$R, create_fragment$R, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChevronsUp",
			options,
			id: create_fragment$R.name
		});
	}

	get class() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChevronsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChevronsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChrome.svelte generated by Svelte v3.22.3 */
const file$S = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconChrome.svelte";

function create_fragment$S(ctx) {
	let svg;
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$S, 39, 4, 919);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "4");
			add_location(circle1, file$S, 40, 4, 957);
			attr_dev(line0, "x1", "21.17");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "8");
			add_location(line0, file$S, 41, 4, 994);
			attr_dev(line1, "x1", "3.95");
			attr_dev(line1, "y1", "6.06");
			attr_dev(line1, "x2", "8.54");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$S, 42, 4, 1040);
			attr_dev(line2, "x1", "10.88");
			attr_dev(line2, "y1", "21.94");
			attr_dev(line2, "x2", "15.46");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$S, 43, 4, 1091);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-chrome feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$S, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-chrome feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$S($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconChrome> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconChrome", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconChrome extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconChrome",
			options,
			id: create_fragment$S.name
		});
	}

	get class() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconChrome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconChrome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCircle.svelte generated by Svelte v3.22.3 */
const file$T = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCircle.svelte";

function create_fragment$T(ctx) {
	let svg;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$T, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$T, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$T($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$T, create_fragment$T, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCircle",
			options,
			id: create_fragment$T.name
		});
	}

	get class() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconClipboard.svelte generated by Svelte v3.22.3 */
const file$U = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconClipboard.svelte";

function create_fragment$U(ctx) {
	let svg;
	let path;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			attr_dev(path, "d", "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2");
			add_location(path, file$U, 39, 4, 922);
			attr_dev(rect, "x", "8");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "8");
			attr_dev(rect, "height", "4");
			attr_dev(rect, "rx", "1");
			attr_dev(rect, "ry", "1");
			add_location(rect, file$U, 40, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-clipboard feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$U, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, rect);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-clipboard feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$U($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconClipboard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconClipboard", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconClipboard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$U, create_fragment$U, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconClipboard",
			options,
			id: create_fragment$U.name
		});
	}

	get class() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconClipboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconClipboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconClock.svelte generated by Svelte v3.22.3 */
const file$V = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconClock.svelte";

function create_fragment$V(ctx) {
	let svg;
	let circle;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$V, 39, 4, 918);
			attr_dev(polyline, "points", "12 6 12 12 16 14");
			add_location(polyline, file$V, 40, 4, 956);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-clock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$V, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-clock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$V($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconClock> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconClock", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconClock extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconClock",
			options,
			id: create_fragment$V.name
		});
	}

	get class() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconClock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconClock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudDrizzle.svelte generated by Svelte v3.22.3 */
const file$W = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudDrizzle.svelte";

function create_fragment$W(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			path = svg_element("path");
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "19");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$W, 39, 4, 926);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "13");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$W, 40, 4, 969);
			attr_dev(line2, "x1", "16");
			attr_dev(line2, "y1", "19");
			attr_dev(line2, "x2", "16");
			attr_dev(line2, "y2", "21");
			add_location(line2, file$W, 41, 4, 1012);
			attr_dev(line3, "x1", "16");
			attr_dev(line3, "y1", "13");
			attr_dev(line3, "x2", "16");
			attr_dev(line3, "y2", "15");
			add_location(line3, file$W, 42, 4, 1057);
			attr_dev(line4, "x1", "12");
			attr_dev(line4, "y1", "21");
			attr_dev(line4, "x2", "12");
			attr_dev(line4, "y2", "23");
			add_location(line4, file$W, 43, 4, 1102);
			attr_dev(line5, "x1", "12");
			attr_dev(line5, "y1", "15");
			attr_dev(line5, "x2", "12");
			attr_dev(line5, "y2", "17");
			add_location(line5, file$W, 44, 4, 1147);
			attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
			add_location(path, file$W, 45, 4, 1192);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud-drizzle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$W, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-drizzle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloudDrizzle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloudDrizzle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloudDrizzle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloudDrizzle",
			options,
			id: create_fragment$W.name
		});
	}

	get class() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloudDrizzle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloudDrizzle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudLightning.svelte generated by Svelte v3.22.3 */
const file$X = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudLightning.svelte";

function create_fragment$X(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9");
			add_location(path, file$X, 39, 4, 928);
			attr_dev(polyline, "points", "13 11 9 17 15 17 11 23");
			add_location(polyline, file$X, 40, 4, 993);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud-lightning feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$X, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-lightning feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloudLightning> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloudLightning", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloudLightning extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloudLightning",
			options,
			id: create_fragment$X.name
		});
	}

	get class() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloudLightning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloudLightning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudOff.svelte generated by Svelte v3.22.3 */
const file$Y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudOff.svelte";

function create_fragment$Y(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3");
			add_location(path, file$Y, 39, 4, 922);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$Y, 41, 4, 1037);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$Y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloudOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloudOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloudOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloudOff",
			options,
			id: create_fragment$Y.name
		});
	}

	get class() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloudOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloudOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudRain.svelte generated by Svelte v3.22.3 */
const file$Z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudRain.svelte";

function create_fragment$Z(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			path = svg_element("path");
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "13");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$Z, 39, 4, 923);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "13");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$Z, 40, 4, 968);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "15");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$Z, 41, 4, 1011);
			attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
			add_location(path, file$Z, 42, 4, 1056);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud-rain feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$Z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-rain feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloudRain> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloudRain", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloudRain extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloudRain",
			options,
			id: create_fragment$Z.name
		});
	}

	get class() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloudRain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloudRain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudSnow.svelte generated by Svelte v3.22.3 */
const file$_ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloudSnow.svelte";

function create_fragment$_(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			attr_dev(path, "d", "M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25");
			add_location(path, file$_, 39, 4, 923);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "16");
			attr_dev(line0, "x2", "8.01");
			attr_dev(line0, "y2", "16");
			add_location(line0, file$_, 40, 4, 989);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "8.01");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$_, 41, 4, 1035);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "12.01");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$_, 42, 4, 1081);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "22");
			attr_dev(line3, "x2", "12.01");
			attr_dev(line3, "y2", "22");
			add_location(line3, file$_, 43, 4, 1129);
			attr_dev(line4, "x1", "16");
			attr_dev(line4, "y1", "16");
			attr_dev(line4, "x2", "16.01");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$_, 44, 4, 1177);
			attr_dev(line5, "x1", "16");
			attr_dev(line5, "y1", "20");
			attr_dev(line5, "x2", "16.01");
			attr_dev(line5, "y2", "20");
			add_location(line5, file$_, 45, 4, 1225);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud-snow feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$_, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud-snow feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloudSnow> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloudSnow", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloudSnow extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloudSnow",
			options,
			id: create_fragment$_.name
		});
	}

	get class() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloudSnow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloudSnow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloud.svelte generated by Svelte v3.22.3 */
const file$$ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCloud.svelte";

function create_fragment$$(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z");
			add_location(path, file$$, 39, 4, 918);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$$, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$$($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCloud> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCloud", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCloud extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCloud",
			options,
			id: create_fragment$$.name
		});
	}

	get class() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCode.svelte generated by Svelte v3.22.3 */
const file$10 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCode.svelte";

function create_fragment$10(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "16 18 22 12 16 6");
			add_location(polyline0, file$10, 39, 4, 917);
			attr_dev(polyline1, "points", "8 6 2 12 8 18");
			add_location(polyline1, file$10, 40, 4, 960);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-code feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$10, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-code feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCode> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCode", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCode extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCode",
			options,
			id: create_fragment$10.name
		});
	}

	get class() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCodepen.svelte generated by Svelte v3.22.3 */
const file$11 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCodepen.svelte";

function create_fragment$11(ctx) {
	let svg;
	let polygon;
	let line0;
	let polyline0;
	let polyline1;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line1 = svg_element("line");
			attr_dev(polygon, "points", "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2");
			add_location(polygon, file$11, 39, 4, 920);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "22");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "15.5");
			add_location(line0, file$11, 40, 4, 989);
			attr_dev(polyline0, "points", "22 8.5 12 15.5 2 8.5");
			add_location(polyline0, file$11, 41, 4, 1036);
			attr_dev(polyline1, "points", "2 15.5 12 8.5 22 15.5");
			add_location(polyline1, file$11, 42, 4, 1083);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "8.5");
			add_location(line1, file$11, 43, 4, 1131);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-codepen feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$11, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line0);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-codepen feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$11($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCodepen> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCodepen", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCodepen extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCodepen",
			options,
			id: create_fragment$11.name
		});
	}

	get class() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCodepen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCodepen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCodesandbox.svelte generated by Svelte v3.22.3 */
const file$12 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCodesandbox.svelte";

function create_fragment$12(ctx) {
	let svg;
	let path;
	let polyline0;
	let polyline1;
	let polyline2;
	let polyline3;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			polyline3 = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2\n        2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$12, 39, 4, 924);
			attr_dev(polyline0, "points", "7.5 4.21 12 6.81 16.5 4.21");
			add_location(polyline0, file$12, 42, 4, 1079);
			attr_dev(polyline1, "points", "7.5 19.79 7.5 14.6 3 12");
			add_location(polyline1, file$12, 43, 4, 1132);
			attr_dev(polyline2, "points", "21 12 16.5 14.6 16.5 19.79");
			add_location(polyline2, file$12, 44, 4, 1182);
			attr_dev(polyline3, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline3, file$12, 45, 4, 1235);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22.08");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$12, 46, 4, 1291);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-codesandbox feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$12, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, polyline2);
			append_dev(svg, polyline3);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-codesandbox feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$12($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCodesandbox> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCodesandbox", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCodesandbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCodesandbox",
			options,
			id: create_fragment$12.name
		});
	}

	get class() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCodesandbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCodesandbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCoffee.svelte generated by Svelte v3.22.3 */
const file$13 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCoffee.svelte";

function create_fragment$13(ctx) {
	let svg;
	let path0;
	let path1;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(path0, "d", "M18 8h1a4 4 0 0 1 0 8h-1");
			add_location(path0, file$13, 39, 4, 919);
			attr_dev(path1, "d", "M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z");
			add_location(path1, file$13, 40, 4, 961);
			attr_dev(line0, "x1", "6");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$13, 41, 4, 1021);
			attr_dev(line1, "x1", "10");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$13, 42, 4, 1062);
			attr_dev(line2, "x1", "14");
			attr_dev(line2, "y1", "1");
			attr_dev(line2, "x2", "14");
			attr_dev(line2, "y2", "4");
			add_location(line2, file$13, 43, 4, 1105);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-coffee feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$13, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-coffee feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCoffee> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCoffee", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCoffee extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCoffee",
			options,
			id: create_fragment$13.name
		});
	}

	get class() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCoffee>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCoffee>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconColumns.svelte generated by Svelte v3.22.3 */
const file$14 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconColumns.svelte";

function create_fragment$14(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18");
			add_location(path, file$14, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-columns feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$14, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-columns feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$14($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconColumns> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconColumns", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconColumns extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$14, create_fragment$14, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconColumns",
			options,
			id: create_fragment$14.name
		});
	}

	get class() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCommand.svelte generated by Svelte v3.22.3 */
const file$15 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCommand.svelte";

function create_fragment$15(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0\n        0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0\n        0-3-3z");
			add_location(path, file$15, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-command feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$15, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-command feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCommand> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCommand", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCommand extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$15, create_fragment$15, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCommand",
			options,
			id: create_fragment$15.name
		});
	}

	get class() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCommand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCommand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCompass.svelte generated by Svelte v3.22.3 */
const file$16 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCompass.svelte";

function create_fragment$16(ctx) {
	let svg;
	let circle;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polygon = svg_element("polygon");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$16, 39, 4, 920);
			attr_dev(polygon, "points", "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76");
			add_location(polygon, file$16, 40, 4, 958);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-compass feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$16, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-compass feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCompass> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCompass", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCompass extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$16, create_fragment$16, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCompass",
			options,
			id: create_fragment$16.name
		});
	}

	get class() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCompass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCompass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCopy.svelte generated by Svelte v3.22.3 */
const file$17 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCopy.svelte";

function create_fragment$17(ctx) {
	let svg;
	let rect;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr_dev(rect, "x", "9");
			attr_dev(rect, "y", "9");
			attr_dev(rect, "width", "13");
			attr_dev(rect, "height", "13");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$17, 39, 4, 917);
			attr_dev(path, "d", "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1");
			add_location(path, file$17, 40, 4, 979);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-copy feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$17, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-copy feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCopy> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCopy", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCopy extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$17, create_fragment$17, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCopy",
			options,
			id: create_fragment$17.name
		});
	}

	get class() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCopy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCopy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerDownLeft.svelte generated by Svelte v3.22.3 */
const file$18 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerDownLeft.svelte";

function create_fragment$18(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "9 10 4 15 9 20");
			add_location(polyline, file$18, 39, 4, 929);
			attr_dev(path, "d", "M20 4v7a4 4 0 0 1-4 4H4");
			add_location(path, file$18, 40, 4, 970);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-down-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$18, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-down-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerDownLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerDownLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerDownLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerDownLeft",
			options,
			id: create_fragment$18.name
		});
	}

	get class() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerDownLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerDownLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerDownRight.svelte generated by Svelte v3.22.3 */
const file$19 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerDownRight.svelte";

function create_fragment$19(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "15 10 20 15 15 20");
			add_location(polyline, file$19, 39, 4, 930);
			attr_dev(path, "d", "M4 4v7a4 4 0 0 0 4 4h12");
			add_location(path, file$19, 40, 4, 974);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-down-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$19, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-down-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerDownRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerDownRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerDownRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerDownRight",
			options,
			id: create_fragment$19.name
		});
	}

	get class() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerDownRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerDownRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerLeftDown.svelte generated by Svelte v3.22.3 */
const file$1a = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerLeftDown.svelte";

function create_fragment$1a(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "14 15 9 20 4 15");
			add_location(polyline, file$1a, 39, 4, 929);
			attr_dev(path, "d", "M20 4h-7a4 4 0 0 0-4 4v12");
			add_location(path, file$1a, 40, 4, 971);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-left-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1a, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-left-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerLeftDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerLeftDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerLeftDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerLeftDown",
			options,
			id: create_fragment$1a.name
		});
	}

	get class() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerLeftDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerLeftDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerLeftUp.svelte generated by Svelte v3.22.3 */
const file$1b = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerLeftUp.svelte";

function create_fragment$1b(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "14 9 9 4 4 9");
			add_location(polyline, file$1b, 39, 4, 927);
			attr_dev(path, "d", "M20 20h-7a4 4 0 0 1-4-4V4");
			add_location(path, file$1b, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-left-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1b, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-left-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1b($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerLeftUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerLeftUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerLeftUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerLeftUp",
			options,
			id: create_fragment$1b.name
		});
	}

	get class() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerLeftUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerLeftUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerRightDown.svelte generated by Svelte v3.22.3 */
const file$1c = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerRightDown.svelte";

function create_fragment$1c(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "10 15 15 20 20 15");
			add_location(polyline, file$1c, 39, 4, 930);
			attr_dev(path, "d", "M4 4h7a4 4 0 0 1 4 4v12");
			add_location(path, file$1c, 40, 4, 974);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-right-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1c, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-right-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1c($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerRightDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerRightDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerRightDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerRightDown",
			options,
			id: create_fragment$1c.name
		});
	}

	get class() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerRightDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerRightDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerRightUp.svelte generated by Svelte v3.22.3 */
const file$1d = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerRightUp.svelte";

function create_fragment$1d(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "10 9 15 4 20 9");
			add_location(polyline, file$1d, 39, 4, 928);
			attr_dev(path, "d", "M4 20h7a4 4 0 0 0 4-4V4");
			add_location(path, file$1d, 40, 4, 969);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-right-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1d, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-right-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1d($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerRightUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerRightUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerRightUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerRightUp",
			options,
			id: create_fragment$1d.name
		});
	}

	get class() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerRightUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerRightUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerUpLeft.svelte generated by Svelte v3.22.3 */
const file$1e = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerUpLeft.svelte";

function create_fragment$1e(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "9 14 4 9 9 4");
			add_location(polyline, file$1e, 39, 4, 927);
			attr_dev(path, "d", "M20 20v-7a4 4 0 0 0-4-4H4");
			add_location(path, file$1e, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-up-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1e, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-up-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1e($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerUpLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerUpLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerUpLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerUpLeft",
			options,
			id: create_fragment$1e.name
		});
	}

	get class() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerUpLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerUpLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerUpRight.svelte generated by Svelte v3.22.3 */
const file$1f = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCornerUpRight.svelte";

function create_fragment$1f(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "15 14 20 9 15 4");
			add_location(polyline, file$1f, 39, 4, 928);
			attr_dev(path, "d", "M4 20v-7a4 4 0 0 1 4-4h12");
			add_location(path, file$1f, 40, 4, 970);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-corner-up-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1f, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-corner-up-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1f($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCornerUpRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCornerUpRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCornerUpRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCornerUpRight",
			options,
			id: create_fragment$1f.name
		});
	}

	get class() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCornerUpRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCornerUpRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCpu.svelte generated by Svelte v3.22.3 */
const file$1g = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCpu.svelte";

function create_fragment$1g(ctx) {
	let svg;
	let rect0;
	let rect1;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			attr_dev(rect0, "x", "4");
			attr_dev(rect0, "y", "4");
			attr_dev(rect0, "width", "16");
			attr_dev(rect0, "height", "16");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$1g, 39, 4, 916);
			attr_dev(rect1, "x", "9");
			attr_dev(rect1, "y", "9");
			attr_dev(rect1, "width", "6");
			attr_dev(rect1, "height", "6");
			add_location(rect1, file$1g, 40, 4, 978);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$1g, 41, 4, 1024);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$1g, 42, 4, 1065);
			attr_dev(line2, "x1", "9");
			attr_dev(line2, "y1", "20");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$1g, 43, 4, 1108);
			attr_dev(line3, "x1", "15");
			attr_dev(line3, "y1", "20");
			attr_dev(line3, "x2", "15");
			attr_dev(line3, "y2", "23");
			add_location(line3, file$1g, 44, 4, 1151);
			attr_dev(line4, "x1", "20");
			attr_dev(line4, "y1", "9");
			attr_dev(line4, "x2", "23");
			attr_dev(line4, "y2", "9");
			add_location(line4, file$1g, 45, 4, 1196);
			attr_dev(line5, "x1", "20");
			attr_dev(line5, "y1", "14");
			attr_dev(line5, "x2", "23");
			attr_dev(line5, "y2", "14");
			add_location(line5, file$1g, 46, 4, 1239);
			attr_dev(line6, "x1", "1");
			attr_dev(line6, "y1", "9");
			attr_dev(line6, "x2", "4");
			attr_dev(line6, "y2", "9");
			add_location(line6, file$1g, 47, 4, 1284);
			attr_dev(line7, "x1", "1");
			attr_dev(line7, "y1", "14");
			attr_dev(line7, "x2", "4");
			attr_dev(line7, "y2", "14");
			add_location(line7, file$1g, 48, 4, 1325);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-cpu feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1g, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect0);
			append_dev(svg, rect1);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, line6);
			append_dev(svg, line7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-cpu feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1g($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCpu> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCpu", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCpu extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCpu",
			options,
			id: create_fragment$1g.name
		});
	}

	get class() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCpu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCpu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCreditCard.svelte generated by Svelte v3.22.3 */
const file$1h = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCreditCard.svelte";

function create_fragment$1h(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "4");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "16");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1h, 39, 4, 924);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "10");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "10");
			add_location(line, file$1h, 40, 4, 986);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-credit-card feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1h, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-credit-card feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1h($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCreditCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCreditCard", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCreditCard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCreditCard",
			options,
			id: create_fragment$1h.name
		});
	}

	get class() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCreditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCreditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCrop.svelte generated by Svelte v3.22.3 */
const file$1i = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCrop.svelte";

function create_fragment$1i(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M6.13 1L6 16a2 2 0 0 0 2 2h15");
			add_location(path0, file$1i, 39, 4, 917);
			attr_dev(path1, "d", "M1 6.13L16 6a2 2 0 0 1 2 2v15");
			add_location(path1, file$1i, 40, 4, 964);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-crop feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1i, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-crop feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1i($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCrop> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCrop", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCrop extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCrop",
			options,
			id: create_fragment$1i.name
		});
	}

	get class() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCrosshair.svelte generated by Svelte v3.22.3 */
const file$1j = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconCrosshair.svelte";

function create_fragment$1j(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1j, 39, 4, 922);
			attr_dev(line0, "x1", "22");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "18");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$1j, 40, 4, 960);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "2");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$1j, 41, 4, 1005);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "6");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "2");
			add_location(line2, file$1j, 42, 4, 1048);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "22");
			attr_dev(line3, "x2", "12");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$1j, 43, 4, 1091);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-crosshair feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1j, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-crosshair feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1j($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconCrosshair> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconCrosshair", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconCrosshair extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconCrosshair",
			options,
			id: create_fragment$1j.name
		});
	}

	get class() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconCrosshair>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconCrosshair>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDatabase.svelte generated by Svelte v3.22.3 */
const file$1k = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDatabase.svelte";

function create_fragment$1k(ctx) {
	let svg;
	let ellipse;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(ellipse, "cx", "12");
			attr_dev(ellipse, "cy", "5");
			attr_dev(ellipse, "rx", "9");
			attr_dev(ellipse, "ry", "3");
			add_location(ellipse, file$1k, 39, 4, 921);
			attr_dev(path0, "d", "M21 12c0 1.66-4 3-9 3s-9-1.34-9-3");
			add_location(path0, file$1k, 40, 4, 966);
			attr_dev(path1, "d", "M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5");
			add_location(path1, file$1k, 41, 4, 1017);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-database feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1k, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, ellipse);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-database feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1k($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDatabase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDatabase", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDatabase extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDatabase",
			options,
			id: create_fragment$1k.name
		});
	}

	get class() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDatabase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDatabase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDelete.svelte generated by Svelte v3.22.3 */
const file$1l = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDelete.svelte";

function create_fragment$1l(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z");
			add_location(path, file$1l, 39, 4, 919);
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$1l, 40, 4, 987);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$1l, 41, 4, 1031);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-delete feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1l, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-delete feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1l($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDelete> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDelete", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDelete extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDelete",
			options,
			id: create_fragment$1l.name
		});
	}

	get class() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDisc.svelte generated by Svelte v3.22.3 */
const file$1m = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDisc.svelte";

function create_fragment$1m(ctx) {
	let svg;
	let circle0;
	let circle1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$1m, 39, 4, 917);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1m, 40, 4, 955);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-disc feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1m, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-disc feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1m($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDisc> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDisc", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDisc extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDisc",
			options,
			id: create_fragment$1m.name
		});
	}

	get class() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDisc>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDisc>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDollarSign.svelte generated by Svelte v3.22.3 */
const file$1n = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDollarSign.svelte";

function create_fragment$1n(ctx) {
	let svg;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "23");
			add_location(line, file$1n, 39, 4, 924);
			attr_dev(path, "d", "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6");
			add_location(path, file$1n, 40, 4, 968);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-dollar-sign feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1n, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-dollar-sign feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1n($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDollarSign> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDollarSign", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDollarSign extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDollarSign",
			options,
			id: create_fragment$1n.name
		});
	}

	get class() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDollarSign>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDollarSign>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDownloadCloud.svelte generated by Svelte v3.22.3 */
const file$1o = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDownloadCloud.svelte";

function create_fragment$1o(ctx) {
	let svg;
	let polyline;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(polyline, "points", "8 17 12 21 16 17");
			add_location(polyline, file$1o, 39, 4, 927);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "21");
			add_location(line, file$1o, 40, 4, 970);
			attr_dev(path, "d", "M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29");
			add_location(path, file$1o, 41, 4, 1015);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-download-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1o, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-download-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1o($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDownloadCloud> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDownloadCloud", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDownloadCloud extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDownloadCloud",
			options,
			id: create_fragment$1o.name
		});
	}

	get class() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDownloadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDownloadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDownload.svelte generated by Svelte v3.22.3 */
const file$1p = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDownload.svelte";

function create_fragment$1p(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
			add_location(path, file$1p, 39, 4, 921);
			attr_dev(polyline, "points", "7 10 12 15 17 10");
			add_location(polyline, file$1p, 40, 4, 980);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "15");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "3");
			add_location(line, file$1p, 41, 4, 1023);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-download feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1p, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-download feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1p($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDownload> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDownload", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDownload extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDownload",
			options,
			id: create_fragment$1p.name
		});
	}

	get class() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDownload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDownload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDroplet.svelte generated by Svelte v3.22.3 */
const file$1q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconDroplet.svelte";

function create_fragment$1q(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z");
			add_location(path, file$1q, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-droplet feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-droplet feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconDroplet> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconDroplet", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconDroplet extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconDroplet",
			options,
			id: create_fragment$1q.name
		});
	}

	get class() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconDroplet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconDroplet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit2.svelte generated by Svelte v3.22.3 */
const file$1r = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit2.svelte";

function create_fragment$1r(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
			add_location(path, file$1r, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-edit-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1r, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-edit-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1r($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconEdit2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconEdit2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconEdit2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconEdit2",
			options,
			id: create_fragment$1r.name
		});
	}

	get class() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconEdit2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconEdit2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit3.svelte generated by Svelte v3.22.3 */
const file$1s = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit3.svelte";

function create_fragment$1s(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M12 20h9");
			add_location(path0, file$1s, 39, 4, 919);
			attr_dev(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
			add_location(path1, file$1s, 40, 4, 945);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-edit-3 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1s, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-edit-3 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1s($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconEdit3> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconEdit3", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconEdit3 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconEdit3",
			options,
			id: create_fragment$1s.name
		});
	}

	get class() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconEdit3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconEdit3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit.svelte generated by Svelte v3.22.3 */
const file$1t = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEdit.svelte";

function create_fragment$1t(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
			add_location(path0, file$1t, 39, 4, 917);
			attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
			add_location(path1, file$1t, 40, 4, 993);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-edit feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1t, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-edit feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1t($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconEdit> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconEdit", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconEdit extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconEdit",
			options,
			id: create_fragment$1t.name
		});
	}

	get class() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconExternalLink.svelte generated by Svelte v3.22.3 */
const file$1u = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconExternalLink.svelte";

function create_fragment$1u(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6");
			add_location(path, file$1u, 39, 4, 926);
			attr_dev(polyline, "points", "15 3 21 3 21 9");
			add_location(polyline, file$1u, 40, 4, 1000);
			attr_dev(line, "x1", "10");
			attr_dev(line, "y1", "14");
			attr_dev(line, "x2", "21");
			attr_dev(line, "y2", "3");
			add_location(line, file$1u, 41, 4, 1041);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-external-link feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1u, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-external-link feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1u($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconExternalLink> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconExternalLink", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconExternalLink extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconExternalLink",
			options,
			id: create_fragment$1u.name
		});
	}

	get class() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconExternalLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconExternalLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEyeOff.svelte generated by Svelte v3.22.3 */
const file$1v = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEyeOff.svelte";

function create_fragment$1v(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9\n        4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1\n        1-4.24-4.24");
			add_location(path, file$1v, 39, 4, 920);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$1v, 43, 4, 1142);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-eye-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1v, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-eye-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1v($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconEyeOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconEyeOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconEyeOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconEyeOff",
			options,
			id: create_fragment$1v.name
		});
	}

	get class() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconEyeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconEyeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEye.svelte generated by Svelte v3.22.3 */
const file$1w = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconEye.svelte";

function create_fragment$1w(ctx) {
	let svg;
	let path;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
			add_location(path, file$1w, 39, 4, 916);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$1w, 40, 4, 978);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-eye feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1w, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-eye feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1w($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconEye> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconEye", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconEye extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconEye",
			options,
			id: create_fragment$1w.name
		});
	}

	get class() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFacebook.svelte generated by Svelte v3.22.3 */
const file$1x = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFacebook.svelte";

function create_fragment$1x(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z");
			add_location(path, file$1x, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-facebook feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1x, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-facebook feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1x($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFacebook> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFacebook", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFacebook extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFacebook",
			options,
			id: create_fragment$1x.name
		});
	}

	get class() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFacebook>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFacebook>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFastForward.svelte generated by Svelte v3.22.3 */
const file$1y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFastForward.svelte";

function create_fragment$1y(ctx) {
	let svg;
	let polygon0;
	let polygon1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon0 = svg_element("polygon");
			polygon1 = svg_element("polygon");
			attr_dev(polygon0, "points", "13 19 22 12 13 5 13 19");
			add_location(polygon0, file$1y, 39, 4, 925);
			attr_dev(polygon1, "points", "2 19 11 12 2 5 2 19");
			add_location(polygon1, file$1y, 40, 4, 973);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-fast-forward feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon0);
			append_dev(svg, polygon1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-fast-forward feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFastForward> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFastForward", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFastForward extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFastForward",
			options,
			id: create_fragment$1y.name
		});
	}

	get class() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFastForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFastForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFeather.svelte generated by Svelte v3.22.3 */
const file$1z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFeather.svelte";

function create_fragment$1z(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z");
			add_location(path, file$1z, 39, 4, 920);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "2");
			attr_dev(line0, "y2", "22");
			add_location(line0, file$1z, 40, 4, 985);
			attr_dev(line1, "x1", "17.5");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$1z, 41, 4, 1028);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-feather feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-feather feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFeather> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFeather", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFeather extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFeather",
			options,
			id: create_fragment$1z.name
		});
	}

	get class() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFeather>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFeather>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFigma.svelte generated by Svelte v3.22.3 */
const file$1A = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFigma.svelte";

function create_fragment$1A(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			attr_dev(path0, "d", "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z");
			add_location(path0, file$1A, 39, 4, 918);
			attr_dev(path1, "d", "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z");
			add_location(path1, file$1A, 40, 4, 992);
			attr_dev(path2, "d", "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z");
			add_location(path2, file$1A, 41, 4, 1043);
			attr_dev(path3, "d", "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z");
			add_location(path3, file$1A, 42, 4, 1106);
			attr_dev(path4, "d", "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z");
			add_location(path4, file$1A, 43, 4, 1178);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-figma feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1A, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, path3);
			append_dev(svg, path4);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-figma feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1A($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFigma> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFigma", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFigma extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFigma",
			options,
			id: create_fragment$1A.name
		});
	}

	get class() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFigma>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFigma>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFileMinus.svelte generated by Svelte v3.22.3 */
const file$1B = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFileMinus.svelte";

function create_fragment$1B(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$1B, 39, 4, 923);
			attr_dev(polyline, "points", "14 2 14 8 20 8");
			add_location(polyline, file$1B, 40, 4, 999);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "15");
			attr_dev(line, "x2", "15");
			attr_dev(line, "y2", "15");
			add_location(line, file$1B, 41, 4, 1040);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-file-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1B, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-file-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1B($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFileMinus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFileMinus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFileMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFileMinus",
			options,
			id: create_fragment$1B.name
		});
	}

	get class() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFileMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFileMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilePlus.svelte generated by Svelte v3.22.3 */
const file$1C = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilePlus.svelte";

function create_fragment$1C(ctx) {
	let svg;
	let path;
	let polyline;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$1C, 39, 4, 922);
			attr_dev(polyline, "points", "14 2 14 8 20 8");
			add_location(polyline, file$1C, 40, 4, 998);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "18");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$1C, 41, 4, 1039);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$1C, 42, 4, 1084);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-file-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1C, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-file-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1C($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFilePlus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFilePlus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFilePlus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFilePlus",
			options,
			id: create_fragment$1C.name
		});
	}

	get class() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFilePlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFilePlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFileText.svelte generated by Svelte v3.22.3 */
const file$1D = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFileText.svelte";

function create_fragment$1D(ctx) {
	let svg;
	let path;
	let polyline0;
	let line0;
	let line1;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			polyline1 = svg_element("polyline");
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$1D, 39, 4, 922);
			attr_dev(polyline0, "points", "14 2 14 8 20 8");
			add_location(polyline0, file$1D, 40, 4, 998);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "13");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "13");
			add_location(line0, file$1D, 41, 4, 1039);
			attr_dev(line1, "x1", "16");
			attr_dev(line1, "y1", "17");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$1D, 42, 4, 1083);
			attr_dev(polyline1, "points", "10 9 9 9 8 9");
			add_location(polyline1, file$1D, 43, 4, 1127);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-file-text feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1D, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline0);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-file-text feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1D($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFileText> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFileText", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFileText extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFileText",
			options,
			id: create_fragment$1D.name
		});
	}

	get class() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFile.svelte generated by Svelte v3.22.3 */
const file$1E = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFile.svelte";

function create_fragment$1E(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z");
			add_location(path, file$1E, 39, 4, 917);
			attr_dev(polyline, "points", "13 2 13 9 20 9");
			add_location(polyline, file$1E, 40, 4, 993);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-file feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1E, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-file feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1E($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFile", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFile extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFile",
			options,
			id: create_fragment$1E.name
		});
	}

	get class() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilm.svelte generated by Svelte v3.22.3 */
const file$1F = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilm.svelte";

function create_fragment$1F(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2.18");
			attr_dev(rect, "ry", "2.18");
			add_location(rect, file$1F, 39, 4, 917);
			attr_dev(line0, "x1", "7");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "22");
			add_location(line0, file$1F, 40, 4, 985);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "17");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$1F, 41, 4, 1027);
			attr_dev(line2, "x1", "2");
			attr_dev(line2, "y1", "12");
			attr_dev(line2, "x2", "22");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$1F, 42, 4, 1071);
			attr_dev(line3, "x1", "2");
			attr_dev(line3, "y1", "7");
			attr_dev(line3, "x2", "7");
			attr_dev(line3, "y2", "7");
			add_location(line3, file$1F, 43, 4, 1115);
			attr_dev(line4, "x1", "2");
			attr_dev(line4, "y1", "17");
			attr_dev(line4, "x2", "7");
			attr_dev(line4, "y2", "17");
			add_location(line4, file$1F, 44, 4, 1156);
			attr_dev(line5, "x1", "17");
			attr_dev(line5, "y1", "17");
			attr_dev(line5, "x2", "22");
			attr_dev(line5, "y2", "17");
			add_location(line5, file$1F, 45, 4, 1199);
			attr_dev(line6, "x1", "17");
			attr_dev(line6, "y1", "7");
			attr_dev(line6, "x2", "22");
			attr_dev(line6, "y2", "7");
			add_location(line6, file$1F, 46, 4, 1244);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-film feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1F, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, line6);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-film feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1F($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFilm> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFilm", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFilm extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFilm",
			options,
			id: create_fragment$1F.name
		});
	}

	get class() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFilm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFilm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilter.svelte generated by Svelte v3.22.3 */
const file$1G = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFilter.svelte";

function create_fragment$1G(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
			add_location(polygon, file$1G, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-filter feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1G, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-filter feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1G($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFilter> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFilter", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFilter extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFilter",
			options,
			id: create_fragment$1G.name
		});
	}

	get class() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFlag.svelte generated by Svelte v3.22.3 */
const file$1H = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFlag.svelte";

function create_fragment$1H(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z");
			add_location(path, file$1H, 39, 4, 917);
			attr_dev(line, "x1", "4");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "4");
			attr_dev(line, "y2", "15");
			add_location(line, file$1H, 40, 4, 992);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-flag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1H, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-flag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1H($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFlag> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFlag", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFlag extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFlag",
			options,
			id: create_fragment$1H.name
		});
	}

	get class() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFlag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFlag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolderMinus.svelte generated by Svelte v3.22.3 */
const file$1I = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolderMinus.svelte";

function create_fragment$1I(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$1I, 39, 4, 925);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "14");
			attr_dev(line, "x2", "15");
			attr_dev(line, "y2", "14");
			add_location(line, file$1I, 40, 4, 1018);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-folder-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1I, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-folder-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1I($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFolderMinus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFolderMinus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFolderMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFolderMinus",
			options,
			id: create_fragment$1I.name
		});
	}

	get class() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFolderMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFolderMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolderPlus.svelte generated by Svelte v3.22.3 */
const file$1J = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolderPlus.svelte";

function create_fragment$1J(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$1J, 39, 4, 924);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "11");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "17");
			add_location(line0, file$1J, 40, 4, 1017);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "14");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$1J, 41, 4, 1062);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-folder-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1J, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-folder-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1J($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFolderPlus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFolderPlus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFolderPlus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFolderPlus",
			options,
			id: create_fragment$1J.name
		});
	}

	get class() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFolderPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFolderPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolder.svelte generated by Svelte v3.22.3 */
const file$1K = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFolder.svelte";

function create_fragment$1K(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$1K, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-folder feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1K, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-folder feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1K($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFolder> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFolder", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFolder extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFolder",
			options,
			id: create_fragment$1K.name
		});
	}

	get class() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFolder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFolder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFramer.svelte generated by Svelte v3.22.3 */
const file$1L = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFramer.svelte";

function create_fragment$1L(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7");
			add_location(path, file$1L, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-framer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1L, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-framer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1L($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFramer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFramer", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFramer extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFramer",
			options,
			id: create_fragment$1L.name
		});
	}

	get class() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFramer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFramer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFrown.svelte generated by Svelte v3.22.3 */
const file$1M = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconFrown.svelte";

function create_fragment$1M(ctx) {
	let svg;
	let circle;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1M, 39, 4, 918);
			attr_dev(path, "d", "M16 16s-1.5-2-4-2-4 2-4 2");
			add_location(path, file$1M, 40, 4, 956);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9.01");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$1M, 41, 4, 999);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$1M, 42, 4, 1043);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-frown feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1M, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-frown feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1M($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconFrown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconFrown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconFrown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconFrown",
			options,
			id: create_fragment$1M.name
		});
	}

	get class() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconFrown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconFrown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGift.svelte generated by Svelte v3.22.3 */
const file$1N = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGift.svelte";

function create_fragment$1N(ctx) {
	let svg;
	let polyline;
	let rect;
	let line;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			rect = svg_element("rect");
			line = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(polyline, "points", "20 12 20 22 4 22 4 12");
			add_location(polyline, file$1N, 39, 4, 917);
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "5");
			add_location(rect, file$1N, 40, 4, 965);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "7");
			add_location(line, file$1N, 41, 4, 1012);
			attr_dev(path0, "d", "M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z");
			add_location(path0, file$1N, 42, 4, 1056);
			attr_dev(path1, "d", "M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z");
			add_location(path1, file$1N, 43, 4, 1117);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-gift feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1N, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, rect);
			append_dev(svg, line);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-gift feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1N($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGift> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGift", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGift extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGift",
			options,
			id: create_fragment$1N.name
		});
	}

	get class() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGift>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGift>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitBranch.svelte generated by Svelte v3.22.3 */
const file$1O = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitBranch.svelte";

function create_fragment$1O(ctx) {
	let svg;
	let line;
	let circle0;
	let circle1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			attr_dev(line, "x1", "6");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "6");
			attr_dev(line, "y2", "15");
			add_location(line, file$1O, 39, 4, 923);
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$1O, 40, 4, 965);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1O, 41, 4, 1001);
			attr_dev(path, "d", "M18 9a9 9 0 0 1-9 9");
			add_location(path, file$1O, 42, 4, 1037);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-git-branch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1O, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-git-branch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1O($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGitBranch> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGitBranch", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGitBranch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGitBranch",
			options,
			id: create_fragment$1O.name
		});
	}

	get class() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGitBranch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGitBranch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitCommit.svelte generated by Svelte v3.22.3 */
const file$1P = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitCommit.svelte";

function create_fragment$1P(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "4");
			add_location(circle, file$1P, 39, 4, 923);
			attr_dev(line0, "x1", "1.05");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$1P, 40, 4, 960);
			attr_dev(line1, "x1", "17.01");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "22.96");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$1P, 41, 4, 1006);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-git-commit feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1P, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-git-commit feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1P($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGitCommit> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGitCommit", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGitCommit extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGitCommit",
			options,
			id: create_fragment$1P.name
		});
	}

	get class() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGitCommit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGitCommit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitMerge.svelte generated by Svelte v3.22.3 */
const file$1Q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitMerge.svelte";

function create_fragment$1Q(ctx) {
	let svg;
	let circle0;
	let circle1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$1Q, 39, 4, 922);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "6");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1Q, 40, 4, 959);
			attr_dev(path, "d", "M6 21V9a9 9 0 0 0 9 9");
			add_location(path, file$1Q, 41, 4, 994);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-git-merge feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1Q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-git-merge feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGitMerge> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGitMerge", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGitMerge extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGitMerge",
			options,
			id: create_fragment$1Q.name
		});
	}

	get class() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGitMerge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGitMerge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitPullRequest.svelte generated by Svelte v3.22.3 */
const file$1R = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitPullRequest.svelte";

function create_fragment$1R(ctx) {
	let svg;
	let circle0;
	let circle1;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$1R, 39, 4, 929);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "6");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1R, 40, 4, 966);
			attr_dev(path, "d", "M13 6h3a2 2 0 0 1 2 2v7");
			add_location(path, file$1R, 41, 4, 1001);
			attr_dev(line, "x1", "6");
			attr_dev(line, "y1", "9");
			attr_dev(line, "x2", "6");
			attr_dev(line, "y2", "21");
			add_location(line, file$1R, 42, 4, 1042);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-git-pull-request feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1R, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-git-pull-request feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1R($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGitPullRequest> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGitPullRequest", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGitPullRequest extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGitPullRequest",
			options,
			id: create_fragment$1R.name
		});
	}

	get class() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGitPullRequest>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGitPullRequest>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGithub.svelte generated by Svelte v3.22.3 */
const file$1S = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGithub.svelte";

function create_fragment$1S(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44\n        5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65\n        5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37\n        3.37 0 0 0 9 18.13V22");
			add_location(path, file$1S, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-github feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1S, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-github feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1S($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGithub> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGithub", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGithub extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGithub",
			options,
			id: create_fragment$1S.name
		});
	}

	get class() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGithub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGithub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitlab.svelte generated by Svelte v3.22.3 */
const file$1T = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGitlab.svelte";

function create_fragment$1T(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1\n        4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6\n        2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z");
			add_location(path, file$1T, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-gitlab feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1T, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-gitlab feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1T($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGitlab> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGitlab", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGitlab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGitlab",
			options,
			id: create_fragment$1T.name
		});
	}

	get class() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGitlab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGitlab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGlobe.svelte generated by Svelte v3.22.3 */
const file$1U = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGlobe.svelte";

function create_fragment$1U(ctx) {
	let svg;
	let circle;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1U, 39, 4, 918);
			attr_dev(line, "x1", "2");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "22");
			attr_dev(line, "y2", "12");
			add_location(line, file$1U, 40, 4, 956);
			attr_dev(path, "d", "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1\n        4-10z");
			add_location(path, file$1U, 41, 4, 1000);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-globe feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1U, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-globe feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1U($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGlobe> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGlobe", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGlobe extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGlobe",
			options,
			id: create_fragment$1U.name
		});
	}

	get class() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGlobe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGlobe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGrid.svelte generated by Svelte v3.22.3 */
const file$1V = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconGrid.svelte";

function create_fragment$1V(ctx) {
	let svg;
	let rect0;
	let rect1;
	let rect2;
	let rect3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			attr_dev(rect0, "x", "3");
			attr_dev(rect0, "y", "3");
			attr_dev(rect0, "width", "7");
			attr_dev(rect0, "height", "7");
			add_location(rect0, file$1V, 39, 4, 917);
			attr_dev(rect1, "x", "14");
			attr_dev(rect1, "y", "3");
			attr_dev(rect1, "width", "7");
			attr_dev(rect1, "height", "7");
			add_location(rect1, file$1V, 40, 4, 963);
			attr_dev(rect2, "x", "14");
			attr_dev(rect2, "y", "14");
			attr_dev(rect2, "width", "7");
			attr_dev(rect2, "height", "7");
			add_location(rect2, file$1V, 41, 4, 1010);
			attr_dev(rect3, "x", "3");
			attr_dev(rect3, "y", "14");
			attr_dev(rect3, "width", "7");
			attr_dev(rect3, "height", "7");
			add_location(rect3, file$1V, 42, 4, 1058);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-grid feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1V, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect0);
			append_dev(svg, rect1);
			append_dev(svg, rect2);
			append_dev(svg, rect3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-grid feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1V($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGrid> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconGrid", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconGrid extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconGrid",
			options,
			id: create_fragment$1V.name
		});
	}

	get class() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHardDrive.svelte generated by Svelte v3.22.3 */
const file$1W = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHardDrive.svelte";

function create_fragment$1W(ctx) {
	let svg;
	let line0;
	let path;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			path = svg_element("path");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "22");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "2");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$1W, 39, 4, 923);
			attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2\n        0 0 0-1.79 1.11z");
			add_location(path, file$1W, 40, 4, 967);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "6.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$1W, 43, 4, 1107);
			attr_dev(line2, "x1", "10");
			attr_dev(line2, "y1", "16");
			attr_dev(line2, "x2", "10.01");
			attr_dev(line2, "y2", "16");
			add_location(line2, file$1W, 44, 4, 1153);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-hard-drive feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1W, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, path);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-hard-drive feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1W($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHardDrive> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHardDrive", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHardDrive extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHardDrive",
			options,
			id: create_fragment$1W.name
		});
	}

	get class() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHardDrive>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHardDrive>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHash.svelte generated by Svelte v3.22.3 */
const file$1X = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHash.svelte";

function create_fragment$1X(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "20");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$1X, 39, 4, 917);
			attr_dev(line1, "x1", "4");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "20");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$1X, 40, 4, 959);
			attr_dev(line2, "x1", "10");
			attr_dev(line2, "y1", "3");
			attr_dev(line2, "x2", "8");
			attr_dev(line2, "y2", "21");
			add_location(line2, file$1X, 41, 4, 1003);
			attr_dev(line3, "x1", "16");
			attr_dev(line3, "y1", "3");
			attr_dev(line3, "x2", "14");
			attr_dev(line3, "y2", "21");
			add_location(line3, file$1X, 42, 4, 1046);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-hash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1X, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-hash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1X($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHash> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHash", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHash extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHash",
			options,
			id: create_fragment$1X.name
		});
	}

	get class() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHeadphones.svelte generated by Svelte v3.22.3 */
const file$1Y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHeadphones.svelte";

function create_fragment$1Y(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M3 18v-6a9 9 0 0 1 18 0v6");
			add_location(path0, file$1Y, 39, 4, 923);
			attr_dev(path1, "d", "M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0\n        2-2v-3a2 2 0 0 0-2-2H3z");
			add_location(path1, file$1Y, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-headphones feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1Y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-headphones feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHeadphones> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHeadphones", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHeadphones extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHeadphones",
			options,
			id: create_fragment$1Y.name
		});
	}

	get class() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHeadphones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHeadphones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHeart.svelte generated by Svelte v3.22.3 */
const file$1Z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHeart.svelte";

function create_fragment$1Z(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12\n        21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z");
			add_location(path, file$1Z, 39, 4, 918);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-heart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1Z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-heart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHeart> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHeart", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHeart extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHeart",
			options,
			id: create_fragment$1Z.name
		});
	}

	get class() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHeart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHeart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHelpCircle.svelte generated by Svelte v3.22.3 */
const file$1_ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHelpCircle.svelte";

function create_fragment$1_(ctx) {
	let svg;
	let circle;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1_, 39, 4, 924);
			attr_dev(path, "d", "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3");
			add_location(path, file$1_, 40, 4, 962);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "17");
			add_location(line, file$1_, 41, 4, 1016);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-help-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1_, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-help-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1_($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHelpCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHelpCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHelpCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHelpCircle",
			options,
			id: create_fragment$1_.name
		});
	}

	get class() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHelpCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHelpCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHexagon.svelte generated by Svelte v3.22.3 */
const file$1$ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHexagon.svelte";

function create_fragment$1$(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2\n        2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$1$, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-hexagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$1$, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-hexagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1$($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHexagon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHexagon", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHexagon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHexagon",
			options,
			id: create_fragment$1$.name
		});
	}

	get class() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHexagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHexagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHome.svelte generated by Svelte v3.22.3 */
const file$20 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconHome.svelte";

function create_fragment$20(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
			add_location(path, file$20, 39, 4, 917);
			attr_dev(polyline, "points", "9 22 9 12 15 12 15 22");
			add_location(polyline, file$20, 40, 4, 981);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-home feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$20, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-home feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$20.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$20($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconHome> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconHome", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconHome extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$20, create_fragment$20, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconHome",
			options,
			id: create_fragment$20.name
		});
	}

	get class() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconHome>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconHome>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconImage.svelte generated by Svelte v3.22.3 */
const file$21 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconImage.svelte";

function create_fragment$21(ctx) {
	let svg;
	let rect;
	let circle;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$21, 39, 4, 918);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "8.5");
			attr_dev(circle, "r", "1.5");
			add_location(circle, file$21, 40, 4, 980);
			attr_dev(polyline, "points", "21 15 16 10 5 21");
			add_location(polyline, file$21, 41, 4, 1021);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-image feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$21, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, circle);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-image feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$21.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$21($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconImage> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconImage", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconImage extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$21, create_fragment$21, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconImage",
			options,
			id: create_fragment$21.name
		});
	}

	get class() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInbox.svelte generated by Svelte v3.22.3 */
const file$22 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInbox.svelte";

function create_fragment$22(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "22 12 16 12 14 15 10 15 8 12 2 12");
			add_location(polyline, file$22, 39, 4, 918);
			attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2\n        0 0 0-1.79 1.11z");
			add_location(path, file$22, 40, 4, 978);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-inbox feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$22, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-inbox feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$22.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$22($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconInbox> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconInbox", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconInbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$22, create_fragment$22, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconInbox",
			options,
			id: create_fragment$22.name
		});
	}

	get class() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconInbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconInbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInfo.svelte generated by Svelte v3.22.3 */
const file$23 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInfo.svelte";

function create_fragment$23(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$23, 39, 4, 917);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "16");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$23, 40, 4, 955);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "8");
			add_location(line1, file$23, 41, 4, 1000);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-info feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$23, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-info feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$23.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$23($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconInfo> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconInfo", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconInfo extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$23, create_fragment$23, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconInfo",
			options,
			id: create_fragment$23.name
		});
	}

	get class() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInstagram.svelte generated by Svelte v3.22.3 */
const file$24 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconInstagram.svelte";

function create_fragment$24(ctx) {
	let svg;
	let rect;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "5");
			attr_dev(rect, "ry", "5");
			add_location(rect, file$24, 39, 4, 922);
			attr_dev(path, "d", "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z");
			add_location(path, file$24, 40, 4, 984);
			attr_dev(line, "x1", "17.5");
			attr_dev(line, "y1", "6.5");
			attr_dev(line, "x2", "17.51");
			attr_dev(line, "y2", "6.5");
			add_location(line, file$24, 41, 4, 1049);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-instagram feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$24, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-instagram feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$24.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$24($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconInstagram> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconInstagram", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconInstagram extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$24, create_fragment$24, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconInstagram",
			options,
			id: create_fragment$24.name
		});
	}

	get class() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconInstagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconInstagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconItalic.svelte generated by Svelte v3.22.3 */
const file$25 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconItalic.svelte";

function create_fragment$25(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "19");
			attr_dev(line0, "y1", "4");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$25, 39, 4, 919);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "5");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$25, 40, 4, 962);
			attr_dev(line2, "x1", "15");
			attr_dev(line2, "y1", "4");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "20");
			add_location(line2, file$25, 41, 4, 1006);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-italic feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$25, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-italic feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$25.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$25($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconItalic> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconItalic", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconItalic extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$25, create_fragment$25, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconItalic",
			options,
			id: create_fragment$25.name
		});
	}

	get class() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconItalic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconItalic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconKey.svelte generated by Svelte v3.22.3 */
const file$26 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconKey.svelte";

function create_fragment$26(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0\n        0l3 3L22 7l-3-3m-3.5 3.5L19 4");
			add_location(path, file$26, 39, 4, 916);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-key feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$26, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-key feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$26.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$26($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconKey> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconKey", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconKey extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$26, create_fragment$26, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconKey",
			options,
			id: create_fragment$26.name
		});
	}

	get class() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLayers.svelte generated by Svelte v3.22.3 */
const file$27 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLayers.svelte";

function create_fragment$27(ctx) {
	let svg;
	let polygon;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polygon, "points", "12 2 2 7 12 12 22 7 12 2");
			add_location(polygon, file$27, 39, 4, 919);
			attr_dev(polyline0, "points", "2 17 12 22 22 17");
			add_location(polyline0, file$27, 40, 4, 969);
			attr_dev(polyline1, "points", "2 12 12 17 22 12");
			add_location(polyline1, file$27, 41, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-layers feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$27, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-layers feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$27.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$27($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLayers> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLayers", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLayers extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$27, create_fragment$27, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLayers",
			options,
			id: create_fragment$27.name
		});
	}

	get class() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLayers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLayers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLayout.svelte generated by Svelte v3.22.3 */
const file$28 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLayout.svelte";

function create_fragment$28(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$28, 39, 4, 919);
			attr_dev(line0, "x1", "3");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$28, 40, 4, 981);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$28, 41, 4, 1023);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-layout feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$28, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-layout feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$28.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$28($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLayout> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLayout", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLayout extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$28, create_fragment$28, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLayout",
			options,
			id: create_fragment$28.name
		});
	}

	get class() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLifeBuoy.svelte generated by Svelte v3.22.3 */
const file$29 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLifeBuoy.svelte";

function create_fragment$29(ctx) {
	let svg;
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$29, 39, 4, 922);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "4");
			add_location(circle1, file$29, 40, 4, 960);
			attr_dev(line0, "x1", "4.93");
			attr_dev(line0, "y1", "4.93");
			attr_dev(line0, "x2", "9.17");
			attr_dev(line0, "y2", "9.17");
			add_location(line0, file$29, 41, 4, 997);
			attr_dev(line1, "x1", "14.83");
			attr_dev(line1, "y1", "14.83");
			attr_dev(line1, "x2", "19.07");
			attr_dev(line1, "y2", "19.07");
			add_location(line1, file$29, 42, 4, 1050);
			attr_dev(line2, "x1", "14.83");
			attr_dev(line2, "y1", "9.17");
			attr_dev(line2, "x2", "19.07");
			attr_dev(line2, "y2", "4.93");
			add_location(line2, file$29, 43, 4, 1107);
			attr_dev(line3, "x1", "14.83");
			attr_dev(line3, "y1", "9.17");
			attr_dev(line3, "x2", "18.36");
			attr_dev(line3, "y2", "5.64");
			add_location(line3, file$29, 44, 4, 1162);
			attr_dev(line4, "x1", "4.93");
			attr_dev(line4, "y1", "19.07");
			attr_dev(line4, "x2", "9.17");
			attr_dev(line4, "y2", "14.83");
			add_location(line4, file$29, 45, 4, 1217);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-life-buoy feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$29, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-life-buoy feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$29.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$29($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLifeBuoy> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLifeBuoy", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLifeBuoy extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$29, create_fragment$29, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLifeBuoy",
			options,
			id: create_fragment$29.name
		});
	}

	get class() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLifeBuoy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLifeBuoy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLink2.svelte generated by Svelte v3.22.3 */
const file$2a = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLink2.svelte";

function create_fragment$2a(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3");
			add_location(path, file$2a, 39, 4, 919);
			attr_dev(line, "x1", "8");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "12");
			add_location(line, file$2a, 40, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-link-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2a, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-link-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2a($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLink2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLink2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLink2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLink2",
			options,
			id: create_fragment$2a.name
		});
	}

	get class() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLink2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLink2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLink.svelte generated by Svelte v3.22.3 */
const file$2b = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLink.svelte";

function create_fragment$2b(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71");
			add_location(path0, file$2b, 39, 4, 917);
			attr_dev(path1, "d", "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71");
			add_location(path1, file$2b, 40, 4, 994);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-link feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2b, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-link feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2b($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLink> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLink", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLink extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLink",
			options,
			id: create_fragment$2b.name
		});
	}

	get class() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLinkedin.svelte generated by Svelte v3.22.3 */
const file$2c = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLinkedin.svelte";

function create_fragment$2c(ctx) {
	let svg;
	let path;
	let rect;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			rect = svg_element("rect");
			circle = svg_element("circle");
			attr_dev(path, "d", "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z");
			add_location(path, file$2c, 39, 4, 921);
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "9");
			attr_dev(rect, "width", "4");
			attr_dev(rect, "height", "12");
			add_location(rect, file$2c, 40, 4, 1017);
			attr_dev(circle, "cx", "4");
			attr_dev(circle, "cy", "4");
			attr_dev(circle, "r", "2");
			add_location(circle, file$2c, 41, 4, 1064);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-linkedin feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2c, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, rect);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-linkedin feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2c($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLinkedin> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLinkedin", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLinkedin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLinkedin",
			options,
			id: create_fragment$2c.name
		});
	}

	get class() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLinkedin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLinkedin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconList.svelte generated by Svelte v3.22.3 */
const file$2d = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconList.svelte";

function create_fragment$2d(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$2d, 39, 4, 917);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "21");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2d, 40, 4, 959);
			attr_dev(line2, "x1", "8");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "21");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$2d, 41, 4, 1003);
			attr_dev(line3, "x1", "3");
			attr_dev(line3, "y1", "6");
			attr_dev(line3, "x2", "3.01");
			attr_dev(line3, "y2", "6");
			add_location(line3, file$2d, 42, 4, 1047);
			attr_dev(line4, "x1", "3");
			attr_dev(line4, "y1", "12");
			attr_dev(line4, "x2", "3.01");
			attr_dev(line4, "y2", "12");
			add_location(line4, file$2d, 43, 4, 1091);
			attr_dev(line5, "x1", "3");
			attr_dev(line5, "y1", "18");
			attr_dev(line5, "x2", "3.01");
			attr_dev(line5, "y2", "18");
			add_location(line5, file$2d, 44, 4, 1137);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-list feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2d, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-list feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2d($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconList", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconList",
			options,
			id: create_fragment$2d.name
		});
	}

	get class() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLoader.svelte generated by Svelte v3.22.3 */
const file$2e = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLoader.svelte";

function create_fragment$2e(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$2e, 39, 4, 919);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "18");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$2e, 40, 4, 962);
			attr_dev(line2, "x1", "4.93");
			attr_dev(line2, "y1", "4.93");
			attr_dev(line2, "x2", "7.76");
			attr_dev(line2, "y2", "7.76");
			add_location(line2, file$2e, 41, 4, 1007);
			attr_dev(line3, "x1", "16.24");
			attr_dev(line3, "y1", "16.24");
			attr_dev(line3, "x2", "19.07");
			attr_dev(line3, "y2", "19.07");
			add_location(line3, file$2e, 42, 4, 1060);
			attr_dev(line4, "x1", "2");
			attr_dev(line4, "y1", "12");
			attr_dev(line4, "x2", "6");
			attr_dev(line4, "y2", "12");
			add_location(line4, file$2e, 43, 4, 1117);
			attr_dev(line5, "x1", "18");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "22");
			attr_dev(line5, "y2", "12");
			add_location(line5, file$2e, 44, 4, 1160);
			attr_dev(line6, "x1", "4.93");
			attr_dev(line6, "y1", "19.07");
			attr_dev(line6, "x2", "7.76");
			attr_dev(line6, "y2", "16.24");
			add_location(line6, file$2e, 45, 4, 1205);
			attr_dev(line7, "x1", "16.24");
			attr_dev(line7, "y1", "7.76");
			attr_dev(line7, "x2", "19.07");
			attr_dev(line7, "y2", "4.93");
			add_location(line7, file$2e, 46, 4, 1260);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-loader feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2e, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, line6);
			append_dev(svg, line7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-loader feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2e($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLoader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLoader", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLoader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLoader",
			options,
			id: create_fragment$2e.name
		});
	}

	get class() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLock.svelte generated by Svelte v3.22.3 */
const file$2f = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLock.svelte";

function create_fragment$2f(ctx) {
	let svg;
	let rect;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "11");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "11");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2f, 39, 4, 917);
			attr_dev(path, "d", "M7 11V7a5 5 0 0 1 10 0v4");
			add_location(path, file$2f, 40, 4, 980);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-lock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2f, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-lock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2f($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLock> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLock", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLock extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2f, create_fragment$2f, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLock",
			options,
			id: create_fragment$2f.name
		});
	}

	get class() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLogIn.svelte generated by Svelte v3.22.3 */
const file$2g = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLogIn.svelte";

function create_fragment$2g(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
			add_location(path, file$2g, 39, 4, 919);
			attr_dev(polyline, "points", "10 17 15 12 10 7");
			add_location(polyline, file$2g, 40, 4, 978);
			attr_dev(line, "x1", "15");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "3");
			attr_dev(line, "y2", "12");
			add_location(line, file$2g, 41, 4, 1021);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-log-in feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2g, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-log-in feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2g($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLogIn> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLogIn", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLogIn extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2g, create_fragment$2g, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLogIn",
			options,
			id: create_fragment$2g.name
		});
	}

	get class() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLogIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLogIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLogOut.svelte generated by Svelte v3.22.3 */
const file$2h = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconLogOut.svelte";

function create_fragment$2h(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4");
			add_location(path, file$2h, 39, 4, 920);
			attr_dev(polyline, "points", "16 17 21 12 16 7");
			add_location(polyline, file$2h, 40, 4, 977);
			attr_dev(line, "x1", "21");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "9");
			attr_dev(line, "y2", "12");
			add_location(line, file$2h, 41, 4, 1020);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-log-out feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2h, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-log-out feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2h($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconLogOut> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconLogOut", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconLogOut extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2h, create_fragment$2h, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconLogOut",
			options,
			id: create_fragment$2h.name
		});
	}

	get class() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconLogOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconLogOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMail.svelte generated by Svelte v3.22.3 */
const file$2i = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMail.svelte";

function create_fragment$2i(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z");
			add_location(path, file$2i, 39, 4, 917);
			attr_dev(polyline, "points", "22,6 12,13 2,6");
			add_location(polyline, file$2i, 40, 4, 1010);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-mail feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2i, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-mail feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2i($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMail> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMail", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMail extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2i, create_fragment$2i, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMail",
			options,
			id: create_fragment$2i.name
		});
	}

	get class() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMapPin.svelte generated by Svelte v3.22.3 */
const file$2j = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMapPin.svelte";

function create_fragment$2j(ctx) {
	let svg;
	let path;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path, "d", "M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z");
			add_location(path, file$2j, 39, 4, 920);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "10");
			attr_dev(circle, "r", "3");
			add_location(circle, file$2j, 40, 4, 984);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-map-pin feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2j, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-map-pin feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2j($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMapPin> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMapPin", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMapPin extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2j, create_fragment$2j, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMapPin",
			options,
			id: create_fragment$2j.name
		});
	}

	get class() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMapPin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMapPin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMap.svelte generated by Svelte v3.22.3 */
const file$2k = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMap.svelte";

function create_fragment$2k(ctx) {
	let svg;
	let polygon;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polygon, "points", "1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6");
			add_location(polygon, file$2k, 39, 4, 916);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$2k, 40, 4, 985);
			attr_dev(line1, "x1", "16");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$2k, 41, 4, 1027);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-map feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2k, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-map feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2k($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMap> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMap", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMap extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2k, create_fragment$2k, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMap",
			options,
			id: create_fragment$2k.name
		});
	}

	get class() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMaximize2.svelte generated by Svelte v3.22.3 */
const file$2l = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMaximize2.svelte";

function create_fragment$2l(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polyline0, "points", "15 3 21 3 21 9");
			add_location(polyline0, file$2l, 39, 4, 923);
			attr_dev(polyline1, "points", "9 21 3 21 3 15");
			add_location(polyline1, file$2l, 40, 4, 964);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "3");
			attr_dev(line0, "x2", "14");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$2l, 41, 4, 1005);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$2l, 42, 4, 1049);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-maximize-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2l, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-maximize-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2l($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMaximize2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMaximize2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMaximize2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2l, create_fragment$2l, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMaximize2",
			options,
			id: create_fragment$2l.name
		});
	}

	get class() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMaximize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMaximize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMaximize.svelte generated by Svelte v3.22.3 */
const file$2m = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMaximize.svelte";

function create_fragment$2m(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2\n        2h3");
			add_location(path, file$2m, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-maximize feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2m, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-maximize feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2m($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMaximize> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMaximize", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMaximize extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2m, create_fragment$2m, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMaximize",
			options,
			id: create_fragment$2m.name
		});
	}

	get class() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMaximize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMaximize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMeh.svelte generated by Svelte v3.22.3 */
const file$2n = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMeh.svelte";

function create_fragment$2n(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2n, 39, 4, 916);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "15");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$2n, 40, 4, 954);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "9.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$2n, 41, 4, 998);
			attr_dev(line2, "x1", "15");
			attr_dev(line2, "y1", "9");
			attr_dev(line2, "x2", "15.01");
			attr_dev(line2, "y2", "9");
			add_location(line2, file$2n, 42, 4, 1042);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-meh feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2n, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-meh feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2n($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMeh> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMeh", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMeh extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2n, create_fragment$2n, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMeh",
			options,
			id: create_fragment$2n.name
		});
	}

	get class() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMeh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMeh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMenu.svelte generated by Svelte v3.22.3 */
const file$2o = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMenu.svelte";

function create_fragment$2o(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "3");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2o, 39, 4, 917);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "21");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$2o, 40, 4, 961);
			attr_dev(line2, "x1", "3");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "21");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$2o, 41, 4, 1003);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-menu feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2o, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-menu feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2o($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMenu> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMenu", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2o, create_fragment$2o, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMenu",
			options,
			id: create_fragment$2o.name
		});
	}

	get class() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMessageCircle.svelte generated by Svelte v3.22.3 */
const file$2p = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMessageCircle.svelte";

function create_fragment$2p(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3\n        21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48\n        0 0 1 8 8v.5z");
			add_location(path, file$2p, 39, 4, 927);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-message-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2p, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-message-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2p($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMessageCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMessageCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMessageCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2p, create_fragment$2p, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMessageCircle",
			options,
			id: create_fragment$2p.name
		});
	}

	get class() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMessageCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMessageCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMessageSquare.svelte generated by Svelte v3.22.3 */
const file$2q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMessageSquare.svelte";

function create_fragment$2q(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
			add_location(path, file$2q, 39, 4, 927);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-message-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-message-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMessageSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMessageSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMessageSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2q, create_fragment$2q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMessageSquare",
			options,
			id: create_fragment$2q.name
		});
	}

	get class() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMessageSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMessageSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMicOff.svelte generated by Svelte v3.22.3 */
const file$2r = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMicOff.svelte";

function create_fragment$2r(ctx) {
	let svg;
	let line0;
	let path0;
	let path1;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(line0, "x1", "1");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$2r, 39, 4, 920);
			attr_dev(path0, "d", "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6");
			add_location(path0, file$2r, 40, 4, 963);
			attr_dev(path1, "d", "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23");
			add_location(path1, file$2r, 41, 4, 1035);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "19");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "23");
			add_location(line1, file$2r, 42, 4, 1106);
			attr_dev(line2, "x1", "8");
			attr_dev(line2, "y1", "23");
			attr_dev(line2, "x2", "16");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$2r, 43, 4, 1151);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-mic-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2r, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-mic-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2r($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMicOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMicOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMicOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2r, create_fragment$2r, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMicOff",
			options,
			id: create_fragment$2r.name
		});
	}

	get class() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMicOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMicOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMic.svelte generated by Svelte v3.22.3 */
const file$2s = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMic.svelte";

function create_fragment$2s(ctx) {
	let svg;
	let path0;
	let path1;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path0, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z");
			add_location(path0, file$2s, 39, 4, 916);
			attr_dev(path1, "d", "M19 10v2a7 7 0 0 1-14 0v-2");
			add_location(path1, file$2s, 40, 4, 986);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "19");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$2s, 41, 4, 1030);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "23");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "23");
			add_location(line1, file$2s, 42, 4, 1075);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-mic feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2s, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-mic feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2s($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMic> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMic", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMic extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2s, create_fragment$2s, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMic",
			options,
			id: create_fragment$2s.name
		});
	}

	get class() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinimize2.svelte generated by Svelte v3.22.3 */
const file$2t = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinimize2.svelte";

function create_fragment$2t(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polyline0, "points", "4 14 10 14 10 20");
			add_location(polyline0, file$2t, 39, 4, 923);
			attr_dev(polyline1, "points", "20 10 14 10 14 4");
			add_location(polyline1, file$2t, 40, 4, 966);
			attr_dev(line0, "x1", "14");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "3");
			add_location(line0, file$2t, 41, 4, 1009);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$2t, 42, 4, 1053);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-minimize-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2t, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-minimize-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2t($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMinimize2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMinimize2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMinimize2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2t, create_fragment$2t, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMinimize2",
			options,
			id: create_fragment$2t.name
		});
	}

	get class() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMinimize2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMinimize2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinimize.svelte generated by Svelte v3.22.3 */
const file$2u = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinimize.svelte";

function create_fragment$2u(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2\n        2v3");
			add_location(path, file$2u, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-minimize feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2u, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-minimize feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2u($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMinimize> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMinimize", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMinimize extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2u, create_fragment$2u, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMinimize",
			options,
			id: create_fragment$2u.name
		});
	}

	get class() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMinimize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMinimize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinusCircle.svelte generated by Svelte v3.22.3 */
const file$2v = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinusCircle.svelte";

function create_fragment$2v(ctx) {
	let svg;
	let circle;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2v, 39, 4, 925);
			attr_dev(line, "x1", "8");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "12");
			add_location(line, file$2v, 40, 4, 963);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-minus-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2v, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-minus-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2v($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMinusCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMinusCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMinusCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2v, create_fragment$2v, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMinusCircle",
			options,
			id: create_fragment$2v.name
		});
	}

	get class() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMinusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMinusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinusSquare.svelte generated by Svelte v3.22.3 */
const file$2w = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinusSquare.svelte";

function create_fragment$2w(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2w, 39, 4, 925);
			attr_dev(line, "x1", "8");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "12");
			add_location(line, file$2w, 40, 4, 987);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-minus-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2w, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-minus-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2w($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMinusSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMinusSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMinusSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2w, create_fragment$2w, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMinusSquare",
			options,
			id: create_fragment$2w.name
		});
	}

	get class() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMinusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMinusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinus.svelte generated by Svelte v3.22.3 */
const file$2x = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMinus.svelte";

function create_fragment$2x(ctx) {
	let svg;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "12");
			add_location(line, file$2x, 39, 4, 918);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2x, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2x($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMinus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMinus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2x, create_fragment$2x, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMinus",
			options,
			id: create_fragment$2x.name
		});
	}

	get class() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMonitor.svelte generated by Svelte v3.22.3 */
const file$2y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMonitor.svelte";

function create_fragment$2y(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2y, 39, 4, 920);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$2y, 40, 4, 982);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "17");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$2y, 41, 4, 1026);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-monitor feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-monitor feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMonitor> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMonitor", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMonitor extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2y, create_fragment$2y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMonitor",
			options,
			id: create_fragment$2y.name
		});
	}

	get class() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMonitor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMonitor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoon.svelte generated by Svelte v3.22.3 */
const file$2z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoon.svelte";

function create_fragment$2z(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z");
			add_location(path, file$2z, 39, 4, 917);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-moon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-moon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMoon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMoon", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMoon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2z, create_fragment$2z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMoon",
			options,
			id: create_fragment$2z.name
		});
	}

	get class() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMoon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMoon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoreHorizontal.svelte generated by Svelte v3.22.3 */
const file$2A = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoreHorizontal.svelte";

function create_fragment$2A(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$2A, 39, 4, 928);
			attr_dev(circle1, "cx", "19");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$2A, 40, 4, 965);
			attr_dev(circle2, "cx", "5");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "1");
			add_location(circle2, file$2A, 41, 4, 1002);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-more-horizontal feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2A, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, circle2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-more-horizontal feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2A($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMoreHorizontal> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMoreHorizontal", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMoreHorizontal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2A, create_fragment$2A, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMoreHorizontal",
			options,
			id: create_fragment$2A.name
		});
	}

	get class() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMoreHorizontal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMoreHorizontal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoreVertical.svelte generated by Svelte v3.22.3 */
const file$2B = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMoreVertical.svelte";

function create_fragment$2B(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$2B, 39, 4, 926);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "5");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$2B, 40, 4, 963);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "19");
			attr_dev(circle2, "r", "1");
			add_location(circle2, file$2B, 41, 4, 999);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-more-vertical feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2B, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, circle2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-more-vertical feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2B($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMoreVertical> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMoreVertical", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMoreVertical extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2B, create_fragment$2B, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMoreVertical",
			options,
			id: create_fragment$2B.name
		});
	}

	get class() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMoreVertical>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMoreVertical>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMousePointer.svelte generated by Svelte v3.22.3 */
const file$2C = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMousePointer.svelte";

function create_fragment$2C(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z");
			add_location(path0, file$2C, 39, 4, 926);
			attr_dev(path1, "d", "M13 13l6 6");
			add_location(path1, file$2C, 40, 4, 984);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-mouse-pointer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2C, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-mouse-pointer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2C($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMousePointer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMousePointer", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMousePointer extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2C, create_fragment$2C, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMousePointer",
			options,
			id: create_fragment$2C.name
		});
	}

	get class() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMousePointer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMousePointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMove.svelte generated by Svelte v3.22.3 */
const file$2D = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMove.svelte";

function create_fragment$2D(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let polyline2;
	let polyline3;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			polyline3 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polyline0, "points", "5 9 2 12 5 15");
			add_location(polyline0, file$2D, 39, 4, 917);
			attr_dev(polyline1, "points", "9 5 12 2 15 5");
			add_location(polyline1, file$2D, 40, 4, 957);
			attr_dev(polyline2, "points", "15 19 12 22 9 19");
			add_location(polyline2, file$2D, 41, 4, 997);
			attr_dev(polyline3, "points", "19 9 22 12 19 15");
			add_location(polyline3, file$2D, 42, 4, 1040);
			attr_dev(line0, "x1", "2");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "22");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2D, 43, 4, 1083);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$2D, 44, 4, 1127);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-move feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2D, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, polyline2);
			append_dev(svg, polyline3);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-move feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2D($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMove> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMove", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMove extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2D, create_fragment$2D, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMove",
			options,
			id: create_fragment$2D.name
		});
	}

	get class() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMove>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMove>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMusic.svelte generated by Svelte v3.22.3 */
const file$2E = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconMusic.svelte";

function create_fragment$2E(ctx) {
	let svg;
	let path;
	let circle0;
	let circle1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr_dev(path, "d", "M9 18V5l12-2v13");
			add_location(path, file$2E, 39, 4, 918);
			attr_dev(circle0, "cx", "6");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$2E, 40, 4, 951);
			attr_dev(circle1, "cx", "18");
			attr_dev(circle1, "cy", "16");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$2E, 41, 4, 987);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-music feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2E, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-music feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2E($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconMusic> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconMusic", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconMusic extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2E, create_fragment$2E, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconMusic",
			options,
			id: create_fragment$2E.name
		});
	}

	get class() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconMusic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconMusic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconNavigation2.svelte generated by Svelte v3.22.3 */
const file$2F = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconNavigation2.svelte";

function create_fragment$2F(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "12 2 19 21 12 17 5 21 12 2");
			add_location(polygon, file$2F, 39, 4, 925);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-navigation-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2F, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-navigation-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2F($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconNavigation2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconNavigation2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconNavigation2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2F, create_fragment$2F, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconNavigation2",
			options,
			id: create_fragment$2F.name
		});
	}

	get class() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconNavigation2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconNavigation2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconNavigation.svelte generated by Svelte v3.22.3 */
const file$2G = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconNavigation.svelte";

function create_fragment$2G(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "3 11 22 2 13 21 11 13 3 11");
			add_location(polygon, file$2G, 39, 4, 923);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-navigation feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2G, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-navigation feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2G($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconNavigation> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconNavigation", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconNavigation extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2G, create_fragment$2G, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconNavigation",
			options,
			id: create_fragment$2G.name
		});
	}

	get class() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconOctagon.svelte generated by Svelte v3.22.3 */
const file$2H = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconOctagon.svelte";

function create_fragment$2H(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$2H, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2H, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2H($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconOctagon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconOctagon", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconOctagon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2H, create_fragment$2H, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconOctagon",
			options,
			id: create_fragment$2H.name
		});
	}

	get class() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPackage.svelte generated by Svelte v3.22.3 */
const file$2I = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPackage.svelte";

function create_fragment$2I(ctx) {
	let svg;
	let line0;
	let path;
	let polyline;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line1 = svg_element("line");
			attr_dev(line0, "x1", "16.5");
			attr_dev(line0, "y1", "9.4");
			attr_dev(line0, "x2", "7.5");
			attr_dev(line0, "y2", "4.21");
			add_location(line0, file$2I, 39, 4, 920);
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2\n        2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$2I, 40, 4, 971);
			attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline, file$2I, 43, 4, 1126);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "22.08");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2I, 44, 4, 1182);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-package feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2I, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-package feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2I($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPackage> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPackage", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPackage extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2I, create_fragment$2I, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPackage",
			options,
			id: create_fragment$2I.name
		});
	}

	get class() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPackage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPackage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPaperclip.svelte generated by Svelte v3.22.3 */
const file$2J = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPaperclip.svelte";

function create_fragment$2J(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0\n        0 1-2.83-2.83l8.49-8.48");
			add_location(path, file$2J, 39, 4, 922);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-paperclip feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2J, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-paperclip feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2J($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPaperclip> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPaperclip", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPaperclip extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2J, create_fragment$2J, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPaperclip",
			options,
			id: create_fragment$2J.name
		});
	}

	get class() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPaperclip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPaperclip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPauseCircle.svelte generated by Svelte v3.22.3 */
const file$2K = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPauseCircle.svelte";

function create_fragment$2K(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2K, 39, 4, 925);
			attr_dev(line0, "x1", "10");
			attr_dev(line0, "y1", "15");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$2K, 40, 4, 963);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$2K, 41, 4, 1007);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-pause-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2K, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-pause-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2K($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPauseCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPauseCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPauseCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2K, create_fragment$2K, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPauseCircle",
			options,
			id: create_fragment$2K.name
		});
	}

	get class() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPauseCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPauseCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPause.svelte generated by Svelte v3.22.3 */
const file$2L = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPause.svelte";

function create_fragment$2L(ctx) {
	let svg;
	let rect0;
	let rect1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			attr_dev(rect0, "x", "6");
			attr_dev(rect0, "y", "4");
			attr_dev(rect0, "width", "4");
			attr_dev(rect0, "height", "16");
			add_location(rect0, file$2L, 39, 4, 918);
			attr_dev(rect1, "x", "14");
			attr_dev(rect1, "y", "4");
			attr_dev(rect1, "width", "4");
			attr_dev(rect1, "height", "16");
			add_location(rect1, file$2L, 40, 4, 965);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-pause feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2L, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect0);
			append_dev(svg, rect1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-pause feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2L($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPause> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPause", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPause extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2L, create_fragment$2L, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPause",
			options,
			id: create_fragment$2L.name
		});
	}

	get class() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPenTool.svelte generated by Svelte v3.22.3 */
const file$2M = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPenTool.svelte";

function create_fragment$2M(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path0, "d", "M12 19l7-7 3 3-7 7-3-3z");
			add_location(path0, file$2M, 39, 4, 921);
			attr_dev(path1, "d", "M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z");
			add_location(path1, file$2M, 40, 4, 962);
			attr_dev(path2, "d", "M2 2l7.586 7.586");
			add_location(path2, file$2M, 41, 4, 1019);
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "2");
			add_location(circle, file$2M, 42, 4, 1053);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-pen-tool feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2M, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-pen-tool feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2M($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPenTool> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPenTool", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPenTool extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2M, create_fragment$2M, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPenTool",
			options,
			id: create_fragment$2M.name
		});
	}

	get class() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPenTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPenTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPercent.svelte generated by Svelte v3.22.3 */
const file$2N = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPercent.svelte";

function create_fragment$2N(ctx) {
	let svg;
	let line;
	let circle0;
	let circle1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "19");
			add_location(line, file$2N, 39, 4, 920);
			attr_dev(circle0, "cx", "6.5");
			attr_dev(circle0, "cy", "6.5");
			attr_dev(circle0, "r", "2.5");
			add_location(circle0, file$2N, 40, 4, 963);
			attr_dev(circle1, "cx", "17.5");
			attr_dev(circle1, "cy", "17.5");
			attr_dev(circle1, "r", "2.5");
			add_location(circle1, file$2N, 41, 4, 1004);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-percent feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2N, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-percent feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2N($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPercent> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPercent", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPercent extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2N, create_fragment$2N, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPercent",
			options,
			id: create_fragment$2N.name
		});
	}

	get class() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPercent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPercent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneCall.svelte generated by Svelte v3.22.3 */
const file$2O = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneCall.svelte";

function create_fragment$2O(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79\n        19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2\n        0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6\n        6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$2O, 39, 4, 923);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-call feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2O, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-call feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2O($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneCall> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneCall", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneCall extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2O, create_fragment$2O, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneCall",
			options,
			id: create_fragment$2O.name
		});
	}

	get class() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneCall>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneCall>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneForwarded.svelte generated by Svelte v3.22.3 */
const file$2P = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneForwarded.svelte";

function create_fragment$2P(ctx) {
	let svg;
	let polyline;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(polyline, "points", "19 1 23 5 19 9");
			add_location(polyline, file$2P, 39, 4, 928);
			attr_dev(line, "x1", "15");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "5");
			add_location(line, file$2P, 40, 4, 969);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79\n        0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45\n        2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0\n        1 22 16.92z");
			add_location(path, file$2P, 41, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-forwarded feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2P, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-forwarded feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2P($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneForwarded> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneForwarded", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneForwarded extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2P, create_fragment$2P, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneForwarded",
			options,
			id: create_fragment$2P.name
		});
	}

	get class() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneForwarded>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneForwarded>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneIncoming.svelte generated by Svelte v3.22.3 */
const file$2Q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneIncoming.svelte";

function create_fragment$2Q(ctx) {
	let svg;
	let polyline;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(polyline, "points", "16 2 16 8 22 8");
			add_location(polyline, file$2Q, 39, 4, 927);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "8");
			add_location(line, file$2Q, 40, 4, 968);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79\n        0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45\n        2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0\n        1 22 16.92z");
			add_location(path, file$2Q, 41, 4, 1011);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-incoming feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2Q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-incoming feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneIncoming> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneIncoming", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneIncoming extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2Q, create_fragment$2Q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneIncoming",
			options,
			id: create_fragment$2Q.name
		});
	}

	get class() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneIncoming>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneIncoming>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneMissed.svelte generated by Svelte v3.22.3 */
const file$2R = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneMissed.svelte";

function create_fragment$2R(ctx) {
	let svg;
	let line0;
	let line1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			path = svg_element("path");
			attr_dev(line0, "x1", "23");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "17");
			attr_dev(line0, "y2", "7");
			add_location(line0, file$2R, 39, 4, 925);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "23");
			attr_dev(line1, "y2", "7");
			add_location(line1, file$2R, 40, 4, 968);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79\n        0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45\n        2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0\n        1 22 16.92z");
			add_location(path, file$2R, 41, 4, 1011);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-missed feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2R, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-missed feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2R($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneMissed> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneMissed", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneMissed extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2R, create_fragment$2R, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneMissed",
			options,
			id: create_fragment$2R.name
		});
	}

	get class() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneMissed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneMissed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneOff.svelte generated by Svelte v3.22.3 */
const file$2S = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneOff.svelte";

function create_fragment$2S(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2\n        2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0\n        1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84\n        12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91");
			add_location(path, file$2S, 39, 4, 922);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "1");
			attr_dev(line, "y2", "23");
			add_location(line, file$2S, 44, 4, 1281);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2S, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2S($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2S, create_fragment$2S, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneOff",
			options,
			id: create_fragment$2S.name
		});
	}

	get class() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneOutgoing.svelte generated by Svelte v3.22.3 */
const file$2T = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhoneOutgoing.svelte";

function create_fragment$2T(ctx) {
	let svg;
	let polyline;
	let line;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			attr_dev(polyline, "points", "23 7 23 1 17 1");
			add_location(polyline, file$2T, 39, 4, 927);
			attr_dev(line, "x1", "16");
			attr_dev(line, "y1", "8");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "1");
			add_location(line, file$2T, 40, 4, 968);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79\n        0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45\n        2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0\n        1 22 16.92z");
			add_location(path, file$2T, 41, 4, 1011);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone-outgoing feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2T, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone-outgoing feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2T($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhoneOutgoing> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhoneOutgoing", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhoneOutgoing extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2T, create_fragment$2T, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhoneOutgoing",
			options,
			id: create_fragment$2T.name
		});
	}

	get class() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhoneOutgoing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhoneOutgoing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhone.svelte generated by Svelte v3.22.3 */
const file$2U = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPhone.svelte";

function create_fragment$2U(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79\n        0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45\n        2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0\n        1 22 16.92z");
			add_location(path, file$2U, 39, 4, 918);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-phone feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2U, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-phone feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2U($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPhone> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPhone", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPhone extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2U, create_fragment$2U, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPhone",
			options,
			id: create_fragment$2U.name
		});
	}

	get class() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPhone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPhone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPieChart.svelte generated by Svelte v3.22.3 */
const file$2V = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPieChart.svelte";

function create_fragment$2V(ctx) {
	let svg;
	let path0;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M21.21 15.89A10 10 0 1 1 8 2.83");
			add_location(path0, file$2V, 39, 4, 922);
			attr_dev(path1, "d", "M22 12A10 10 0 0 0 12 2v10z");
			add_location(path1, file$2V, 40, 4, 971);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-pie-chart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2V, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-pie-chart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2V($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPieChart> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPieChart", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPieChart extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2V, create_fragment$2V, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPieChart",
			options,
			id: create_fragment$2V.name
		});
	}

	get class() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlayCircle.svelte generated by Svelte v3.22.3 */
const file$2W = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlayCircle.svelte";

function create_fragment$2W(ctx) {
	let svg;
	let circle;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polygon = svg_element("polygon");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2W, 39, 4, 924);
			attr_dev(polygon, "points", "10 8 16 12 10 16 10 8");
			add_location(polygon, file$2W, 40, 4, 962);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-play-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2W, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-play-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2W($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPlayCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPlayCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPlayCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2W, create_fragment$2W, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPlayCircle",
			options,
			id: create_fragment$2W.name
		});
	}

	get class() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPlayCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPlayCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlay.svelte generated by Svelte v3.22.3 */
const file$2X = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlay.svelte";

function create_fragment$2X(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
			add_location(polygon, file$2X, 39, 4, 917);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-play feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2X, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-play feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2X($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPlay> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPlay", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPlay extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2X, create_fragment$2X, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPlay",
			options,
			id: create_fragment$2X.name
		});
	}

	get class() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlusCircle.svelte generated by Svelte v3.22.3 */
const file$2Y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlusCircle.svelte";

function create_fragment$2Y(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2Y, 39, 4, 924);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "16");
			add_location(line0, file$2Y, 40, 4, 962);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2Y, 41, 4, 1006);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-plus-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2Y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-plus-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPlusCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPlusCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPlusCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2Y, create_fragment$2Y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPlusCircle",
			options,
			id: create_fragment$2Y.name
		});
	}

	get class() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPlusCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPlusCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlusSquare.svelte generated by Svelte v3.22.3 */
const file$2Z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlusSquare.svelte";

function create_fragment$2Z(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2Z, 39, 4, 924);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "16");
			add_location(line0, file$2Z, 40, 4, 986);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2Z, 41, 4, 1030);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-plus-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2Z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-plus-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPlusSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPlusSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPlusSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2Z, create_fragment$2Z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPlusSquare",
			options,
			id: create_fragment$2Z.name
		});
	}

	get class() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPlusSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPlusSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlus.svelte generated by Svelte v3.22.3 */
const file$2_ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPlus.svelte";

function create_fragment$2_(ctx) {
	let svg;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "5");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "19");
			add_location(line0, file$2_, 39, 4, 917);
			attr_dev(line1, "x1", "5");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "19");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2_, 40, 4, 961);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2_, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2_($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPlus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPlus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPlus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2_, create_fragment$2_, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPlus",
			options,
			id: create_fragment$2_.name
		});
	}

	get class() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPocket.svelte generated by Svelte v3.22.3 */
const file$2$ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPocket.svelte";

function create_fragment$2$(ctx) {
	let svg;
	let path;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z");
			add_location(path, file$2$, 39, 4, 919);
			attr_dev(polyline, "points", "8 10 12 14 16 10");
			add_location(polyline, file$2$, 40, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-pocket feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$2$, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-pocket feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2$($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPocket> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPocket", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPocket extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2$, create_fragment$2$, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPocket",
			options,
			id: create_fragment$2$.name
		});
	}

	get class() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPocket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPocket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPower.svelte generated by Svelte v3.22.3 */
const file$30 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPower.svelte";

function create_fragment$30(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
			add_location(path, file$30, 39, 4, 918);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$30, 40, 4, 965);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-power feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$30, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-power feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$30.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$30($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPower> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPower", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPower extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$30, create_fragment$30, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPower",
			options,
			id: create_fragment$30.name
		});
	}

	get class() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPower>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPower>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPrinter.svelte generated by Svelte v3.22.3 */
const file$31 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconPrinter.svelte";

function create_fragment$31(ctx) {
	let svg;
	let polyline;
	let path;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			rect = svg_element("rect");
			attr_dev(polyline, "points", "6 9 6 2 18 2 18 9");
			add_location(polyline, file$31, 39, 4, 920);
			attr_dev(path, "d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2");
			add_location(path, file$31, 40, 4, 964);
			attr_dev(rect, "x", "6");
			attr_dev(rect, "y", "14");
			attr_dev(rect, "width", "12");
			attr_dev(rect, "height", "8");
			add_location(rect, file$31, 41, 4, 1056);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-printer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$31, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
			append_dev(svg, rect);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-printer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$31.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$31($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconPrinter> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconPrinter", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconPrinter extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$31, create_fragment$31, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconPrinter",
			options,
			id: create_fragment$31.name
		});
	}

	get class() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconPrinter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconPrinter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRadio.svelte generated by Svelte v3.22.3 */
const file$32 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRadio.svelte";

function create_fragment$32(ctx) {
	let svg;
	let circle;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "2");
			add_location(circle, file$32, 39, 4, 918);
			attr_dev(path, "d", "M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0\n        14.14m-14.14 0a10 10 0 0 1 0-14.14");
			add_location(path, file$32, 40, 4, 955);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-radio feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$32, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-radio feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$32.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$32($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRadio> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRadio", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRadio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$32, create_fragment$32, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRadio",
			options,
			id: create_fragment$32.name
		});
	}

	get class() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRadio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRadio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRefreshCcw.svelte generated by Svelte v3.22.3 */
const file$33 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRefreshCcw.svelte";

function create_fragment$33(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline0, "points", "1 4 1 10 7 10");
			add_location(polyline0, file$33, 39, 4, 924);
			attr_dev(polyline1, "points", "23 20 23 14 17 14");
			add_location(polyline1, file$33, 40, 4, 964);
			attr_dev(path, "d", "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15");
			add_location(path, file$33, 41, 4, 1008);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-refresh-ccw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$33, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-refresh-ccw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$33.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$33($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRefreshCcw> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRefreshCcw", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRefreshCcw extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$33, create_fragment$33, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRefreshCcw",
			options,
			id: create_fragment$33.name
		});
	}

	get class() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRefreshCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRefreshCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRefreshCw.svelte generated by Svelte v3.22.3 */
const file$34 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRefreshCw.svelte";

function create_fragment$34(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline0, "points", "23 4 23 10 17 10");
			add_location(polyline0, file$34, 39, 4, 923);
			attr_dev(polyline1, "points", "1 20 1 14 7 14");
			add_location(polyline1, file$34, 40, 4, 966);
			attr_dev(path, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
			add_location(path, file$34, 41, 4, 1007);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-refresh-cw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$34, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-refresh-cw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$34.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$34($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRefreshCw> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRefreshCw", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRefreshCw extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$34, create_fragment$34, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRefreshCw",
			options,
			id: create_fragment$34.name
		});
	}

	get class() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRefreshCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRefreshCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRepeat.svelte generated by Svelte v3.22.3 */
const file$35 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRepeat.svelte";

function create_fragment$35(ctx) {
	let svg;
	let polyline0;
	let path0;
	let polyline1;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			path0 = svg_element("path");
			polyline1 = svg_element("polyline");
			path1 = svg_element("path");
			attr_dev(polyline0, "points", "17 1 21 5 17 9");
			add_location(polyline0, file$35, 39, 4, 919);
			attr_dev(path0, "d", "M3 11V9a4 4 0 0 1 4-4h14");
			add_location(path0, file$35, 40, 4, 960);
			attr_dev(polyline1, "points", "7 23 3 19 7 15");
			add_location(polyline1, file$35, 41, 4, 1002);
			attr_dev(path1, "d", "M21 13v2a4 4 0 0 1-4 4H3");
			add_location(path1, file$35, 42, 4, 1043);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-repeat feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$35, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, path0);
			append_dev(svg, polyline1);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-repeat feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$35.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$35($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRepeat> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRepeat", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRepeat extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$35, create_fragment$35, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRepeat",
			options,
			id: create_fragment$35.name
		});
	}

	get class() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRepeat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRepeat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRewind.svelte generated by Svelte v3.22.3 */
const file$36 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRewind.svelte";

function create_fragment$36(ctx) {
	let svg;
	let polygon0;
	let polygon1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon0 = svg_element("polygon");
			polygon1 = svg_element("polygon");
			attr_dev(polygon0, "points", "11 19 2 12 11 5 11 19");
			add_location(polygon0, file$36, 39, 4, 919);
			attr_dev(polygon1, "points", "22 19 13 12 22 5 22 19");
			add_location(polygon1, file$36, 40, 4, 966);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-rewind feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$36, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon0);
			append_dev(svg, polygon1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-rewind feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$36.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$36($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRewind> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRewind", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRewind extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$36, create_fragment$36, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRewind",
			options,
			id: create_fragment$36.name
		});
	}

	get class() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRewind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRewind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRotateCcw.svelte generated by Svelte v3.22.3 */
const file$37 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRotateCcw.svelte";

function create_fragment$37(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "1 4 1 10 7 10");
			add_location(polyline, file$37, 39, 4, 923);
			attr_dev(path, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10");
			add_location(path, file$37, 40, 4, 963);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-rotate-ccw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$37, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-rotate-ccw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$37.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$37($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRotateCcw> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRotateCcw", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRotateCcw extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$37, create_fragment$37, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRotateCcw",
			options,
			id: create_fragment$37.name
		});
	}

	get class() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRotateCcw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRotateCcw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRotateCw.svelte generated by Svelte v3.22.3 */
const file$38 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRotateCw.svelte";

function create_fragment$38(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "23 4 23 10 17 10");
			add_location(polyline, file$38, 39, 4, 922);
			attr_dev(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
			add_location(path, file$38, 40, 4, 965);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-rotate-cw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$38, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-rotate-cw feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$38.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$38($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRotateCw> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRotateCw", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRotateCw extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$38, create_fragment$38, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRotateCw",
			options,
			id: create_fragment$38.name
		});
	}

	get class() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRotateCw>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRotateCw>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRss.svelte generated by Svelte v3.22.3 */
const file$39 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconRss.svelte";

function create_fragment$39(ctx) {
	let svg;
	let path0;
	let path1;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path0, "d", "M4 11a9 9 0 0 1 9 9");
			add_location(path0, file$39, 39, 4, 916);
			attr_dev(path1, "d", "M4 4a16 16 0 0 1 16 16");
			add_location(path1, file$39, 40, 4, 953);
			attr_dev(circle, "cx", "5");
			attr_dev(circle, "cy", "19");
			attr_dev(circle, "r", "1");
			add_location(circle, file$39, 41, 4, 993);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-rss feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$39, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-rss feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$39.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$39($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconRss> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconRss", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconRss extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$39, create_fragment$39, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconRss",
			options,
			id: create_fragment$39.name
		});
	}

	get class() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconRss>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconRss>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSave.svelte generated by Svelte v3.22.3 */
const file$3a = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSave.svelte";

function create_fragment$3a(ctx) {
	let svg;
	let path;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(path, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
			add_location(path, file$3a, 39, 4, 917);
			attr_dev(polyline0, "points", "17 21 17 13 7 13 7 21");
			add_location(polyline0, file$3a, 40, 4, 998);
			attr_dev(polyline1, "points", "7 3 7 8 15 8");
			add_location(polyline1, file$3a, 41, 4, 1046);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-save feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3a, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-save feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3a($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSave> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSave", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSave extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3a, create_fragment$3a, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSave",
			options,
			id: create_fragment$3a.name
		});
	}

	get class() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSave>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSave>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconScissors.svelte generated by Svelte v3.22.3 */
const file$3b = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconScissors.svelte";

function create_fragment$3b(ctx) {
	let svg;
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(circle0, "cx", "6");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$3b, 39, 4, 921);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$3b, 40, 4, 956);
			attr_dev(line0, "x1", "20");
			attr_dev(line0, "y1", "4");
			attr_dev(line0, "x2", "8.12");
			attr_dev(line0, "y2", "15.88");
			add_location(line0, file$3b, 41, 4, 992);
			attr_dev(line1, "x1", "14.47");
			attr_dev(line1, "y1", "14.48");
			attr_dev(line1, "x2", "20");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$3b, 42, 4, 1041);
			attr_dev(line2, "x1", "8.12");
			attr_dev(line2, "y1", "8.12");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$3b, 43, 4, 1092);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-scissors feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3b, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-scissors feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3b($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconScissors> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconScissors", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconScissors extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3b, create_fragment$3b, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconScissors",
			options,
			id: create_fragment$3b.name
		});
	}

	get class() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconScissors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconScissors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSearch.svelte generated by Svelte v3.22.3 */
const file$3c = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSearch.svelte";

function create_fragment$3c(ctx) {
	let svg;
	let circle;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$3c, 39, 4, 919);
			attr_dev(line, "x1", "21");
			attr_dev(line, "y1", "21");
			attr_dev(line, "x2", "16.65");
			attr_dev(line, "y2", "16.65");
			add_location(line, file$3c, 40, 4, 956);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-search feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3c, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-search feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3c($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSearch> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSearch", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSearch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3c, create_fragment$3c, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSearch",
			options,
			id: create_fragment$3c.name
		});
	}

	get class() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSearch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSearch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSend.svelte generated by Svelte v3.22.3 */
const file$3d = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSend.svelte";

function create_fragment$3d(ctx) {
	let svg;
	let line;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line = svg_element("line");
			polygon = svg_element("polygon");
			attr_dev(line, "x1", "22");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "11");
			attr_dev(line, "y2", "13");
			add_location(line, file$3d, 39, 4, 917);
			attr_dev(polygon, "points", "22 2 15 22 11 13 2 9 22 2");
			add_location(polygon, file$3d, 40, 4, 961);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-send feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3d, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-send feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3d($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSend> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSend", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSend extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3d, create_fragment$3d, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSend",
			options,
			id: create_fragment$3d.name
		});
	}

	get class() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconServer.svelte generated by Svelte v3.22.3 */
const file$3e = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconServer.svelte";

function create_fragment$3e(ctx) {
	let svg;
	let rect0;
	let rect1;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(rect0, "x", "2");
			attr_dev(rect0, "y", "2");
			attr_dev(rect0, "width", "20");
			attr_dev(rect0, "height", "8");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$3e, 39, 4, 919);
			attr_dev(rect1, "x", "2");
			attr_dev(rect1, "y", "14");
			attr_dev(rect1, "width", "20");
			attr_dev(rect1, "height", "8");
			attr_dev(rect1, "rx", "2");
			attr_dev(rect1, "ry", "2");
			add_location(rect1, file$3e, 40, 4, 980);
			attr_dev(line0, "x1", "6");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6.01");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$3e, 41, 4, 1042);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "18");
			attr_dev(line1, "x2", "6.01");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$3e, 42, 4, 1086);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-server feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3e, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect0);
			append_dev(svg, rect1);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-server feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3e($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconServer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconServer", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconServer extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3e, create_fragment$3e, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconServer",
			options,
			id: create_fragment$3e.name
		});
	}

	get class() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSettings.svelte generated by Svelte v3.22.3 */
const file$3f = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSettings.svelte";

function create_fragment$3f(ctx) {
	let svg;
	let circle;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$3f, 39, 4, 921);
			attr_dev(path, "d", "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65\n        1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0\n        0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65\n        0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6\n        9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0\n        1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51\n        1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0\n        0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51\n        1z");
			add_location(path, file$3f, 40, 4, 958);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-settings feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3f, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-settings feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3f($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSettings> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSettings", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSettings extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3f, create_fragment$3f, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSettings",
			options,
			id: create_fragment$3f.name
		});
	}

	get class() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSettings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSettings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShare2.svelte generated by Svelte v3.22.3 */
const file$3g = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShare2.svelte";

function create_fragment$3g(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "5");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$3g, 39, 4, 920);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$3g, 40, 4, 956);
			attr_dev(circle2, "cx", "18");
			attr_dev(circle2, "cy", "19");
			attr_dev(circle2, "r", "3");
			add_location(circle2, file$3g, 41, 4, 992);
			attr_dev(line0, "x1", "8.59");
			attr_dev(line0, "y1", "13.51");
			attr_dev(line0, "x2", "15.42");
			attr_dev(line0, "y2", "17.49");
			add_location(line0, file$3g, 42, 4, 1029);
			attr_dev(line1, "x1", "15.41");
			attr_dev(line1, "y1", "6.51");
			attr_dev(line1, "x2", "8.59");
			attr_dev(line1, "y2", "10.49");
			add_location(line1, file$3g, 43, 4, 1085);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-share-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3g, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, circle2);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-share-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3g($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShare2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShare2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShare2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3g, create_fragment$3g, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShare2",
			options,
			id: create_fragment$3g.name
		});
	}

	get class() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShare2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShare2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShare.svelte generated by Svelte v3.22.3 */
const file$3h = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShare.svelte";

function create_fragment$3h(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8");
			add_location(path, file$3h, 39, 4, 918);
			attr_dev(polyline, "points", "16 6 12 2 8 6");
			add_location(polyline, file$3h, 40, 4, 977);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "15");
			add_location(line, file$3h, 41, 4, 1017);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-share feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3h, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-share feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3h($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3h, create_fragment$3h, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShare",
			options,
			id: create_fragment$3h.name
		});
	}

	get class() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShieldOff.svelte generated by Svelte v3.22.3 */
const file$3i = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShieldOff.svelte";

function create_fragment$3i(ctx) {
	let svg;
	let path0;
	let path1;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line = svg_element("line");
			attr_dev(path0, "d", "M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18");
			add_location(path0, file$3i, 39, 4, 923);
			attr_dev(path1, "d", "M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38");
			add_location(path1, file$3i, 40, 4, 987);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$3i, 41, 4, 1063);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-shield-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3i, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-shield-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3i($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShieldOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShieldOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShieldOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3i, create_fragment$3i, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShieldOff",
			options,
			id: create_fragment$3i.name
		});
	}

	get class() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShieldOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShieldOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShield.svelte generated by Svelte v3.22.3 */
const file$3j = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShield.svelte";

function create_fragment$3j(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
			add_location(path, file$3j, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-shield feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3j, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-shield feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3j($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShield> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShield", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShield extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3j, create_fragment$3j, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShield",
			options,
			id: create_fragment$3j.name
		});
	}

	get class() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShoppingBag.svelte generated by Svelte v3.22.3 */
const file$3k = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShoppingBag.svelte";

function create_fragment$3k(ctx) {
	let svg;
	let path0;
	let line;
	let path1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			line = svg_element("line");
			path1 = svg_element("path");
			attr_dev(path0, "d", "M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z");
			add_location(path0, file$3k, 39, 4, 925);
			attr_dev(line, "x1", "3");
			attr_dev(line, "y1", "6");
			attr_dev(line, "x2", "21");
			attr_dev(line, "y2", "6");
			add_location(line, file$3k, 40, 4, 993);
			attr_dev(path1, "d", "M16 10a4 4 0 0 1-8 0");
			add_location(path1, file$3k, 41, 4, 1035);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-shopping-bag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3k, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, line);
			append_dev(svg, path1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-shopping-bag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3k($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShoppingBag> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShoppingBag", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShoppingBag extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3k, create_fragment$3k, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShoppingBag",
			options,
			id: create_fragment$3k.name
		});
	}

	get class() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShoppingBag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShoppingBag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShoppingCart.svelte generated by Svelte v3.22.3 */
const file$3l = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShoppingCart.svelte";

function create_fragment$3l(ctx) {
	let svg;
	let circle0;
	let circle1;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			attr_dev(circle0, "cx", "9");
			attr_dev(circle0, "cy", "21");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$3l, 39, 4, 926);
			attr_dev(circle1, "cx", "20");
			attr_dev(circle1, "cy", "21");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$3l, 40, 4, 962);
			attr_dev(path, "d", "M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6");
			add_location(path, file$3l, 41, 4, 999);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-shopping-cart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3l, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-shopping-cart feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3l($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShoppingCart> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShoppingCart", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShoppingCart extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3l, create_fragment$3l, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShoppingCart",
			options,
			id: create_fragment$3l.name
		});
	}

	get class() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShoppingCart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShoppingCart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShuffle.svelte generated by Svelte v3.22.3 */
const file$3m = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconShuffle.svelte";

function create_fragment$3m(ctx) {
	let svg;
	let polyline0;
	let line0;
	let polyline1;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			line0 = svg_element("line");
			polyline1 = svg_element("polyline");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(polyline0, "points", "16 3 21 3 21 8");
			add_location(polyline0, file$3m, 39, 4, 920);
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "3");
			add_location(line0, file$3m, 40, 4, 961);
			attr_dev(polyline1, "points", "21 16 21 21 16 21");
			add_location(polyline1, file$3m, 41, 4, 1004);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "21");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$3m, 42, 4, 1048);
			attr_dev(line2, "x1", "4");
			attr_dev(line2, "y1", "4");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "9");
			add_location(line2, file$3m, 43, 4, 1093);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-shuffle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3m, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, line0);
			append_dev(svg, polyline1);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-shuffle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3m($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconShuffle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconShuffle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconShuffle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3m, create_fragment$3m, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconShuffle",
			options,
			id: create_fragment$3m.name
		});
	}

	get class() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconShuffle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconShuffle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSidebar.svelte generated by Svelte v3.22.3 */
const file$3n = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSidebar.svelte";

function create_fragment$3n(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3n, 39, 4, 920);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "9");
			attr_dev(line, "y2", "21");
			add_location(line, file$3n, 40, 4, 982);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-sidebar feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3n, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-sidebar feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3n($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSidebar> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSidebar", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSidebar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3n, create_fragment$3n, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSidebar",
			options,
			id: create_fragment$3n.name
		});
	}

	get class() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSkipBack.svelte generated by Svelte v3.22.3 */
const file$3o = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSkipBack.svelte";

function create_fragment$3o(ctx) {
	let svg;
	let polygon;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line = svg_element("line");
			attr_dev(polygon, "points", "19 20 9 12 19 4 19 20");
			add_location(polygon, file$3o, 39, 4, 922);
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "5");
			add_location(line, file$3o, 40, 4, 969);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-skip-back feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3o, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-skip-back feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3o($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSkipBack> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSkipBack", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSkipBack extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3o, create_fragment$3o, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSkipBack",
			options,
			id: create_fragment$3o.name
		});
	}

	get class() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSkipBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSkipBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSkipForward.svelte generated by Svelte v3.22.3 */
const file$3p = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSkipForward.svelte";

function create_fragment$3p(ctx) {
	let svg;
	let polygon;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line = svg_element("line");
			attr_dev(polygon, "points", "5 4 15 12 5 20 5 4");
			add_location(polygon, file$3p, 39, 4, 925);
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "19");
			add_location(line, file$3p, 40, 4, 969);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-skip-forward feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3p, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-skip-forward feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3p($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSkipForward> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSkipForward", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSkipForward extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3p, create_fragment$3p, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSkipForward",
			options,
			id: create_fragment$3p.name
		});
	}

	get class() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSkipForward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSkipForward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSlack.svelte generated by Svelte v3.22.3 */
const file$3q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSlack.svelte";

function create_fragment$3q(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			attr_dev(path0, "d", "M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67\n        1.5-1.5 1.5z");
			add_location(path0, file$3q, 39, 4, 918);
			attr_dev(path1, "d", "M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
			add_location(path1, file$3q, 42, 4, 1047);
			attr_dev(path2, "d", "M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5\n        1.5-1.5z");
			add_location(path2, file$3q, 43, 4, 1133);
			attr_dev(path3, "d", "M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z");
			add_location(path3, file$3q, 46, 4, 1259);
			attr_dev(path4, "d", "M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83\n        0-1.5-.67-1.5-1.5z");
			add_location(path4, file$3q, 47, 4, 1343);
			attr_dev(path5, "d", "M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
			add_location(path5, file$3q, 50, 4, 1473);
			attr_dev(path6, "d", "M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67\n        1.5-1.5z");
			add_location(path6, file$3q, 51, 4, 1560);
			attr_dev(path7, "d", "M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z");
			add_location(path7, file$3q, 54, 4, 1685);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-slack feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, path3);
			append_dev(svg, path4);
			append_dev(svg, path5);
			append_dev(svg, path6);
			append_dev(svg, path7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-slack feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSlack> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSlack", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSlack extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3q, create_fragment$3q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSlack",
			options,
			id: create_fragment$3q.name
		});
	}

	get class() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSlack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSlack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSlash.svelte generated by Svelte v3.22.3 */
const file$3r = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSlash.svelte";

function create_fragment$3r(ctx) {
	let svg;
	let circle;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3r, 39, 4, 918);
			attr_dev(line, "x1", "4.93");
			attr_dev(line, "y1", "4.93");
			attr_dev(line, "x2", "19.07");
			attr_dev(line, "y2", "19.07");
			add_location(line, file$3r, 40, 4, 956);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-slash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3r, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-slash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3r($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSlash> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSlash", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSlash extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3r, create_fragment$3r, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSlash",
			options,
			id: create_fragment$3r.name
		});
	}

	get class() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSlash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSlash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSliders.svelte generated by Svelte v3.22.3 */
const file$3s = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSliders.svelte";

function create_fragment$3s(ctx) {
	let svg;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let line8;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			line8 = svg_element("line");
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "4");
			attr_dev(line0, "y2", "14");
			add_location(line0, file$3s, 39, 4, 920);
			attr_dev(line1, "x1", "4");
			attr_dev(line1, "y1", "10");
			attr_dev(line1, "x2", "4");
			attr_dev(line1, "y2", "3");
			add_location(line1, file$3s, 40, 4, 963);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "21");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$3s, 41, 4, 1005);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "8");
			attr_dev(line3, "x2", "12");
			attr_dev(line3, "y2", "3");
			add_location(line3, file$3s, 42, 4, 1050);
			attr_dev(line4, "x1", "20");
			attr_dev(line4, "y1", "21");
			attr_dev(line4, "x2", "20");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$3s, 43, 4, 1093);
			attr_dev(line5, "x1", "20");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "20");
			attr_dev(line5, "y2", "3");
			add_location(line5, file$3s, 44, 4, 1138);
			attr_dev(line6, "x1", "1");
			attr_dev(line6, "y1", "14");
			attr_dev(line6, "x2", "7");
			attr_dev(line6, "y2", "14");
			add_location(line6, file$3s, 45, 4, 1182);
			attr_dev(line7, "x1", "9");
			attr_dev(line7, "y1", "8");
			attr_dev(line7, "x2", "15");
			attr_dev(line7, "y2", "8");
			add_location(line7, file$3s, 46, 4, 1225);
			attr_dev(line8, "x1", "17");
			attr_dev(line8, "y1", "16");
			attr_dev(line8, "x2", "23");
			attr_dev(line8, "y2", "16");
			add_location(line8, file$3s, 47, 4, 1267);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-sliders feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3s, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, line6);
			append_dev(svg, line7);
			append_dev(svg, line8);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-sliders feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3s($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSliders> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSliders", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSliders extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3s, create_fragment$3s, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSliders",
			options,
			id: create_fragment$3s.name
		});
	}

	get class() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSliders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSliders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSmartphone.svelte generated by Svelte v3.22.3 */
const file$3t = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSmartphone.svelte";

function create_fragment$3t(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "5");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "14");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3t, 39, 4, 923);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "18");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "18");
			add_location(line, file$3t, 40, 4, 985);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-smartphone feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3t, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-smartphone feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3t($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSmartphone> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSmartphone", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSmartphone extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3t, create_fragment$3t, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSmartphone",
			options,
			id: create_fragment$3t.name
		});
	}

	get class() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSmartphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSmartphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSmile.svelte generated by Svelte v3.22.3 */
const file$3u = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSmile.svelte";

function create_fragment$3u(ctx) {
	let svg;
	let circle;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3u, 39, 4, 918);
			attr_dev(path, "d", "M8 14s1.5 2 4 2 4-2 4-2");
			add_location(path, file$3u, 40, 4, 956);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9.01");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$3u, 41, 4, 997);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$3u, 42, 4, 1041);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-smile feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3u, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-smile feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3u($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSmile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSmile", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSmile extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3u, create_fragment$3u, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSmile",
			options,
			id: create_fragment$3u.name
		});
	}

	get class() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSmile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSmile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSpeaker.svelte generated by Svelte v3.22.3 */
const file$3v = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSpeaker.svelte";

function create_fragment$3v(ctx) {
	let svg;
	let rect;
	let circle;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle = svg_element("circle");
			line = svg_element("line");
			attr_dev(rect, "x", "4");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "16");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3v, 39, 4, 920);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "14");
			attr_dev(circle, "r", "4");
			add_location(circle, file$3v, 40, 4, 982);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "6");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "6");
			add_location(line, file$3v, 41, 4, 1019);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-speaker feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3v, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, circle);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-speaker feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3v($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSpeaker> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSpeaker", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSpeaker extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3v, create_fragment$3v, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSpeaker",
			options,
			id: create_fragment$3v.name
		});
	}

	get class() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSpeaker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSpeaker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSquare.svelte generated by Svelte v3.22.3 */
const file$3w = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSquare.svelte";

function create_fragment$3w(ctx) {
	let svg;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3w, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3w, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3w($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3w, create_fragment$3w, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSquare",
			options,
			id: create_fragment$3w.name
		});
	}

	get class() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconStar.svelte generated by Svelte v3.22.3 */
const file$3x = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconStar.svelte";

function create_fragment$3x(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91\n        8.26 12 2");
			add_location(polygon, file$3x, 39, 4, 917);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-star feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3x, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-star feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3x($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconStar> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconStar", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconStar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3x, create_fragment$3x, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconStar",
			options,
			id: create_fragment$3x.name
		});
	}

	get class() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconStar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconStar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconStopCircle.svelte generated by Svelte v3.22.3 */
const file$3y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconStopCircle.svelte";

function create_fragment$3y(ctx) {
	let svg;
	let circle;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			rect = svg_element("rect");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3y, 39, 4, 924);
			attr_dev(rect, "x", "9");
			attr_dev(rect, "y", "9");
			attr_dev(rect, "width", "6");
			attr_dev(rect, "height", "6");
			add_location(rect, file$3y, 40, 4, 962);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-stop-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, rect);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-stop-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconStopCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconStopCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconStopCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3y, create_fragment$3y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconStopCircle",
			options,
			id: create_fragment$3y.name
		});
	}

	get class() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconStopCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconStopCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSun.svelte generated by Svelte v3.22.3 */
const file$3z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSun.svelte";

function create_fragment$3z(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "5");
			add_location(circle, file$3z, 39, 4, 916);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "3");
			add_location(line0, file$3z, 40, 4, 953);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "23");
			add_location(line1, file$3z, 41, 4, 996);
			attr_dev(line2, "x1", "4.22");
			attr_dev(line2, "y1", "4.22");
			attr_dev(line2, "x2", "5.64");
			attr_dev(line2, "y2", "5.64");
			add_location(line2, file$3z, 42, 4, 1041);
			attr_dev(line3, "x1", "18.36");
			attr_dev(line3, "y1", "18.36");
			attr_dev(line3, "x2", "19.78");
			attr_dev(line3, "y2", "19.78");
			add_location(line3, file$3z, 43, 4, 1094);
			attr_dev(line4, "x1", "1");
			attr_dev(line4, "y1", "12");
			attr_dev(line4, "x2", "3");
			attr_dev(line4, "y2", "12");
			add_location(line4, file$3z, 44, 4, 1151);
			attr_dev(line5, "x1", "21");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "23");
			attr_dev(line5, "y2", "12");
			add_location(line5, file$3z, 45, 4, 1194);
			attr_dev(line6, "x1", "4.22");
			attr_dev(line6, "y1", "19.78");
			attr_dev(line6, "x2", "5.64");
			attr_dev(line6, "y2", "18.36");
			add_location(line6, file$3z, 46, 4, 1239);
			attr_dev(line7, "x1", "18.36");
			attr_dev(line7, "y1", "5.64");
			attr_dev(line7, "x2", "19.78");
			attr_dev(line7, "y2", "4.22");
			add_location(line7, file$3z, 47, 4, 1294);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-sun feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, line6);
			append_dev(svg, line7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-sun feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSun> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSun", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSun extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3z, create_fragment$3z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSun",
			options,
			id: create_fragment$3z.name
		});
	}

	get class() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSun>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSun>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSunrise.svelte generated by Svelte v3.22.3 */
const file$3A = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSunrise.svelte";

function create_fragment$3A(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
			add_location(path, file$3A, 39, 4, 920);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$3A, 40, 4, 959);
			attr_dev(line1, "x1", "4.22");
			attr_dev(line1, "y1", "10.22");
			attr_dev(line1, "x2", "5.64");
			attr_dev(line1, "y2", "11.64");
			add_location(line1, file$3A, 41, 4, 1002);
			attr_dev(line2, "x1", "1");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$3A, 42, 4, 1057);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "23");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$3A, 43, 4, 1100);
			attr_dev(line4, "x1", "18.36");
			attr_dev(line4, "y1", "11.64");
			attr_dev(line4, "x2", "19.78");
			attr_dev(line4, "y2", "10.22");
			add_location(line4, file$3A, 44, 4, 1145);
			attr_dev(line5, "x1", "23");
			attr_dev(line5, "y1", "22");
			attr_dev(line5, "x2", "1");
			attr_dev(line5, "y2", "22");
			add_location(line5, file$3A, 45, 4, 1202);
			attr_dev(polyline, "points", "8 6 12 2 16 6");
			add_location(polyline, file$3A, 46, 4, 1246);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-sunrise feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3A, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-sunrise feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3A($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSunrise> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSunrise", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSunrise extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3A, create_fragment$3A, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSunrise",
			options,
			id: create_fragment$3A.name
		});
	}

	get class() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSunrise>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSunrise>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSunset.svelte generated by Svelte v3.22.3 */
const file$3B = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconSunset.svelte";

function create_fragment$3B(ctx) {
	let svg;
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
			add_location(path, file$3B, 39, 4, 919);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "2");
			add_location(line0, file$3B, 40, 4, 958);
			attr_dev(line1, "x1", "4.22");
			attr_dev(line1, "y1", "10.22");
			attr_dev(line1, "x2", "5.64");
			attr_dev(line1, "y2", "11.64");
			add_location(line1, file$3B, 41, 4, 1001);
			attr_dev(line2, "x1", "1");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$3B, 42, 4, 1056);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "23");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$3B, 43, 4, 1099);
			attr_dev(line4, "x1", "18.36");
			attr_dev(line4, "y1", "11.64");
			attr_dev(line4, "x2", "19.78");
			attr_dev(line4, "y2", "10.22");
			add_location(line4, file$3B, 44, 4, 1144);
			attr_dev(line5, "x1", "23");
			attr_dev(line5, "y1", "22");
			attr_dev(line5, "x2", "1");
			attr_dev(line5, "y2", "22");
			add_location(line5, file$3B, 45, 4, 1201);
			attr_dev(polyline, "points", "16 5 12 9 8 5");
			add_location(polyline, file$3B, 46, 4, 1245);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-sunset feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3B, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
			append_dev(svg, line3);
			append_dev(svg, line4);
			append_dev(svg, line5);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-sunset feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3B($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconSunset> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconSunset", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconSunset extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3B, create_fragment$3B, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconSunset",
			options,
			id: create_fragment$3B.name
		});
	}

	get class() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconSunset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconSunset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTablet.svelte generated by Svelte v3.22.3 */
const file$3C = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTablet.svelte";

function create_fragment$3C(ctx) {
	let svg;
	let rect;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line = svg_element("line");
			attr_dev(rect, "x", "4");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "16");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3C, 39, 4, 919);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "18");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "18");
			add_location(line, file$3C, 40, 4, 981);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-tablet feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3C, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-tablet feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3C($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTablet> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTablet", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTablet extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3C, create_fragment$3C, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTablet",
			options,
			id: create_fragment$3C.name
		});
	}

	get class() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTablet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTablet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTag.svelte generated by Svelte v3.22.3 */
const file$3D = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTag.svelte";

function create_fragment$3D(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z");
			add_location(path, file$3D, 39, 4, 916);
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "7.01");
			attr_dev(line, "y2", "7");
			add_location(line, file$3D, 40, 4, 1012);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-tag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3D, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-tag feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3D($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTag> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTag", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTag extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3D, create_fragment$3D, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTag",
			options,
			id: create_fragment$3D.name
		});
	}

	get class() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTarget.svelte generated by Svelte v3.22.3 */
const file$3E = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTarget.svelte";

function create_fragment$3E(ctx) {
	let svg;
	let circle0;
	let circle1;
	let circle2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$3E, 39, 4, 919);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "6");
			add_location(circle1, file$3E, 40, 4, 957);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "2");
			add_location(circle2, file$3E, 41, 4, 994);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-target feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3E, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, circle2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-target feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3E($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTarget> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTarget", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTarget extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3E, create_fragment$3E, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTarget",
			options,
			id: create_fragment$3E.name
		});
	}

	get class() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTerminal.svelte generated by Svelte v3.22.3 */
const file$3F = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTerminal.svelte";

function create_fragment$3F(ctx) {
	let svg;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(polyline, "points", "4 17 10 11 4 5");
			add_location(polyline, file$3F, 39, 4, 921);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "20");
			attr_dev(line, "y2", "19");
			add_location(line, file$3F, 40, 4, 962);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-terminal feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3F, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-terminal feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3F($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTerminal> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTerminal", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTerminal extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3F, create_fragment$3F, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTerminal",
			options,
			id: create_fragment$3F.name
		});
	}

	get class() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTerminal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTerminal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThermometer.svelte generated by Svelte v3.22.3 */
const file$3G = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThermometer.svelte";

function create_fragment$3G(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z");
			add_location(path, file$3G, 39, 4, 924);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-thermometer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3G, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-thermometer feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3G($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconThermometer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconThermometer", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconThermometer extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3G, create_fragment$3G, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconThermometer",
			options,
			id: create_fragment$3G.name
		});
	}

	get class() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconThermometer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconThermometer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThumbsDown.svelte generated by Svelte v3.22.3 */
const file$3H = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThumbsDown.svelte";

function create_fragment$3H(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31\n        2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17");
			add_location(path, file$3H, 39, 4, 924);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-thumbs-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3H, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-thumbs-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3H($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconThumbsDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconThumbsDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconThumbsDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3H, create_fragment$3H, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconThumbsDown",
			options,
			id: create_fragment$3H.name
		});
	}

	get class() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconThumbsDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconThumbsDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThumbsUp.svelte generated by Svelte v3.22.3 */
const file$3I = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconThumbsUp.svelte";

function create_fragment$3I(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0\n        0 1-2-2v-7a2 2 0 0 1 2-2h3");
			add_location(path, file$3I, 39, 4, 922);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-thumbs-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3I, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-thumbs-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3I($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconThumbsUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconThumbsUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconThumbsUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3I, create_fragment$3I, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconThumbsUp",
			options,
			id: create_fragment$3I.name
		});
	}

	get class() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconThumbsUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconThumbsUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconToggleLeft.svelte generated by Svelte v3.22.3 */
const file$3J = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconToggleLeft.svelte";

function create_fragment$3J(ctx) {
	let svg;
	let rect;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle = svg_element("circle");
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "7");
			attr_dev(rect, "ry", "7");
			add_location(rect, file$3J, 39, 4, 924);
			attr_dev(circle, "cx", "8");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$3J, 40, 4, 986);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-toggle-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3J, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-toggle-left feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3J($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconToggleLeft> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconToggleLeft", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconToggleLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3J, create_fragment$3J, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconToggleLeft",
			options,
			id: create_fragment$3J.name
		});
	}

	get class() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconToggleLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconToggleLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconToggleRight.svelte generated by Svelte v3.22.3 */
const file$3K = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconToggleRight.svelte";

function create_fragment$3K(ctx) {
	let svg;
	let rect;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			circle = svg_element("circle");
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "7");
			attr_dev(rect, "ry", "7");
			add_location(rect, file$3K, 39, 4, 925);
			attr_dev(circle, "cx", "16");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$3K, 40, 4, 987);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-toggle-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3K, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-toggle-right feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3K($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconToggleRight> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconToggleRight", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconToggleRight extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3K, create_fragment$3K, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconToggleRight",
			options,
			id: create_fragment$3K.name
		});
	}

	get class() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconToggleRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconToggleRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTool.svelte generated by Svelte v3.22.3 */
const file$3L = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTool.svelte";

function create_fragment$3L(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91\n        6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z");
			add_location(path, file$3L, 39, 4, 917);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-tool feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3L, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-tool feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3L($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTool> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTool", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTool extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3L, create_fragment$3L, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTool",
			options,
			id: create_fragment$3L.name
		});
	}

	get class() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTool>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTool>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrash2.svelte generated by Svelte v3.22.3 */
const file$3M = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrash2.svelte";

function create_fragment$3M(ctx) {
	let svg;
	let polyline;
	let path;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polyline, "points", "3 6 5 6 21 6");
			add_location(polyline, file$3M, 39, 4, 920);
			attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			add_location(path, file$3M, 40, 4, 959);
			attr_dev(line0, "x1", "10");
			attr_dev(line0, "y1", "11");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "17");
			add_location(line0, file$3M, 41, 4, 1055);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$3M, 42, 4, 1100);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-trash-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3M, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-trash-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3M($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTrash2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTrash2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTrash2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3M, create_fragment$3M, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTrash2",
			options,
			id: create_fragment$3M.name
		});
	}

	get class() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTrash2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTrash2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrash.svelte generated by Svelte v3.22.3 */
const file$3N = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrash.svelte";

function create_fragment$3N(ctx) {
	let svg;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(polyline, "points", "3 6 5 6 21 6");
			add_location(polyline, file$3N, 39, 4, 918);
			attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			add_location(path, file$3N, 40, 4, 957);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-trash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3N, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-trash feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3N($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTrash> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTrash", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTrash extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3N, create_fragment$3N, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTrash",
			options,
			id: create_fragment$3N.name
		});
	}

	get class() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTrash>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTrash>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrello.svelte generated by Svelte v3.22.3 */
const file$3O = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrello.svelte";

function create_fragment$3O(ctx) {
	let svg;
	let rect0;
	let rect1;
	let rect2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			attr_dev(rect0, "x", "3");
			attr_dev(rect0, "y", "3");
			attr_dev(rect0, "width", "18");
			attr_dev(rect0, "height", "18");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$3O, 39, 4, 919);
			attr_dev(rect1, "x", "7");
			attr_dev(rect1, "y", "7");
			attr_dev(rect1, "width", "3");
			attr_dev(rect1, "height", "9");
			add_location(rect1, file$3O, 40, 4, 981);
			attr_dev(rect2, "x", "14");
			attr_dev(rect2, "y", "7");
			attr_dev(rect2, "width", "3");
			attr_dev(rect2, "height", "5");
			add_location(rect2, file$3O, 41, 4, 1027);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-trello feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3O, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect0);
			append_dev(svg, rect1);
			append_dev(svg, rect2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-trello feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3O($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTrello> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTrello", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTrello extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3O, create_fragment$3O, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTrello",
			options,
			id: create_fragment$3O.name
		});
	}

	get class() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTrello>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTrello>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrendingDown.svelte generated by Svelte v3.22.3 */
const file$3P = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrendingDown.svelte";

function create_fragment$3P(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "23 18 13.5 8.5 8.5 13.5 1 6");
			add_location(polyline0, file$3P, 39, 4, 926);
			attr_dev(polyline1, "points", "17 18 23 18 23 12");
			add_location(polyline1, file$3P, 40, 4, 980);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-trending-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3P, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-trending-down feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3P($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTrendingDown> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTrendingDown", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTrendingDown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3P, create_fragment$3P, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTrendingDown",
			options,
			id: create_fragment$3P.name
		});
	}

	get class() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTrendingDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTrendingDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrendingUp.svelte generated by Svelte v3.22.3 */
const file$3Q = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTrendingUp.svelte";

function create_fragment$3Q(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "23 6 13.5 15.5 8.5 10.5 1 18");
			add_location(polyline0, file$3Q, 39, 4, 924);
			attr_dev(polyline1, "points", "17 6 23 6 23 12");
			add_location(polyline1, file$3Q, 40, 4, 979);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-trending-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3Q, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-trending-up feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Q($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTrendingUp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTrendingUp", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTrendingUp extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3Q, create_fragment$3Q, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTrendingUp",
			options,
			id: create_fragment$3Q.name
		});
	}

	get class() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTrendingUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTrendingUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTriangle.svelte generated by Svelte v3.22.3 */
const file$3R = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTriangle.svelte";

function create_fragment$3R(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
			add_location(path, file$3R, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-triangle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3R, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-triangle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3R($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTriangle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTriangle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTriangle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3R, create_fragment$3R, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTriangle",
			options,
			id: create_fragment$3R.name
		});
	}

	get class() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTriangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTriangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTruck.svelte generated by Svelte v3.22.3 */
const file$3S = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTruck.svelte";

function create_fragment$3S(ctx) {
	let svg;
	let rect;
	let polygon;
	let circle0;
	let circle1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			polygon = svg_element("polygon");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "15");
			attr_dev(rect, "height", "13");
			add_location(rect, file$3S, 39, 4, 918);
			attr_dev(polygon, "points", "16 8 20 8 23 11 23 16 16 16 16 8");
			add_location(polygon, file$3S, 40, 4, 966);
			attr_dev(circle0, "cx", "5.5");
			attr_dev(circle0, "cy", "18.5");
			attr_dev(circle0, "r", "2.5");
			add_location(circle0, file$3S, 41, 4, 1024);
			attr_dev(circle1, "cx", "18.5");
			attr_dev(circle1, "cy", "18.5");
			attr_dev(circle1, "r", "2.5");
			add_location(circle1, file$3S, 42, 4, 1066);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-truck feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3S, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, polygon);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-truck feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3S($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTruck> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTruck", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTruck extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3S, create_fragment$3S, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTruck",
			options,
			id: create_fragment$3S.name
		});
	}

	get class() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTruck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTruck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTv.svelte generated by Svelte v3.22.3 */
const file$3T = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTv.svelte";

function create_fragment$3T(ctx) {
	let svg;
	let rect;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "15");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3T, 39, 4, 915);
			attr_dev(polyline, "points", "17 2 12 7 7 2");
			add_location(polyline, file$3T, 40, 4, 977);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-tv feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3T, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-tv feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3T($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTv> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTv", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTv extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3T, create_fragment$3T, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTv",
			options,
			id: create_fragment$3T.name
		});
	}

	get class() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTwitch.svelte generated by Svelte v3.22.3 */
const file$3U = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTwitch.svelte";

function create_fragment$3U(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7");
			add_location(path, file$3U, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-twitch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3U, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-twitch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3U($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTwitch> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTwitch", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTwitch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3U, create_fragment$3U, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTwitch",
			options,
			id: create_fragment$3U.name
		});
	}

	get class() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTwitter.svelte generated by Svelte v3.22.3 */
const file$3V = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconTwitter.svelte";

function create_fragment$3V(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5\n        13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z");
			add_location(path, file$3V, 39, 4, 920);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-twitter feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3V, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-twitter feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3V($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconTwitter> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconTwitter", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconTwitter extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3V, create_fragment$3V, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconTwitter",
			options,
			id: create_fragment$3V.name
		});
	}

	get class() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconTwitter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconTwitter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconType.svelte generated by Svelte v3.22.3 */
const file$3W = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconType.svelte";

function create_fragment$3W(ctx) {
	let svg;
	let polyline;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polyline, "points", "4 7 4 4 20 4 20 7");
			add_location(polyline, file$3W, 39, 4, 917);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "15");
			attr_dev(line0, "y2", "20");
			add_location(line0, file$3W, 40, 4, 961);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "4");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$3W, 41, 4, 1005);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-type feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3W, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-type feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3W($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconType> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconType", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconType extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3W, create_fragment$3W, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconType",
			options,
			id: create_fragment$3W.name
		});
	}

	get class() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconType>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconType>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUmbrella.svelte generated by Svelte v3.22.3 */
const file$3X = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUmbrella.svelte";

function create_fragment$3X(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7");
			add_location(path, file$3X, 39, 4, 921);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-umbrella feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3X, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-umbrella feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3X($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUmbrella> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUmbrella", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUmbrella extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3X, create_fragment$3X, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUmbrella",
			options,
			id: create_fragment$3X.name
		});
	}

	get class() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUmbrella>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUmbrella>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUnderline.svelte generated by Svelte v3.22.3 */
const file$3Y = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUnderline.svelte";

function create_fragment$3Y(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3");
			add_location(path, file$3Y, 39, 4, 922);
			attr_dev(line, "x1", "4");
			attr_dev(line, "y1", "21");
			attr_dev(line, "x2", "20");
			attr_dev(line, "y2", "21");
			add_location(line, file$3Y, 40, 4, 976);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-underline feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3Y, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-underline feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Y($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUnderline> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUnderline", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUnderline extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3Y, create_fragment$3Y, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUnderline",
			options,
			id: create_fragment$3Y.name
		});
	}

	get class() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUnderline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUnderline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUnlock.svelte generated by Svelte v3.22.3 */
const file$3Z = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUnlock.svelte";

function create_fragment$3Z(ctx) {
	let svg;
	let rect;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			path = svg_element("path");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "11");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "11");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3Z, 39, 4, 919);
			attr_dev(path, "d", "M7 11V7a5 5 0 0 1 9.9-1");
			add_location(path, file$3Z, 40, 4, 982);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-unlock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3Z, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-unlock feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Z($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUnlock> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUnlock", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUnlock extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3Z, create_fragment$3Z, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUnlock",
			options,
			id: create_fragment$3Z.name
		});
	}

	get class() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUnlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUnlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUploadCloud.svelte generated by Svelte v3.22.3 */
const file$3_ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUploadCloud.svelte";

function create_fragment$3_(ctx) {
	let svg;
	let polyline0;
	let line;
	let path;
	let polyline1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			polyline1 = svg_element("polyline");
			attr_dev(polyline0, "points", "16 16 12 12 8 16");
			add_location(polyline0, file$3_, 39, 4, 925);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "21");
			add_location(line, file$3_, 40, 4, 968);
			attr_dev(path, "d", "M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3");
			add_location(path, file$3_, 41, 4, 1013);
			attr_dev(polyline1, "points", "16 16 12 12 8 16");
			add_location(polyline1, file$3_, 42, 4, 1081);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-upload-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3_, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, line);
			append_dev(svg, path);
			append_dev(svg, polyline1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-upload-cloud feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3_($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUploadCloud> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUploadCloud", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUploadCloud extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3_, create_fragment$3_, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUploadCloud",
			options,
			id: create_fragment$3_.name
		});
	}

	get class() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUploadCloud>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUploadCloud>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUpload.svelte generated by Svelte v3.22.3 */
const file$3$ = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUpload.svelte";

function create_fragment$3$(ctx) {
	let svg;
	let path;
	let polyline;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
			add_location(path, file$3$, 39, 4, 919);
			attr_dev(polyline, "points", "17 8 12 3 7 8");
			add_location(polyline, file$3$, 40, 4, 978);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "15");
			add_location(line, file$3$, 41, 4, 1018);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-upload feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$3$, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polyline);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-upload feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3$($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUpload> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUpload", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3$, create_fragment$3$, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUpload",
			options,
			id: create_fragment$3$.name
		});
	}

	get class() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserCheck.svelte generated by Svelte v3.22.3 */
const file$40 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserCheck.svelte";

function create_fragment$40(ctx) {
	let svg;
	let path;
	let circle;
	let polyline;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$40, 39, 4, 923);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$40, 40, 4, 982);
			attr_dev(polyline, "points", "17 11 19 13 23 9");
			add_location(polyline, file$40, 41, 4, 1019);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-user-check feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$40, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
			append_dev(svg, polyline);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-user-check feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$40.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$40($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUserCheck> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUserCheck", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUserCheck extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$40, create_fragment$40, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUserCheck",
			options,
			id: create_fragment$40.name
		});
	}

	get class() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUserCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUserCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserMinus.svelte generated by Svelte v3.22.3 */
const file$41 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserMinus.svelte";

function create_fragment$41(ctx) {
	let svg;
	let path;
	let circle;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			line = svg_element("line");
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$41, 39, 4, 923);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$41, 40, 4, 982);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "11");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "11");
			add_location(line, file$41, 41, 4, 1019);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-user-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$41, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-user-minus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$41.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$41($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUserMinus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUserMinus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUserMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$41, create_fragment$41, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUserMinus",
			options,
			id: create_fragment$41.name
		});
	}

	get class() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUserMinus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUserMinus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserPlus.svelte generated by Svelte v3.22.3 */
const file$42 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserPlus.svelte";

function create_fragment$42(ctx) {
	let svg;
	let path;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$42, 39, 4, 922);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$42, 40, 4, 981);
			attr_dev(line0, "x1", "20");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "20");
			attr_dev(line0, "y2", "14");
			add_location(line0, file$42, 41, 4, 1018);
			attr_dev(line1, "x1", "23");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "17");
			attr_dev(line1, "y2", "11");
			add_location(line1, file$42, 42, 4, 1062);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-user-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$42, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-user-plus feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$42.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$42($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUserPlus> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUserPlus", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUserPlus extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$42, create_fragment$42, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUserPlus",
			options,
			id: create_fragment$42.name
		});
	}

	get class() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserX.svelte generated by Svelte v3.22.3 */
const file$43 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUserX.svelte";

function create_fragment$43(ctx) {
	let svg;
	let path;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$43, 39, 4, 919);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$43, 40, 4, 978);
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "13");
			add_location(line0, file$43, 41, 4, 1015);
			attr_dev(line1, "x1", "23");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "13");
			add_location(line1, file$43, 42, 4, 1059);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-user-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$43, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-user-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$43.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$43($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUserX> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUserX", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUserX extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$43, create_fragment$43, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUserX",
			options,
			id: create_fragment$43.name
		});
	}

	get class() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUserX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUserX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUser.svelte generated by Svelte v3.22.3 */
const file$44 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUser.svelte";

function create_fragment$44(ctx) {
	let svg;
	let path;
	let circle;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			circle = svg_element("circle");
			attr_dev(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
			add_location(path, file$44, 39, 4, 917);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$44, 40, 4, 976);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-user feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$44, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, circle);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-user feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$44.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$44($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUser> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUser", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUser extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$44, create_fragment$44, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUser",
			options,
			id: create_fragment$44.name
		});
	}

	get class() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUsers.svelte generated by Svelte v3.22.3 */
const file$45 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconUsers.svelte";

function create_fragment$45(ctx) {
	let svg;
	let path0;
	let circle;
	let path1;
	let path2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			circle = svg_element("circle");
			path1 = svg_element("path");
			path2 = svg_element("path");
			attr_dev(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path0, file$45, 39, 4, 918);
			attr_dev(circle, "cx", "9");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$45, 40, 4, 977);
			attr_dev(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
			add_location(path1, file$45, 41, 4, 1012);
			attr_dev(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
			add_location(path2, file$45, 42, 4, 1056);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-users feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$45, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, circle);
			append_dev(svg, path1);
			append_dev(svg, path2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-users feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$45.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$45($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconUsers> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconUsers", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconUsers extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$45, create_fragment$45, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconUsers",
			options,
			id: create_fragment$45.name
		});
	}

	get class() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVideoOff.svelte generated by Svelte v3.22.3 */
const file$46 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVideoOff.svelte";

function create_fragment$46(ctx) {
	let svg;
	let path;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr_dev(path, "d", "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1\n        1L23 7v10");
			add_location(path, file$46, 39, 4, 922);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$46, 42, 4, 1053);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-video-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$46, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-video-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$46.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$46($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVideoOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVideoOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVideoOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$46, create_fragment$46, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVideoOff",
			options,
			id: create_fragment$46.name
		});
	}

	get class() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVideoOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVideoOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVideo.svelte generated by Svelte v3.22.3 */
const file$47 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVideo.svelte";

function create_fragment$47(ctx) {
	let svg;
	let polygon;
	let rect;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			rect = svg_element("rect");
			attr_dev(polygon, "points", "23 7 16 12 23 17 23 7");
			add_location(polygon, file$47, 39, 4, 918);
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "15");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$47, 40, 4, 965);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-video feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$47, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, rect);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-video feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$47.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$47($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVideo> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVideo", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVideo extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$47, create_fragment$47, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVideo",
			options,
			id: create_fragment$47.name
		});
	}

	get class() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVideo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVideo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVoicemail.svelte generated by Svelte v3.22.3 */
const file$48 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVoicemail.svelte";

function create_fragment$48(ctx) {
	let svg;
	let circle0;
	let circle1;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line = svg_element("line");
			attr_dev(circle0, "cx", "5.5");
			attr_dev(circle0, "cy", "11.5");
			attr_dev(circle0, "r", "4.5");
			add_location(circle0, file$48, 39, 4, 922);
			attr_dev(circle1, "cx", "18.5");
			attr_dev(circle1, "cy", "11.5");
			attr_dev(circle1, "r", "4.5");
			add_location(circle1, file$48, 40, 4, 964);
			attr_dev(line, "x1", "5.5");
			attr_dev(line, "y1", "16");
			attr_dev(line, "x2", "18.5");
			attr_dev(line, "y2", "16");
			add_location(line, file$48, 41, 4, 1007);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-voicemail feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$48, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle0);
			append_dev(svg, circle1);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-voicemail feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$48.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$48($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVoicemail> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVoicemail", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVoicemail extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$48, create_fragment$48, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVoicemail",
			options,
			id: create_fragment$48.name
		});
	}

	get class() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVoicemail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVoicemail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume1.svelte generated by Svelte v3.22.3 */
const file$49 = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume1.svelte";

function create_fragment$49(ctx) {
	let svg;
	let polygon;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			path = svg_element("path");
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$49, 39, 4, 921);
			attr_dev(path, "d", "M15.54 8.46a5 5 0 0 1 0 7.07");
			add_location(path, file$49, 40, 4, 980);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-volume-1 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$49, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-volume-1 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$49.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$49($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVolume1> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVolume1", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVolume1 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$49, create_fragment$49, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVolume1",
			options,
			id: create_fragment$49.name
		});
	}

	get class() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVolume1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVolume1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume2.svelte generated by Svelte v3.22.3 */
const file$4a = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume2.svelte";

function create_fragment$4a(ctx) {
	let svg;
	let polygon;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			path = svg_element("path");
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$4a, 39, 4, 921);
			attr_dev(path, "d", "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07");
			add_location(path, file$4a, 40, 4, 980);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-volume-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4a, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-volume-2 feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4a($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVolume2> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVolume2", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVolume2 extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4a, create_fragment$4a, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVolume2",
			options,
			id: create_fragment$4a.name
		});
	}

	get class() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVolume2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVolume2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolumeX.svelte generated by Svelte v3.22.3 */
const file$4b = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolumeX.svelte";

function create_fragment$4b(ctx) {
	let svg;
	let polygon;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$4b, 39, 4, 921);
			attr_dev(line0, "x1", "23");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "17");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$4b, 40, 4, 980);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "23");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$4b, 41, 4, 1024);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-volume-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4b, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-volume-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4b($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVolumeX> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVolumeX", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVolumeX extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4b, create_fragment$4b, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVolumeX",
			options,
			id: create_fragment$4b.name
		});
	}

	get class() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVolumeX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVolumeX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume.svelte generated by Svelte v3.22.3 */
const file$4c = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconVolume.svelte";

function create_fragment$4c(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$4c, 39, 4, 919);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-volume feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4c, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-volume feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4c($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconVolume> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconVolume", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconVolume extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4c, create_fragment$4c, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconVolume",
			options,
			id: create_fragment$4c.name
		});
	}

	get class() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconVolume>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconVolume>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWatch.svelte generated by Svelte v3.22.3 */
const file$4d = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWatch.svelte";

function create_fragment$4d(ctx) {
	let svg;
	let circle;
	let polyline;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			path = svg_element("path");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "7");
			add_location(circle, file$4d, 39, 4, 918);
			attr_dev(polyline, "points", "12 9 12 12 13.5 13.5");
			add_location(polyline, file$4d, 40, 4, 955);
			attr_dev(path, "d", "M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0\n        1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83");
			add_location(path, file$4d, 41, 4, 1002);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-watch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4d, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, polyline);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-watch feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4d($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconWatch> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconWatch", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconWatch extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4d, create_fragment$4d, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconWatch",
			options,
			id: create_fragment$4d.name
		});
	}

	get class() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconWatch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconWatch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWifiOff.svelte generated by Svelte v3.22.3 */
const file$4e = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWifiOff.svelte";

function create_fragment$4e(ctx) {
	let svg;
	let line0;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			line1 = svg_element("line");
			attr_dev(line0, "x1", "1");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$4e, 39, 4, 921);
			attr_dev(path0, "d", "M16.72 11.06A10.94 10.94 0 0 1 19 12.55");
			add_location(path0, file$4e, 40, 4, 964);
			attr_dev(path1, "d", "M5 12.55a10.94 10.94 0 0 1 5.17-2.39");
			add_location(path1, file$4e, 41, 4, 1021);
			attr_dev(path2, "d", "M10.71 5.05A16 16 0 0 1 22.58 9");
			add_location(path2, file$4e, 42, 4, 1075);
			attr_dev(path3, "d", "M1.42 9a15.91 15.91 0 0 1 4.7-2.88");
			add_location(path3, file$4e, 43, 4, 1124);
			attr_dev(path4, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
			add_location(path4, file$4e, 44, 4, 1176);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$4e, 45, 4, 1222);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-wifi-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4e, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, path3);
			append_dev(svg, path4);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-wifi-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4e($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconWifiOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconWifiOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconWifiOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4e, create_fragment$4e, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconWifiOff",
			options,
			id: create_fragment$4e.name
		});
	}

	get class() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconWifiOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconWifiOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWifi.svelte generated by Svelte v3.22.3 */
const file$4f = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWifi.svelte";

function create_fragment$4f(ctx) {
	let svg;
	let path0;
	let path1;
	let path2;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			line = svg_element("line");
			attr_dev(path0, "d", "M5 12.55a11 11 0 0 1 14.08 0");
			add_location(path0, file$4f, 39, 4, 917);
			attr_dev(path1, "d", "M1.42 9a16 16 0 0 1 21.16 0");
			add_location(path1, file$4f, 40, 4, 963);
			attr_dev(path2, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
			add_location(path2, file$4f, 41, 4, 1008);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "20");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "20");
			add_location(line, file$4f, 42, 4, 1054);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-wifi feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4f, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path0);
			append_dev(svg, path1);
			append_dev(svg, path2);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-wifi feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4f($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconWifi> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconWifi", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconWifi extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4f, create_fragment$4f, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconWifi",
			options,
			id: create_fragment$4f.name
		});
	}

	get class() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconWifi>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconWifi>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWind.svelte generated by Svelte v3.22.3 */
const file$4g = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconWind.svelte";

function create_fragment$4g(ctx) {
	let svg;
	let path;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5\n        12H2");
			add_location(path, file$4g, 39, 4, 917);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-wind feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4g, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-wind feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4g($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconWind> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconWind", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconWind extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4g, create_fragment$4g, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconWind",
			options,
			id: create_fragment$4g.name
		});
	}

	get class() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconWind>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconWind>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXCircle.svelte generated by Svelte v3.22.3 */
const file$4h = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXCircle.svelte";

function create_fragment$4h(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$4h, 39, 4, 921);
			attr_dev(line0, "x1", "15");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$4h, 40, 4, 959);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$4h, 41, 4, 1002);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-x-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4h, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-x-circle feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4h($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconXCircle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconXCircle", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconXCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4h, create_fragment$4h, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconXCircle",
			options,
			id: create_fragment$4h.name
		});
	}

	get class() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconXCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconXCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXOctagon.svelte generated by Svelte v3.22.3 */
const file$4i = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXOctagon.svelte";

function create_fragment$4i(ctx) {
	let svg;
	let polygon;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$4i, 39, 4, 922);
			attr_dev(line0, "x1", "15");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$4i, 40, 4, 1018);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$4i, 41, 4, 1061);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-x-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4i, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-x-octagon feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4i($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconXOctagon> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconXOctagon", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconXOctagon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4i, create_fragment$4i, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconXOctagon",
			options,
			id: create_fragment$4i.name
		});
	}

	get class() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconXOctagon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconXOctagon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXSquare.svelte generated by Svelte v3.22.3 */
const file$4j = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconXSquare.svelte";

function create_fragment$4j(ctx) {
	let svg;
	let rect;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$4j, 39, 4, 921);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "15");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$4j, 40, 4, 983);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$4j, 41, 4, 1026);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-x-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4j, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, rect);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-x-square feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4j($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconXSquare> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconXSquare", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconXSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4j, create_fragment$4j, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconXSquare",
			options,
			id: create_fragment$4j.name
		});
	}

	get class() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconXSquare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconXSquare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconX.svelte generated by Svelte v3.22.3 */
const file$4k = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconX.svelte";

function create_fragment$4k(ctx) {
	let svg;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$4k, 39, 4, 914);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$4k, 40, 4, 957);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4k, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-x feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4k($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconX> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconX", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconX extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4k, create_fragment$4k, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconX",
			options,
			id: create_fragment$4k.name
		});
	}

	get class() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconYoutube.svelte generated by Svelte v3.22.3 */
const file$4l = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconYoutube.svelte";

function create_fragment$4l(ctx) {
	let svg;
	let path;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			polygon = svg_element("polygon");
			attr_dev(path, "d", "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94\n        2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88\n        0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z");
			add_location(path, file$4l, 39, 4, 920);
			attr_dev(polygon, "points", "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02");
			add_location(polygon, file$4l, 43, 4, 1219);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-youtube feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4l, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-youtube feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4l($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconYoutube> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconYoutube", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconYoutube extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4l, create_fragment$4l, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconYoutube",
			options,
			id: create_fragment$4l.name
		});
	}

	get class() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconYoutube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconYoutube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZapOff.svelte generated by Svelte v3.22.3 */
const file$4m = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZapOff.svelte";

function create_fragment$4m(ctx) {
	let svg;
	let polyline0;
	let polyline1;
	let polyline2;
	let line;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			line = svg_element("line");
			attr_dev(polyline0, "points", "12.41 6.75 13 2 10.57 4.92");
			add_location(polyline0, file$4m, 39, 4, 920);
			attr_dev(polyline1, "points", "18.57 12.91 21 10 15.66 10");
			add_location(polyline1, file$4m, 40, 4, 973);
			attr_dev(polyline2, "points", "8 8 3 14 12 14 11 22 16 16");
			add_location(polyline2, file$4m, 41, 4, 1026);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$4m, 42, 4, 1079);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-zap-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4m, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polyline0);
			append_dev(svg, polyline1);
			append_dev(svg, polyline2);
			append_dev(svg, line);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-zap-off feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4m($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconZapOff> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconZapOff", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconZapOff extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4m, create_fragment$4m, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconZapOff",
			options,
			id: create_fragment$4m.name
		});
	}

	get class() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconZapOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconZapOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZap.svelte generated by Svelte v3.22.3 */
const file$4n = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZap.svelte";

function create_fragment$4n(ctx) {
	let svg;
	let polygon;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			polygon = svg_element("polygon");
			attr_dev(polygon, "points", "13 2 3 14 12 14 11 22 21 10 12 10 13 2");
			add_location(polygon, file$4n, 39, 4, 916);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-zap feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4n, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, polygon);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-zap feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4n($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconZap> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconZap", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconZap extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4n, create_fragment$4n, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconZap",
			options,
			id: create_fragment$4n.name
		});
	}

	get class() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconZap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconZap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZoomIn.svelte generated by Svelte v3.22.3 */
const file$4o = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZoomIn.svelte";

function create_fragment$4o(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let line2;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$4o, 39, 4, 920);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16.65");
			attr_dev(line0, "y2", "16.65");
			add_location(line0, file$4o, 40, 4, 957);
			attr_dev(line1, "x1", "11");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "11");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$4o, 41, 4, 1008);
			attr_dev(line2, "x1", "8");
			attr_dev(line2, "y1", "11");
			attr_dev(line2, "x2", "14");
			attr_dev(line2, "y2", "11");
			add_location(line2, file$4o, 42, 4, 1052);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-zoom-in feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4o, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
			append_dev(svg, line2);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-zoom-in feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4o($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconZoomIn> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconZoomIn", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconZoomIn extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4o, create_fragment$4o, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconZoomIn",
			options,
			id: create_fragment$4o.name
		});
	}

	get class() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconZoomIn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconZoomIn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZoomOut.svelte generated by Svelte v3.22.3 */
const file$4p = "home/novacbn/workspace/novacbn/svelte-feather/lib/components/IconZoomOut.svelte";

function create_fragment$4p(ctx) {
	let svg;
	let circle;
	let line0;
	let line1;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$4p, 39, 4, 921);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16.65");
			attr_dev(line0, "y2", "16.65");
			add_location(line0, file$4p, 40, 4, 958);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "11");
			add_location(line1, file$4p, 41, 4, 1009);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "class", svg_class_value = "feather feather-zoom-out feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0]);
			attr_dev(svg, "width", /*font_size*/ ctx[8]);
			attr_dev(svg, "height", /*font_size*/ ctx[8]);
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", /*fill*/ ctx[4]);
			attr_dev(svg, "stroke", /*color*/ ctx[2]);
			attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			attr_dev(svg, "style", /*style*/ ctx[1]);
			add_location(svg, file$4p, 26, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, circle);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*size, _class*/ 9 && svg_class_value !== (svg_class_value = "feather feather-zoom-out feather-size-" + /*size*/ ctx[3] + "\n    " + /*_class*/ ctx[0])) {
				attr_dev(svg, "class", svg_class_value);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "width", /*font_size*/ ctx[8]);
			}

			if (dirty & /*font_size*/ 256) {
				attr_dev(svg, "height", /*font_size*/ ctx[8]);
			}

			if (dirty & /*fill*/ 16) {
				attr_dev(svg, "fill", /*fill*/ ctx[4]);
			}

			if (dirty & /*color*/ 4) {
				attr_dev(svg, "stroke", /*color*/ ctx[2]);
			}

			if (dirty & /*width*/ 128) {
				attr_dev(svg, "stroke-width", /*width*/ ctx[7]);
			}

			if (dirty & /*linecap*/ 32) {
				attr_dev(svg, "stroke-linecap", /*linecap*/ ctx[5]);
			}

			if (dirty & /*linejoin*/ 64) {
				attr_dev(svg, "stroke-linejoin", /*linejoin*/ ctx[6]);
			}

			if (dirty & /*style*/ 2) {
				attr_dev(svg, "style", /*style*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4p($$self, $$props, $$invalidate) {
	let { class: _class = "" } = $$props;
	let { style = "" } = $$props;
	let { color = "currentColor" } = $$props;
	let { size = ICON_SIZES.default } = $$props;
	let { fill = "none" } = $$props;
	let { linecap = "round" } = $$props;
	let { linejoin = "round" } = $$props;
	let { width = "2" } = $$props;
	let font_size;
	const writable_props = ["class", "style", "color", "size", "fill", "linecap", "linejoin", "width"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconZoomOut> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconZoomOut", $$slots, []);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, _class = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		ICON_SIZES,
		ICON_SIZE_UNITS,
		is_size_primitive,
		_class,
		style,
		color,
		size,
		fill,
		linecap,
		linejoin,
		width,
		font_size
	});

	$$self.$inject_state = $$props => {
		if ("_class" in $$props) $$invalidate(0, _class = $$props._class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("size" in $$props) $$invalidate(3, size = $$props.size);
		if ("fill" in $$props) $$invalidate(4, fill = $$props.fill);
		if ("linecap" in $$props) $$invalidate(5, linecap = $$props.linecap);
		if ("linejoin" in $$props) $$invalidate(6, linejoin = $$props.linejoin);
		if ("width" in $$props) $$invalidate(7, width = $$props.width);
		if ("font_size" in $$props) $$invalidate(8, font_size = $$props.font_size);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 8) {
			 {
				if (is_size_primitive(size)) {
					$$invalidate(8, font_size = size);
				} else {
					$$invalidate(8, font_size = ICON_SIZE_UNITS[size] || ICON_SIZE_UNITS[ICON_SIZES.default]);
				}
			}
		}
	};

	return [_class, style, color, size, fill, linecap, linejoin, width, font_size];
}

class IconZoomOut extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$4p, create_fragment$4p, safe_not_equal, {
			class: 0,
			style: 1,
			color: 2,
			size: 3,
			fill: 4,
			linecap: 5,
			linejoin: 6,
			width: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconZoomOut",
			options,
			id: create_fragment$4p.name
		});
	}

	get class() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get color() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set color(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linecap() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linecap(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linejoin() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linejoin(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<IconZoomOut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<IconZoomOut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { ICON_SIZES, ICON_SIZE_UNITS, IconActivity, IconAirplay, IconAlertCircle, IconAlertOctagon, IconAlertTriangle, IconAlignCenter, IconAlignJustify, IconAlignLeft, IconAlignRight, IconAnchor, IconAperture, IconArchive, IconArrowDown, IconArrowDownCircle, IconArrowDownLeft, IconArrowDownRight, IconArrowLeft, IconArrowLeftCircle, IconArrowRight, IconArrowRightCircle, IconArrowUp, IconArrowUpCircle, IconArrowUpLeft, IconArrowUpRight, IconAtSign, IconAward, IconBarChart, IconBarChart2, IconBattery, IconBatteryCharging, IconBell, IconBellOff, IconBluetooth, IconBold, IconBook, IconBookOpen, IconBookmark, IconBox, IconBriefcase, IconCalendar, IconCamera, IconCameraOff, IconCast, IconCheck, IconCheckCircle, IconCheckSquare, IconChevronDown, IconChevronLeft, IconChevronRight, IconChevronUp, IconChevronsDown, IconChevronsLeft, IconChevronsRight, IconChevronsUp, IconChrome, IconCircle, IconClipboard, IconClock, IconCloud, IconCloudDrizzle, IconCloudLightning, IconCloudOff, IconCloudRain, IconCloudSnow, IconCode, IconCodepen, IconCodesandbox, IconCoffee, IconColumns, IconCommand, IconCompass, IconCopy, IconCornerDownLeft, IconCornerDownRight, IconCornerLeftDown, IconCornerLeftUp, IconCornerRightDown, IconCornerRightUp, IconCornerUpLeft, IconCornerUpRight, IconCpu, IconCreditCard, IconCrop, IconCrosshair, IconDatabase, IconDelete, IconDisc, IconDollarSign, IconDownload, IconDownloadCloud, IconDroplet, IconEdit, IconEdit2, IconEdit3, IconExternalLink, IconEye, IconEyeOff, IconFacebook, IconFastForward, IconFeather, IconFigma, IconFile, IconFileMinus, IconFilePlus, IconFileText, IconFilm, IconFilter, IconFlag, IconFolder, IconFolderMinus, IconFolderPlus, IconFramer, IconFrown, IconGift, IconGitBranch, IconGitCommit, IconGitMerge, IconGitPullRequest, IconGithub, IconGitlab, IconGlobe, IconGrid, IconHardDrive, IconHash, IconHeadphones, IconHeart, IconHelpCircle, IconHexagon, IconHome, IconImage, IconInbox, IconInfo, IconInstagram, IconItalic, IconKey, IconLayers, IconLayout, IconLifeBuoy, IconLink, IconLink2, IconLinkedin, IconList, IconLoader, IconLock, IconLogIn, IconLogOut, IconMail, IconMap, IconMapPin, IconMaximize, IconMaximize2, IconMeh, IconMenu, IconMessageCircle, IconMessageSquare, IconMic, IconMicOff, IconMinimize, IconMinimize2, IconMinus, IconMinusCircle, IconMinusSquare, IconMonitor, IconMoon, IconMoreHorizontal, IconMoreVertical, IconMousePointer, IconMove, IconMusic, IconNavigation, IconNavigation2, IconOctagon, IconPackage, IconPaperclip, IconPause, IconPauseCircle, IconPenTool, IconPercent, IconPhone, IconPhoneCall, IconPhoneForwarded, IconPhoneIncoming, IconPhoneMissed, IconPhoneOff, IconPhoneOutgoing, IconPieChart, IconPlay, IconPlayCircle, IconPlus, IconPlusCircle, IconPlusSquare, IconPocket, IconPower, IconPrinter, IconRadio, IconRefreshCcw, IconRefreshCw, IconRepeat, IconRewind, IconRotateCcw, IconRotateCw, IconRss, IconSave, IconScissors, IconSearch, IconSend, IconServer, IconSettings, IconShare, IconShare2, IconShield, IconShieldOff, IconShoppingBag, IconShoppingCart, IconShuffle, IconSidebar, IconSkipBack, IconSkipForward, IconSlack, IconSlash, IconSliders, IconSmartphone, IconSmile, IconSpeaker, IconSquare, IconStar, IconStopCircle, IconSun, IconSunrise, IconSunset, IconTablet, IconTag, IconTarget, IconTerminal, IconThermometer, IconThumbsDown, IconThumbsUp, IconToggleLeft, IconToggleRight, IconTool, IconTrash, IconTrash2, IconTrello, IconTrendingDown, IconTrendingUp, IconTriangle, IconTruck, IconTv, IconTwitch, IconTwitter, IconType, IconUmbrella, IconUnderline, IconUnlock, IconUpload, IconUploadCloud, IconUser, IconUserCheck, IconUserMinus, IconUserPlus, IconUserX, IconUsers, IconVideo, IconVideoOff, IconVoicemail, IconVolume, IconVolume1, IconVolume2, IconVolumeX, IconWatch, IconWifi, IconWifiOff, IconWind, IconX, IconXCircle, IconXOctagon, IconXSquare, IconYoutube, IconZap, IconZapOff, IconZoomIn, IconZoomOut, is_size_primitive };
