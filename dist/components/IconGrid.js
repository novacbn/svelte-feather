/* src/components/IconGrid.svelte generated by Svelte v3.22.3 */
import { SvelteComponentDev, add_location, append_dev, attr_dev, check_outros, create_component, destroy_component, detach_dev, dispatch_dev, element, group_outros, init, insert_dev, listen_dev, mount_component, outro_and_destroy_block, safe_not_equal, set_data_dev, space, text, toggle_class, transition_in, transition_out, update_keyed_each, validate_each_argument, validate_each_keys, validate_slots } from "/svelte-feather/dist/"web_modules/svelte/internal.js";
import { createEventDispatcher } from "/svelte-feather/dist/"web_modules/svelte.js";
import { ICON_SIZES } from "/svelte-feather/dist/"web_modules/svelte-feather.js";
const file = "src/components/IconGrid.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-1vbaeq4-style";
  style.textContent = "section.svelte-1vbaeq4{display:grid;grid-gap:2rem;grid-template-columns:repeat(auto-fit, minmax(175px, 1fr))}article.svelte-1vbaeq4{padding-top:2rem;padding-bottom:2rem;overflow:hidden}p.svelte-1vbaeq4{margin-bottom:1rem}a.svelte-1vbaeq4{color:inherit}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbkdyaWQuc3ZlbHRlIiwic291cmNlcyI6WyJJY29uR3JpZC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQge2NyZWF0ZUV2ZW50RGlzcGF0Y2hlcn0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHtJQ09OX1NJWkVTfSBmcm9tIFwic3ZlbHRlLWZlYXRoZXJcIjtcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBleHBvcnQgbGV0IGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIjtcbiAgICBleHBvcnQgbGV0IGZpbGwgPSBcIm5vbmVcIjtcbiAgICBleHBvcnQgbGV0IGxpbmVjYXAgPSBcInJvdW5kXCI7XG4gICAgZXhwb3J0IGxldCBsaW5lam9pbiA9IFwicm91bmRcIjtcbiAgICBleHBvcnQgbGV0IHNpemUgPSBJQ09OX1NJWkVTLmRlZmF1bHQ7XG4gICAgZXhwb3J0IGxldCB3aWR0aCA9IFwiMnB4XCI7XG5cbiAgICBleHBvcnQgbGV0IGljb25zID0gW107XG5cbiAgICBmdW5jdGlvbiBvbl9hbmNob3JfY2xpY2soZXZlbnQsIGNsYXNzX25hbWUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBkaXNwYXRjaChcImNsaWNrXCIsIHtjbGFzc19uYW1lfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC1nYXA6IDJyZW07XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMTc1cHgsIDFmcikpO1xuICAgIH1cblxuICAgIGFydGljbGUge1xuICAgICAgICBwYWRkaW5nLXRvcDogMnJlbTtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDJyZW07XG5cbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG5cbiAgICBwIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcbiAgICB9XG5cbiAgICBhIHtcbiAgICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgfVxuPC9zdHlsZT5cblxuPCEtLVxuICAgIFRPRE86IE5lZWQgdG8gZml4IGdyaWQgcmVuZGVyaW5nIGl0ZW1zIGJlaW5nIHRvbyBsYXJnZSB3aGVuIGJlbG93IG1heGltdW0gcGVyIHJvdyBpdGVtc1xuLS0+XG5cbjxzZWN0aW9uPlxuICAgIHsjZWFjaCBpY29ucyBhcyB7Y29tcG9uZW50LCBjbGFzc19uYW1lLCB2aXNpYmxlfSAoY2xhc3NfbmFtZSl9XG4gICAgICAgIDxhIGhyZWY9XCIjXCIgb246Y2xpY2s9eyhldmVudCkgPT4gb25fYW5jaG9yX2NsaWNrKGV2ZW50LCBjbGFzc19uYW1lKX0+XG4gICAgICAgICAgICA8YXJ0aWNsZSBjbGFzcz1cImNhcmRcIiBjbGFzczppcy1oaWRkZW49eyF2aXNpYmxlfT5cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmVsdGU6Y29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzPXtjb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3J9XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZmlsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtsaW5lY2FwfVxuICAgICAgICAgICAgICAgICAgICAgICAge2xpbmVqb2lufVxuICAgICAgICAgICAgICAgICAgICAgICAge3NpemV9XG4gICAgICAgICAgICAgICAgICAgICAgICB7d2lkdGh9IC8+XG4gICAgICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICAgICAgPGhlYWRlciBjbGFzcz1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjb2RlPntjbGFzc19uYW1lfTwvY29kZT5cbiAgICAgICAgICAgICAgICAgICAgPC9zbWFsbD5cbiAgICAgICAgICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgICAgIDwvYXJ0aWNsZT5cbiAgICAgICAgPC9hPlxuICAgIHsvZWFjaH1cbjwvc2VjdGlvbj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF3QkksT0FBTyxlQUFDLENBQUMsQUFDTCxPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxJQUFJLENBQ2QscUJBQXFCLENBQUUsT0FBTyxRQUFRLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQy9ELENBQUMsQUFFRCxPQUFPLGVBQUMsQ0FBQyxBQUNMLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLGNBQWMsQ0FBRSxJQUFJLENBRXBCLFFBQVEsQ0FBRSxNQUFNLEFBQ3BCLENBQUMsQUFFRCxDQUFDLGVBQUMsQ0FBQyxBQUNDLGFBQWEsQ0FBRSxJQUFJLEFBQ3ZCLENBQUMsQUFFRCxDQUFDLGVBQUMsQ0FBQyxBQUNDLEtBQUssQ0FBRSxPQUFPLEFBQ2xCLENBQUMifQ== */";
  append_dev(document.head, style);
}

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i].component;
  child_ctx[11] = list[i].class_name;
  child_ctx[12] = list[i].visible;
  return child_ctx;
} // (52:4) {#each icons as {component, class_name, visible}


function create_each_block(key_1, ctx) {
  let a;
  let article;
  let p;
  let t0;
  let header;
  let small;
  let code;
  let t1_value =
  /*class_name*/
  ctx[11] + "";
  let t1;
  let t2;
  let current;
  let dispose;
  var switch_value =
  /*component*/
  ctx[10];

  function switch_props(ctx) {
    return {
      props: {
        color:
        /*color*/
        ctx[0],
        fill:
        /*fill*/
        ctx[1],
        linecap:
        /*linecap*/
        ctx[2],
        linejoin:
        /*linejoin*/
        ctx[3],
        size:
        /*size*/
        ctx[4],
        width:
        /*width*/
        ctx[5]
      },
      $$inline: true
    };
  }

  if (switch_value) {
    var switch_instance = new switch_value(switch_props(ctx));
  }

  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[9](
      /*class_name*/
      ctx[11], ...args)
    );
  }

  const block = {
    key: key_1,
    first: null,
    c: function create() {
      a = element("a");
      article = element("article");
      p = element("p");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      t0 = space();
      header = element("header");
      small = element("small");
      code = element("code");
      t1 = text(t1_value);
      t2 = space();
      attr_dev(p, "class", "text-center svelte-1vbaeq4");
      add_location(p, file, 54, 16, 1212);
      add_location(code, file, 67, 24, 1632);
      add_location(small, file, 66, 20, 1600);
      attr_dev(header, "class", "text-center");
      add_location(header, file, 65, 16, 1551);
      attr_dev(article, "class", "card svelte-1vbaeq4");
      toggle_class(article, "is-hidden", !
      /*visible*/
      ctx[12]);
      add_location(article, file, 53, 12, 1146);
      attr_dev(a, "href", "#");
      attr_dev(a, "class", "svelte-1vbaeq4");
      add_location(a, file, 52, 8, 1064);
      this.first = a;
    },
    m: function mount(target, anchor, remount) {
      insert_dev(target, a, anchor);
      append_dev(a, article);
      append_dev(article, p);

      if (switch_instance) {
        mount_component(switch_instance, p, null);
      }

      append_dev(article, t0);
      append_dev(article, header);
      append_dev(header, small);
      append_dev(small, code);
      append_dev(code, t1);
      append_dev(a, t2);
      current = true;
      if (remount) dispose();
      dispose = listen_dev(a, "click", click_handler, false, false, false);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty &
      /*color*/
      1) switch_instance_changes.color =
      /*color*/
      ctx[0];
      if (dirty &
      /*fill*/
      2) switch_instance_changes.fill =
      /*fill*/
      ctx[1];
      if (dirty &
      /*linecap*/
      4) switch_instance_changes.linecap =
      /*linecap*/
      ctx[2];
      if (dirty &
      /*linejoin*/
      8) switch_instance_changes.linejoin =
      /*linejoin*/
      ctx[3];
      if (dirty &
      /*size*/
      16) switch_instance_changes.size =
      /*size*/
      ctx[4];
      if (dirty &
      /*width*/
      32) switch_instance_changes.width =
      /*width*/
      ctx[5];

      if (switch_value !== (switch_value =
      /*component*/
      ctx[10])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, p, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }

      if ((!current || dirty &
      /*icons*/
      64) && t1_value !== (t1_value =
      /*class_name*/
      ctx[11] + "")) set_data_dev(t1, t1_value);

      if (dirty &
      /*icons*/
      64) {
        toggle_class(article, "is-hidden", !
        /*visible*/
        ctx[12]);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(a);
      if (switch_instance) destroy_component(switch_instance);
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(52:4) {#each icons as {component, class_name, visible}",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let current;
  let each_value =
  /*icons*/
  ctx[6];
  validate_each_argument(each_value);

  const get_key = ctx =>
  /*class_name*/
  ctx[11];

  validate_each_keys(ctx, each_value, get_each_context, get_key);

  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }

  const block = {
    c: function create() {
      section = element("section");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      attr_dev(section, "class", "svelte-1vbaeq4");
      add_location(section, file, 50, 0, 979);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, section, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(section, null);
      }

      current = true;
    },
    p: function update(ctx, [dirty]) {
      if (dirty &
      /*on_anchor_click, icons, color, fill, linecap, linejoin, size, width*/
      255) {
        const each_value =
        /*icons*/
        ctx[6];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, section, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }

      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }

      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(section);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let {
    color = "currentColor"
  } = $$props;
  let {
    fill = "none"
  } = $$props;
  let {
    linecap = "round"
  } = $$props;
  let {
    linejoin = "round"
  } = $$props;
  let {
    size = ICON_SIZES.default
  } = $$props;
  let {
    width = "2px"
  } = $$props;
  let {
    icons = []
  } = $$props;

  function on_anchor_click(event, class_name) {
    event.preventDefault();
    dispatch("click", {
      class_name
    });
  }

  const writable_props = ["color", "fill", "linecap", "linejoin", "size", "width", "icons"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconGrid> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("IconGrid", $$slots, []);

  const click_handler = (class_name, event) => on_anchor_click(event, class_name);

  $$self.$set = $$props => {
    if ("color" in $$props) $$invalidate(0, color = $$props.color);
    if ("fill" in $$props) $$invalidate(1, fill = $$props.fill);
    if ("linecap" in $$props) $$invalidate(2, linecap = $$props.linecap);
    if ("linejoin" in $$props) $$invalidate(3, linejoin = $$props.linejoin);
    if ("size" in $$props) $$invalidate(4, size = $$props.size);
    if ("width" in $$props) $$invalidate(5, width = $$props.width);
    if ("icons" in $$props) $$invalidate(6, icons = $$props.icons);
  };

  $$self.$capture_state = () => ({
    createEventDispatcher,
    ICON_SIZES,
    dispatch,
    color,
    fill,
    linecap,
    linejoin,
    size,
    width,
    icons,
    on_anchor_click
  });

  $$self.$inject_state = $$props => {
    if ("color" in $$props) $$invalidate(0, color = $$props.color);
    if ("fill" in $$props) $$invalidate(1, fill = $$props.fill);
    if ("linecap" in $$props) $$invalidate(2, linecap = $$props.linecap);
    if ("linejoin" in $$props) $$invalidate(3, linejoin = $$props.linejoin);
    if ("size" in $$props) $$invalidate(4, size = $$props.size);
    if ("width" in $$props) $$invalidate(5, width = $$props.width);
    if ("icons" in $$props) $$invalidate(6, icons = $$props.icons);
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  return [color, fill, linecap, linejoin, size, width, icons, on_anchor_click, dispatch, click_handler];
}

class IconGrid extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-1vbaeq4-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      color: 0,
      fill: 1,
      linecap: 2,
      linejoin: 3,
      size: 4,
      width: 5,
      icons: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IconGrid",
      options,
      id: create_fragment.name
    });
  }

  get color() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set color(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get fill() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set fill(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get linecap() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set linecap(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get linejoin() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set linejoin(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get size() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set size(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get width() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set width(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get icons() {
    throw new Error("<IconGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set icons(value) {
    throw new Error("<IconGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default IconGrid;